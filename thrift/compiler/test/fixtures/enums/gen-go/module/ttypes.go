// Autogenerated by Thrift Compiler (facebook)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
// @generated

package module

import (
	"bytes"
	"context"
	"sync"
	"fmt"
	thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
	thrift0 "thrift/annotation/thrift"

)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = sync.Mutex{}
var _ = bytes.Equal
var _ = context.Background

var _ = thrift0.GoUnusedProtection__
var GoUnusedProtection__ int;

type Metasyntactic int64
const (
  Metasyntactic_FOO Metasyntactic = 1
  Metasyntactic_BAR Metasyntactic = 2
  Metasyntactic_BAZ Metasyntactic = 3
  Metasyntactic_BAX Metasyntactic = 4
  Metasyntactic_Unspecified Metasyntactic = 0
)

var MetasyntacticToName = map[Metasyntactic]string {
  Metasyntactic_FOO: "FOO",
  Metasyntactic_BAR: "BAR",
  Metasyntactic_BAZ: "BAZ",
  Metasyntactic_BAX: "BAX",
  Metasyntactic_Unspecified: "Unspecified",
}

var MetasyntacticToValue = map[string]Metasyntactic {
  "FOO": Metasyntactic_FOO,
  "BAR": Metasyntactic_BAR,
  "BAZ": Metasyntactic_BAZ,
  "BAX": Metasyntactic_BAX,
  "Unspecified": Metasyntactic_Unspecified,
}

var MetasyntacticNames = []string {
  "FOO",
  "BAR",
  "BAZ",
  "BAX",
  "Unspecified",
}

var MetasyntacticValues = []Metasyntactic {
  Metasyntactic_FOO,
  Metasyntactic_BAR,
  Metasyntactic_BAZ,
  Metasyntactic_BAX,
  Metasyntactic_Unspecified,
}

func (p Metasyntactic) String() string {
  if v, ok := MetasyntacticToName[p]; ok {
    return v
  }
  return "<UNSET>"
}

func MetasyntacticFromString(s string) (Metasyntactic, error) {
  if v, ok := MetasyntacticToValue[s]; ok {
    return v, nil
  }
  return Metasyntactic(0), fmt.Errorf("not a valid Metasyntactic string")
}

func MetasyntacticPtr(v Metasyntactic) *Metasyntactic { return &v }

// Attributes:
//  - Reasonable
//  - Fine
//  - Questionable
//  - Tags
type SomeStruct struct {
  Reasonable Metasyntactic `thrift:"reasonable,1" db:"reasonable" json:"reasonable"`
  Fine Metasyntactic `thrift:"fine,2" db:"fine" json:"fine"`
  Questionable Metasyntactic `thrift:"questionable,3" db:"questionable" json:"questionable"`
  Tags []int32 `thrift:"tags,4" db:"tags" json:"tags"`
}

func NewSomeStruct() *SomeStruct {
  return &SomeStruct{
    Reasonable: 1,
    Fine: 2,
    Questionable: -1,
    Tags: []int32{
    },
  }
}


func (p *SomeStruct) GetReasonable() Metasyntactic {
  return p.Reasonable
}

func (p *SomeStruct) GetFine() Metasyntactic {
  return p.Fine
}

func (p *SomeStruct) GetQuestionable() Metasyntactic {
  return p.Questionable
}

func (p *SomeStruct) GetTags() []int32 {
  return p.Tags
}
type SomeStructBuilder struct {
  obj *SomeStruct
}

func NewSomeStructBuilder() *SomeStructBuilder{
  return &SomeStructBuilder{
    obj: NewSomeStruct(),
  }
}

func (p SomeStructBuilder) Emit() *SomeStruct{
  return &SomeStruct{
    Reasonable: p.obj.Reasonable,
    Fine: p.obj.Fine,
    Questionable: p.obj.Questionable,
    Tags: p.obj.Tags,
  }
}

func (s *SomeStructBuilder) Reasonable(reasonable Metasyntactic) *SomeStructBuilder {
  s.obj.Reasonable = reasonable
  return s
}

func (s *SomeStructBuilder) Fine(fine Metasyntactic) *SomeStructBuilder {
  s.obj.Fine = fine
  return s
}

func (s *SomeStructBuilder) Questionable(questionable Metasyntactic) *SomeStructBuilder {
  s.obj.Questionable = questionable
  return s
}

func (s *SomeStructBuilder) Tags(tags []int32) *SomeStructBuilder {
  s.obj.Tags = tags
  return s
}

func (s *SomeStruct) SetReasonable(reasonable Metasyntactic) *SomeStruct {
  s.Reasonable = reasonable
  return s
}

func (s *SomeStruct) SetFine(fine Metasyntactic) *SomeStruct {
  s.Fine = fine
  return s
}

func (s *SomeStruct) SetQuestionable(questionable Metasyntactic) *SomeStruct {
  s.Questionable = questionable
  return s
}

func (s *SomeStruct) SetTags(tags []int32) *SomeStruct {
  s.Tags = tags
  return s
}

func (p *SomeStruct) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SomeStruct)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    temp := Metasyntactic(v)
    p.Reasonable = temp
  }
  return nil
}

func (p *SomeStruct)  ReadField2(iprot thrift.Protocol) error {
  if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 2: ", err)
  } else {
    temp := Metasyntactic(v)
    p.Fine = temp
  }
  return nil
}

func (p *SomeStruct)  ReadField3(iprot thrift.Protocol) error {
  if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 3: ", err)
  } else {
    temp := Metasyntactic(v)
    p.Questionable = temp
  }
  return nil
}

func (p *SomeStruct)  ReadField4(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadSetBegin()
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]int32, 0, size)
  p.Tags =  tSet
  for i := 0; i < size; i ++ {
    var _elem1 int32
    if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
    } else {
      _elem1 = v
    }
    p.Tags = append(p.Tags, _elem1)
  }
  if err := iprot.ReadSetEnd(); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *SomeStruct) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("SomeStruct"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := p.writeField2(oprot); err != nil { return err }
  if err := p.writeField3(oprot); err != nil { return err }
  if err := p.writeField4(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SomeStruct) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("reasonable", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:reasonable: ", p), err) }
  if err := oprot.WriteI32(int32(p.Reasonable)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.reasonable (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:reasonable: ", p), err) }
  return err
}

func (p *SomeStruct) writeField2(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("fine", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:fine: ", p), err) }
  if err := oprot.WriteI32(int32(p.Fine)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.fine (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:fine: ", p), err) }
  return err
}

func (p *SomeStruct) writeField3(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("questionable", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:questionable: ", p), err) }
  if err := oprot.WriteI32(int32(p.Questionable)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.questionable (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:questionable: ", p), err) }
  return err
}

func (p *SomeStruct) writeField4(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("tags", thrift.SET, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:tags: ", p), err) }
  if err := oprot.WriteSetBegin(thrift.I32, len(p.Tags)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  set := make(map[int32]bool, len(p.Tags))
  for _, v := range p.Tags {
    if ok := set[v]; ok {
      return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", v))
    }
    set[v] = true
  }
  for _, v := range p.Tags {
    if err := oprot.WriteI32(int32(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteSetEnd(); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:tags: ", p), err) }
  return err
}

func (p *SomeStruct) String() string {
  if p == nil {
    return "<nil>"
  }

  reasonableVal := fmt.Sprintf("%v", p.Reasonable)
  fineVal := fmt.Sprintf("%v", p.Fine)
  questionableVal := fmt.Sprintf("%v", p.Questionable)
  tagsVal := fmt.Sprintf("%v", p.Tags)
  return fmt.Sprintf("SomeStruct({Reasonable:%s Fine:%s Questionable:%s Tags:%s})", reasonableVal, fineVal, questionableVal, tagsVal)
}

