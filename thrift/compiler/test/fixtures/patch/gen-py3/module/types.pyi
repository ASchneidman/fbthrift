#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

import folly.iobuf as _fbthrift_iobuf
import thrift.py3.types
import thrift.py3.exceptions
from thrift.py3.types import __NotSet, NOTSET
import typing as _typing
from typing_extensions import Final

import sys
import itertools
import patch.types as _patch_types


__property__ = property


class MyStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        boolVal: bool
        byteVal: bool
        i16Val: bool
        i32Val: bool
        i64Val: bool
        floatVal: bool
        doubleVal: bool
        stringVal: bool
        binaryVal: bool
        pass

    boolVal: Final[bool] = ...

    byteVal: Final[int] = ...

    i16Val: Final[int] = ...

    i32Val: Final[int] = ...

    i64Val: Final[int] = ...

    floatVal: Final[float] = ...

    doubleVal: Final[float] = ...

    stringVal: Final[str] = ...

    binaryVal: Final[bytes] = ...

    def __init__(
        self, *,
        boolVal: _typing.Optional[bool]=None,
        byteVal: _typing.Optional[int]=None,
        i16Val: _typing.Optional[int]=None,
        i32Val: _typing.Optional[int]=None,
        i64Val: _typing.Optional[int]=None,
        floatVal: _typing.Optional[float]=None,
        doubleVal: _typing.Optional[float]=None,
        stringVal: _typing.Optional[str]=None,
        binaryVal: _typing.Optional[bytes]=None
    ) -> None: ...

    def __call__(
        self, *,
        boolVal: _typing.Union[bool, __NotSet, None]=NOTSET,
        byteVal: _typing.Union[int, __NotSet, None]=NOTSET,
        i16Val: _typing.Union[int, __NotSet, None]=NOTSET,
        i32Val: _typing.Union[int, __NotSet, None]=NOTSET,
        i64Val: _typing.Union[int, __NotSet, None]=NOTSET,
        floatVal: _typing.Union[float, __NotSet, None]=NOTSET,
        doubleVal: _typing.Union[float, __NotSet, None]=NOTSET,
        stringVal: _typing.Union[str, __NotSet, None]=NOTSET,
        binaryVal: _typing.Union[bytes, __NotSet, None]=NOTSET
    ) -> MyStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['MyStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'MyStruct') -> bool: ...
    def __gt__(self, other: 'MyStruct') -> bool: ...
    def __le__(self, other: 'MyStruct') -> bool: ...
    def __ge__(self, other: 'MyStruct') -> bool: ...


class MyStructPatch(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        boolVal: bool
        byteVal: bool
        i16Val: bool
        i32Val: bool
        i64Val: bool
        floatVal: bool
        doubleVal: bool
        stringVal: bool
        binaryVal: bool
        pass

    boolVal: Final[_patch_types.BoolPatch] = ...

    byteVal: Final[_patch_types.BytePatch] = ...

    i16Val: Final[_patch_types.I16Patch] = ...

    i32Val: Final[_patch_types.I32Patch] = ...

    i64Val: Final[_patch_types.I64Patch] = ...

    floatVal: Final[_patch_types.FloatPatch] = ...

    doubleVal: Final[_patch_types.DoublePatch] = ...

    stringVal: Final[_patch_types.StringPatch] = ...

    binaryVal: Final[_patch_types.BinaryPatch] = ...

    def __init__(
        self, *,
        boolVal: _typing.Optional[_patch_types.BoolPatch]=None,
        byteVal: _typing.Optional[_patch_types.BytePatch]=None,
        i16Val: _typing.Optional[_patch_types.I16Patch]=None,
        i32Val: _typing.Optional[_patch_types.I32Patch]=None,
        i64Val: _typing.Optional[_patch_types.I64Patch]=None,
        floatVal: _typing.Optional[_patch_types.FloatPatch]=None,
        doubleVal: _typing.Optional[_patch_types.DoublePatch]=None,
        stringVal: _typing.Optional[_patch_types.StringPatch]=None,
        binaryVal: _typing.Optional[_patch_types.BinaryPatch]=None
    ) -> None: ...

    def __call__(
        self, *,
        boolVal: _typing.Union[_patch_types.BoolPatch, __NotSet, None]=NOTSET,
        byteVal: _typing.Union[_patch_types.BytePatch, __NotSet, None]=NOTSET,
        i16Val: _typing.Union[_patch_types.I16Patch, __NotSet, None]=NOTSET,
        i32Val: _typing.Union[_patch_types.I32Patch, __NotSet, None]=NOTSET,
        i64Val: _typing.Union[_patch_types.I64Patch, __NotSet, None]=NOTSET,
        floatVal: _typing.Union[_patch_types.FloatPatch, __NotSet, None]=NOTSET,
        doubleVal: _typing.Union[_patch_types.DoublePatch, __NotSet, None]=NOTSET,
        stringVal: _typing.Union[_patch_types.StringPatch, __NotSet, None]=NOTSET,
        binaryVal: _typing.Union[_patch_types.BinaryPatch, __NotSet, None]=NOTSET
    ) -> MyStructPatch: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['MyStructPatch'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'MyStructPatch') -> bool: ...
    def __gt__(self, other: 'MyStructPatch') -> bool: ...
    def __le__(self, other: 'MyStructPatch') -> bool: ...
    def __ge__(self, other: 'MyStructPatch') -> bool: ...


class MyStructValuePatch(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        assign: bool
        clear: bool
        patch: bool
        pass

    assign: Final[_typing.Optional[MyStruct]] = ...

    clear: Final[bool] = ...

    patch: Final[MyStructPatch] = ...

    def __init__(
        self, *,
        assign: _typing.Optional[MyStruct]=None,
        clear: _typing.Optional[bool]=None,
        patch: _typing.Optional[MyStructPatch]=None
    ) -> None: ...

    def __call__(
        self, *,
        assign: _typing.Union[MyStruct, __NotSet, None]=NOTSET,
        clear: _typing.Union[bool, __NotSet, None]=NOTSET,
        patch: _typing.Union[MyStructPatch, __NotSet, None]=NOTSET
    ) -> MyStructValuePatch: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['MyStructValuePatch'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'MyStructValuePatch') -> bool: ...
    def __gt__(self, other: 'MyStructValuePatch') -> bool: ...
    def __le__(self, other: 'MyStructValuePatch') -> bool: ...
    def __ge__(self, other: 'MyStructValuePatch') -> bool: ...


class OptionalMyStructValuePatch(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        clear: bool
        patch: bool
        ensure: bool
        patchAfter: bool
        pass

    clear: Final[bool] = ...

    patch: Final[MyStructValuePatch] = ...

    ensure: Final[_typing.Optional[MyStruct]] = ...

    patchAfter: Final[MyStructValuePatch] = ...

    def __init__(
        self, *,
        clear: _typing.Optional[bool]=None,
        patch: _typing.Optional[MyStructValuePatch]=None,
        ensure: _typing.Optional[MyStruct]=None,
        patchAfter: _typing.Optional[MyStructValuePatch]=None
    ) -> None: ...

    def __call__(
        self, *,
        clear: _typing.Union[bool, __NotSet, None]=NOTSET,
        patch: _typing.Union[MyStructValuePatch, __NotSet, None]=NOTSET,
        ensure: _typing.Union[MyStruct, __NotSet, None]=NOTSET,
        patchAfter: _typing.Union[MyStructValuePatch, __NotSet, None]=NOTSET
    ) -> OptionalMyStructValuePatch: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['OptionalMyStructValuePatch'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'OptionalMyStructValuePatch') -> bool: ...
    def __gt__(self, other: 'OptionalMyStructValuePatch') -> bool: ...
    def __le__(self, other: 'OptionalMyStructValuePatch') -> bool: ...
    def __ge__(self, other: 'OptionalMyStructValuePatch') -> bool: ...


