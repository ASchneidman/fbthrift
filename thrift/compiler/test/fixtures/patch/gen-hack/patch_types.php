<?hh
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

/**
 * Original thrift struct:-
 * BoolPatch
 */
class BoolPatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::BOOL,
    ),
    2 => shape(
      'var' => 'invert',
      'type' => \TType::BOOL,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'invert' => 2,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?bool,
    ?'invert' => ?bool,
  );

  const type TShape = shape(
    ?'assign' => ?bool,
    'invert' => bool,
    ...
  );
  const int STRUCTURAL_ID = 3875050023329461666;
  /**
   * Original thrift field:-
   * 1: bool assign
   */
  public ?bool $assign;
  /**
   * Original thrift field:-
   * 2: bool invert
   */
  public bool $invert;

  public function __construct(?bool $assign = null, ?bool $invert = null  )[] {
    $this->assign = $assign;
    $this->invert = $invert ?? false;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'invert'),
    );
  }

  public function getName()[]: string {
    return 'BoolPatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.BoolPatch",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "invert",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        'facebook_thrift_annotation_thrift_Experimental' => facebook_thrift_annotation_thrift_Experimental::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['invert'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'invert' => $this->invert,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $this->assign = /* HH_FIXME[4110] */ $parsed['assign'];
    }    
    if (idx($parsed, 'invert') !== null) {
      $this->invert = /* HH_FIXME[4110] */ $parsed['invert'];
    }    
  }

}

/**
 * Original thrift struct:-
 * BytePatch
 */
class BytePatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::BYTE,
    ),
    2 => shape(
      'var' => 'add',
      'type' => \TType::BYTE,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'add' => 2,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?int,
    ?'add' => ?int,
  );

  const type TShape = shape(
    ?'assign' => ?int,
    'add' => int,
    ...
  );
  const int STRUCTURAL_ID = 4364926226693714377;
  /**
   * Original thrift field:-
   * 1: byte assign
   */
  public ?int $assign;
  /**
   * Original thrift field:-
   * 2: byte add
   */
  public int $add;

  public function __construct(?int $assign = null, ?int $add = null  )[] {
    $this->assign = $assign;
    $this->add = $add ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'add'),
    );
  }

  public function getName()[]: string {
    return 'BytePatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.BytePatch",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BYTE_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BYTE_TYPE,
                )
              ),
              "name" => "add",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        'facebook_thrift_annotation_thrift_Experimental' => facebook_thrift_annotation_thrift_Experimental::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['add'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'add' => $this->add,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $_tmp0 = (int)/* HH_FIXME[4110] */ $parsed['assign'];
      if ($_tmp0 > 0x7f) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->assign = (int)$_tmp0;
      }
    }    
    if (idx($parsed, 'add') !== null) {
      $_tmp1 = (int)/* HH_FIXME[4110] */ $parsed['add'];
      if ($_tmp1 > 0x7f) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->add = (int)$_tmp1;
      }
    }    
  }

}

/**
 * Original thrift struct:-
 * I16Patch
 */
class I16Patch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::I16,
    ),
    2 => shape(
      'var' => 'add',
      'type' => \TType::I16,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'add' => 2,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?int,
    ?'add' => ?int,
  );

  const type TShape = shape(
    ?'assign' => ?int,
    'add' => int,
    ...
  );
  const int STRUCTURAL_ID = 7982053966984816637;
  /**
   * Original thrift field:-
   * 1: i16 assign
   */
  public ?int $assign;
  /**
   * Original thrift field:-
   * 2: i16 add
   */
  public int $add;

  public function __construct(?int $assign = null, ?int $add = null  )[] {
    $this->assign = $assign;
    $this->add = $add ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'add'),
    );
  }

  public function getName()[]: string {
    return 'I16Patch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.I16Patch",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I16_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I16_TYPE,
                )
              ),
              "name" => "add",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        'facebook_thrift_annotation_thrift_Experimental' => facebook_thrift_annotation_thrift_Experimental::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['add'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'add' => $this->add,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $_tmp0 = (int)/* HH_FIXME[4110] */ $parsed['assign'];
      if ($_tmp0 > 0x7fff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->assign = (int)$_tmp0;
      }
    }    
    if (idx($parsed, 'add') !== null) {
      $_tmp1 = (int)/* HH_FIXME[4110] */ $parsed['add'];
      if ($_tmp1 > 0x7fff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->add = (int)$_tmp1;
      }
    }    
  }

}

/**
 * Original thrift struct:-
 * I32Patch
 */
class I32Patch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::I32,
    ),
    2 => shape(
      'var' => 'add',
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'add' => 2,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?int,
    ?'add' => ?int,
  );

  const type TShape = shape(
    ?'assign' => ?int,
    'add' => int,
    ...
  );
  const int STRUCTURAL_ID = 1442315754779904080;
  /**
   * Original thrift field:-
   * 1: i32 assign
   */
  public ?int $assign;
  /**
   * Original thrift field:-
   * 2: i32 add
   */
  public int $add;

  public function __construct(?int $assign = null, ?int $add = null  )[] {
    $this->assign = $assign;
    $this->add = $add ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'add'),
    );
  }

  public function getName()[]: string {
    return 'I32Patch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.I32Patch",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "add",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        'facebook_thrift_annotation_thrift_Experimental' => facebook_thrift_annotation_thrift_Experimental::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['add'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'add' => $this->add,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $_tmp0 = (int)/* HH_FIXME[4110] */ $parsed['assign'];
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->assign = (int)$_tmp0;
      }
    }    
    if (idx($parsed, 'add') !== null) {
      $_tmp1 = (int)/* HH_FIXME[4110] */ $parsed['add'];
      if ($_tmp1 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->add = (int)$_tmp1;
      }
    }    
  }

}

/**
 * Original thrift struct:-
 * I64Patch
 */
class I64Patch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::I64,
    ),
    2 => shape(
      'var' => 'add',
      'type' => \TType::I64,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'add' => 2,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?int,
    ?'add' => ?int,
  );

  const type TShape = shape(
    ?'assign' => ?int,
    'add' => int,
    ...
  );
  const int STRUCTURAL_ID = 6712631685845531374;
  /**
   * Original thrift field:-
   * 1: i64 assign
   */
  public ?int $assign;
  /**
   * Original thrift field:-
   * 2: i64 add
   */
  public int $add;

  public function __construct(?int $assign = null, ?int $add = null  )[] {
    $this->assign = $assign;
    $this->add = $add ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'add'),
    );
  }

  public function getName()[]: string {
    return 'I64Patch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.I64Patch",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "add",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        'facebook_thrift_annotation_thrift_Experimental' => facebook_thrift_annotation_thrift_Experimental::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['add'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'add' => $this->add,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $this->assign = /* HH_FIXME[4110] */ $parsed['assign'];
    }    
    if (idx($parsed, 'add') !== null) {
      $this->add = /* HH_FIXME[4110] */ $parsed['add'];
    }    
  }

}

/**
 * Original thrift struct:-
 * FloatPatch
 */
class FloatPatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::FLOAT,
    ),
    2 => shape(
      'var' => 'add',
      'type' => \TType::FLOAT,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'add' => 2,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?float,
    ?'add' => ?float,
  );

  const type TShape = shape(
    ?'assign' => ?float,
    'add' => float,
    ...
  );
  const int STRUCTURAL_ID = 8559016797145234950;
  /**
   * Original thrift field:-
   * 1: float assign
   */
  public ?float $assign;
  /**
   * Original thrift field:-
   * 2: float add
   */
  public float $add;

  public function __construct(?float $assign = null, ?float $add = null  )[] {
    $this->assign = $assign;
    $this->add = $add ?? 0.0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'add'),
    );
  }

  public function getName()[]: string {
    return 'FloatPatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.FloatPatch",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_FLOAT_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_FLOAT_TYPE,
                )
              ),
              "name" => "add",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        'facebook_thrift_annotation_thrift_Experimental' => facebook_thrift_annotation_thrift_Experimental::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['add'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'add' => $this->add,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $this->assign = /* HH_FIXME[4110] */ $parsed['assign'];
    }    
    if (idx($parsed, 'add') !== null) {
      $this->add = /* HH_FIXME[4110] */ $parsed['add'];
    }    
  }

}

/**
 * Original thrift struct:-
 * DoublePatch
 */
class DoublePatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::DOUBLE,
    ),
    2 => shape(
      'var' => 'add',
      'type' => \TType::DOUBLE,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'add' => 2,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?float,
    ?'add' => ?float,
  );

  const type TShape = shape(
    ?'assign' => ?float,
    'add' => float,
    ...
  );
  const int STRUCTURAL_ID = 2907066783911210347;
  /**
   * Original thrift field:-
   * 1: double assign
   */
  public ?float $assign;
  /**
   * Original thrift field:-
   * 2: double add
   */
  public float $add;

  public function __construct(?float $assign = null, ?float $add = null  )[] {
    $this->assign = $assign;
    $this->add = $add ?? 0.0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'add'),
    );
  }

  public function getName()[]: string {
    return 'DoublePatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.DoublePatch",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_DOUBLE_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_DOUBLE_TYPE,
                )
              ),
              "name" => "add",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        'facebook_thrift_annotation_thrift_Experimental' => facebook_thrift_annotation_thrift_Experimental::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['add'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'add' => $this->add,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $this->assign = /* HH_FIXME[4110] */ $parsed['assign'];
    }    
    if (idx($parsed, 'add') !== null) {
      $this->add = /* HH_FIXME[4110] */ $parsed['add'];
    }    
  }

}

/**
 * Original thrift struct:-
 * StringPatch
 */
class StringPatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'append',
      'type' => \TType::STRING,
    ),
    3 => shape(
      'var' => 'prepend',
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'append' => 2,
    'prepend' => 3,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?string,
    ?'append' => ?string,
    ?'prepend' => ?string,
  );

  const type TShape = shape(
    ?'assign' => ?string,
    'append' => string,
    'prepend' => string,
    ...
  );
  const int STRUCTURAL_ID = 75028268814464515;
  /**
   * Original thrift field:-
   * 1: string assign
   */
  public ?string $assign;
  /**
   * Original thrift field:-
   * 2: string append
   */
  public string $append;
  /**
   * Original thrift field:-
   * 3: string prepend
   */
  public string $prepend;

  public function __construct(?string $assign = null, ?string $append = null, ?string $prepend = null  )[] {
    $this->assign = $assign;
    $this->append = $append ?? '';
    $this->prepend = $prepend ?? '';
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'append'),
      Shapes::idx($shape, 'prepend'),
    );
  }

  public function getName()[]: string {
    return 'StringPatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.StringPatch",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "append",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "prepend",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        'facebook_thrift_annotation_thrift_Experimental' => facebook_thrift_annotation_thrift_Experimental::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['append'],
      $shape['prepend'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'append' => $this->append,
      'prepend' => $this->prepend,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $this->assign = /* HH_FIXME[4110] */ $parsed['assign'];
    }    
    if (idx($parsed, 'append') !== null) {
      $this->append = /* HH_FIXME[4110] */ $parsed['append'];
    }    
    if (idx($parsed, 'prepend') !== null) {
      $this->prepend = /* HH_FIXME[4110] */ $parsed['prepend'];
    }    
  }

}

/**
 * Original thrift struct:-
 * BinaryPatch
 */
class BinaryPatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?string,
  );

  const type TShape = shape(
    ?'assign' => ?string,
    ...
  );
  const int STRUCTURAL_ID = 6677740157096629654;
  /**
   * Original thrift field:-
   * 1: binary assign
   */
  public ?string $assign;

  public function __construct(?string $assign = null  )[] {
    $this->assign = $assign;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
    );
  }

  public function getName()[]: string {
    return 'BinaryPatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.BinaryPatch",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BINARY_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        'facebook_thrift_annotation_thrift_Experimental' => facebook_thrift_annotation_thrift_Experimental::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $this->assign = /* HH_FIXME[4110] */ $parsed['assign'];
    }    
  }

}

