#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.annotation.thrift.ttypes
import thrift.lib.thrift.patch.ttypes
import thrift.lib.thrift.standard.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'MyEnum', 'MyData', 'InnerUnion', 'MyUnion', 'MyStruct', 'LateDefStruct', 'Recursive', 'Bar', 'Loop', 'MyDataEnsureStruct', 'MyDataFieldPatch', 'MyDataPatch', 'InnerUnionFieldPatch', 'InnerUnionPatch', 'MyUnionFieldPatch', 'MyUnionPatch', 'MyStructEnsureStruct', 'MyStructField10Patch', 'MyStructField23Patch', 'MyStructField26Patch', 'MyStructField27Patch', 'MyStructField28Patch', 'MyStructField29Patch', 'MyStructField29Patch1', 'MyStructField30Patch', 'MyStructField30Patch1', 'MyStructFieldPatch', 'MyStructPatch', 'LateDefStructEnsureStruct', 'LateDefStructFieldPatch', 'LateDefStructPatch', 'RecursiveEnsureStruct', 'RecursiveField1Patch', 'RecursiveFieldPatch', 'RecursivePatch', 'BarEnsureStruct', 'BarFieldPatch', 'BarPatch', 'LoopEnsureStruct', 'LoopFieldPatch', 'LoopPatch']

class MyEnum:
  MyValue0 = 0

  _VALUES_TO_NAMES = {
    0: "MyValue0",
  }

  _NAMES_TO_VALUES = {
    "MyValue0": 0,
  }

class MyData:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.data2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyData')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRING, 1)
      oprot.writeString(self.data1.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data1, bytes) else oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.I32, 2)
      oprot.writeI32(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = json_obj['data1']
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = json_obj['data2']
      if self.data2 > 0x7fffffff or self.data2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyData, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyData, self)

  def _to_py_deprecated(self):
    return self

class InnerUnion(object):
  r"""
  Attributes:
   - innerOption
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  INNEROPTION = 1
  
  @staticmethod
  def isUnion():
    return True

  def get_innerOption(self):
    assert self.field == 1
    return self.value

  def set_innerOption(self, value):
    self.field = 1
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('innerOption', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRING:
          _fbthrift_innerOption = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_innerOption(_fbthrift_innerOption)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('InnerUnion')
    if self.field == 1:
      oprot.writeFieldBegin('innerOption', TType.STRING, 1)
      innerOption = self.value
      oprot.writeString(innerOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'innerOption' in obj:
      _fbthrift_innerOption = obj['innerOption']
      self.set_innerOption(_fbthrift_innerOption)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.InnerUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.InnerUnion, self)

  def _to_py_deprecated(self):
    return self

class MyUnion(object):
  r"""
  Attributes:
   - option1
   - option2
   - option3
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  OPTION1 = 1
  OPTION2 = 2
  OPTION3 = 3
  
  @staticmethod
  def isUnion():
    return True

  def get_option1(self):
    assert self.field == 1
    return self.value

  def get_option2(self):
    assert self.field == 2
    return self.value

  def get_option3(self):
    assert self.field == 3
    return self.value

  def set_option1(self, value):
    self.field = 1
    self.value = value

  def set_option2(self, value):
    self.field = 2
    self.value = value

  def set_option3(self, value):
    self.field = 3
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option1', value)
    if self.field == 2:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option2', value)
    if self.field == 3:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option3', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRING:
          _fbthrift_option1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_option1(_fbthrift_option1)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          _fbthrift_option2 = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_option2(_fbthrift_option2)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          _fbthrift_option3 = InnerUnion()
          _fbthrift_option3.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_option3(_fbthrift_option3)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('MyUnion')
    if self.field == 1:
      oprot.writeFieldBegin('option1', TType.STRING, 1)
      option1 = self.value
      oprot.writeString(option1.encode('utf-8')) if UTF8STRINGS and not isinstance(option1, bytes) else oprot.writeString(option1)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('option2', TType.I32, 2)
      option2 = self.value
      oprot.writeI32(option2)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('option3', TType.STRUCT, 3)
      option3 = self.value
      option3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'option1' in obj:
      _fbthrift_option1 = obj['option1']
      self.set_option1(_fbthrift_option1)
    if 'option2' in obj:
      _fbthrift_option2 = obj['option2']
      if _fbthrift_option2 > 0x7fffffff or _fbthrift_option2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_option2(_fbthrift_option2)
    if 'option3' in obj:
      _fbthrift_option3 = InnerUnion()
      _fbthrift_option3.readFromJson(obj['option3'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
      self.set_option3(_fbthrift_option3)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnion, self)

  def _to_py_deprecated(self):
    return self

class MyStruct:
  r"""
  Attributes:
   - boolVal
   - byteVal
   - i16Val
   - i32Val
   - i64Val
   - floatVal
   - doubleVal
   - stringVal
   - binaryVal
   - enumVal
   - structVal
   - unionVal
   - lateStructVal
   - optBoolVal
   - optByteVal
   - optI16Val
   - optI32Val
   - optI64Val
   - optFloatVal
   - optDoubleVal
   - optStringVal
   - optBinaryVal
   - optEnumVal
   - optStructVal
   - optLateStructVal
   - optListVal
   - optSetVal
   - optMapVal
   - listMap
   - mapMap
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.BOOL:
          self.boolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.BYTE:
          self.byteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.I16:
          self.i16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.I32:
          self.i32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.I64:
          self.i64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -6:
        if ftype == TType.FLOAT:
          self.floatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -7:
        if ftype == TType.DOUBLE:
          self.doubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -8:
        if ftype == TType.STRING:
          self.stringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -9:
        if ftype == TType.STRING:
          self.binaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -10:
        if ftype == TType.I32:
          self.enumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -11:
        if ftype == TType.STRUCT:
          self.structVal = MyData()
          self.structVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -12:
        if ftype == TType.STRUCT:
          self.unionVal = MyUnion()
          self.unionVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -13:
        if ftype == TType.STRUCT:
          self.lateStructVal = LateDefStruct()
          self.lateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -14:
        if ftype == TType.BOOL:
          self.optBoolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == -15:
        if ftype == TType.BYTE:
          self.optByteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -16:
        if ftype == TType.I16:
          self.optI16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -17:
        if ftype == TType.I32:
          self.optI32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -18:
        if ftype == TType.I64:
          self.optI64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -19:
        if ftype == TType.FLOAT:
          self.optFloatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -20:
        if ftype == TType.DOUBLE:
          self.optDoubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -21:
        if ftype == TType.STRING:
          self.optStringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -22:
        if ftype == TType.STRING:
          self.optBinaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -23:
        if ftype == TType.I32:
          self.optEnumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -24:
        if ftype == TType.STRUCT:
          self.optStructVal = MyData()
          self.optStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -25:
        if ftype == TType.STRUCT:
          self.optLateStructVal = LateDefStruct()
          self.optLateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -26:
        if ftype == TType.LIST:
          self.optListVal = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readI16()
              self.optListVal.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readI16()
              self.optListVal.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -27:
        if ftype == TType.SET:
          self.optSetVal = set()
          (_etype10, _size7) = iprot.readSetBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem12)
          else: 
            while iprot.peekSet():
              _elem13 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem13)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == -28:
        if ftype == TType.MAP:
          self.optMapVal = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in range(_size14):
              _key19 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val20 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key21 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val22 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -29:
        if ftype == TType.LIST:
          self.listMap = []
          (_etype26, _size23) = iprot.readListBegin()
          if _size23 >= 0:
            for _i27 in range(_size23):
              _elem28 = {}
              (_ktype30, _vtype31, _size29 ) = iprot.readMapBegin() 
              if _size29 >= 0:
                for _i33 in range(_size29):
                  _key34 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val35 = iprot.readI32()
                  _elem28[_key34] = _val35
              else: 
                while iprot.peekMap():
                  _key36 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val37 = iprot.readI32()
                  _elem28[_key36] = _val37
              iprot.readMapEnd()
              self.listMap.append(_elem28)
          else: 
            while iprot.peekList():
              _elem38 = {}
              (_ktype40, _vtype41, _size39 ) = iprot.readMapBegin() 
              if _size39 >= 0:
                for _i43 in range(_size39):
                  _key44 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val45 = iprot.readI32()
                  _elem38[_key44] = _val45
              else: 
                while iprot.peekMap():
                  _key46 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val47 = iprot.readI32()
                  _elem38[_key46] = _val47
              iprot.readMapEnd()
              self.listMap.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -30:
        if ftype == TType.MAP:
          self.mapMap = {}
          (_ktype49, _vtype50, _size48 ) = iprot.readMapBegin() 
          if _size48 >= 0:
            for _i52 in range(_size48):
              _key53 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val54 = {}
              (_ktype56, _vtype57, _size55 ) = iprot.readMapBegin() 
              if _size55 >= 0:
                for _i59 in range(_size55):
                  _key60 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val61 = iprot.readI32()
                  _val54[_key60] = _val61
              else: 
                while iprot.peekMap():
                  _key62 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val63 = iprot.readI32()
                  _val54[_key62] = _val63
              iprot.readMapEnd()
              self.mapMap[_key53] = _val54
          else: 
            while iprot.peekMap():
              _key64 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val65 = {}
              (_ktype67, _vtype68, _size66 ) = iprot.readMapBegin() 
              if _size66 >= 0:
                for _i70 in range(_size66):
                  _key71 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val72 = iprot.readI32()
                  _val65[_key71] = _val72
              else: 
                while iprot.peekMap():
                  _key73 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val74 = iprot.readI32()
                  _val65[_key73] = _val74
              iprot.readMapEnd()
              self.mapMap[_key64] = _val65
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    if self.mapMap != None:
      oprot.writeFieldBegin('mapMap', TType.MAP, -30)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.mapMap))
      for kiter75,viter76 in self.mapMap.items():
        oprot.writeString(kiter75.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter75, bytes) else oprot.writeString(kiter75)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter76))
        for kiter77,viter78 in viter76.items():
          oprot.writeString(kiter77.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter77, bytes) else oprot.writeString(kiter77)
          oprot.writeI32(viter78)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.listMap != None:
      oprot.writeFieldBegin('listMap', TType.LIST, -29)
      oprot.writeListBegin(TType.MAP, len(self.listMap))
      for iter79 in self.listMap:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter79))
        for kiter80,viter81 in iter79.items():
          oprot.writeString(kiter80.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter80, bytes) else oprot.writeString(kiter80)
          oprot.writeI32(viter81)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optMapVal != None:
      oprot.writeFieldBegin('optMapVal', TType.MAP, -28)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.optMapVal))
      for kiter82,viter83 in self.optMapVal.items():
        oprot.writeString(kiter82.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter82, bytes) else oprot.writeString(kiter82)
        oprot.writeString(viter83.encode('utf-8')) if UTF8STRINGS and not isinstance(viter83, bytes) else oprot.writeString(viter83)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.optSetVal != None:
      oprot.writeFieldBegin('optSetVal', TType.SET, -27)
      oprot.writeSetBegin(TType.STRING, len(self.optSetVal))
      for iter84 in self.optSetVal:
        oprot.writeString(iter84.encode('utf-8')) if UTF8STRINGS and not isinstance(iter84, bytes) else oprot.writeString(iter84)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.optListVal != None:
      oprot.writeFieldBegin('optListVal', TType.LIST, -26)
      oprot.writeListBegin(TType.I16, len(self.optListVal))
      for iter85 in self.optListVal:
        oprot.writeI16(iter85)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optLateStructVal != None:
      oprot.writeFieldBegin('optLateStructVal', TType.STRUCT, -25)
      self.optLateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStructVal != None:
      oprot.writeFieldBegin('optStructVal', TType.STRUCT, -24)
      self.optStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optEnumVal != None:
      oprot.writeFieldBegin('optEnumVal', TType.I32, -23)
      oprot.writeI32(self.optEnumVal)
      oprot.writeFieldEnd()
    if self.optBinaryVal != None:
      oprot.writeFieldBegin('optBinaryVal', TType.STRING, -22)
      oprot.writeString(self.optBinaryVal)
      oprot.writeFieldEnd()
    if self.optStringVal != None:
      oprot.writeFieldBegin('optStringVal', TType.STRING, -21)
      oprot.writeString(self.optStringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.optStringVal, bytes) else oprot.writeString(self.optStringVal)
      oprot.writeFieldEnd()
    if self.optDoubleVal != None:
      oprot.writeFieldBegin('optDoubleVal', TType.DOUBLE, -20)
      oprot.writeDouble(self.optDoubleVal)
      oprot.writeFieldEnd()
    if self.optFloatVal != None:
      oprot.writeFieldBegin('optFloatVal', TType.FLOAT, -19)
      oprot.writeFloat(self.optFloatVal)
      oprot.writeFieldEnd()
    if self.optI64Val != None:
      oprot.writeFieldBegin('optI64Val', TType.I64, -18)
      oprot.writeI64(self.optI64Val)
      oprot.writeFieldEnd()
    if self.optI32Val != None:
      oprot.writeFieldBegin('optI32Val', TType.I32, -17)
      oprot.writeI32(self.optI32Val)
      oprot.writeFieldEnd()
    if self.optI16Val != None:
      oprot.writeFieldBegin('optI16Val', TType.I16, -16)
      oprot.writeI16(self.optI16Val)
      oprot.writeFieldEnd()
    if self.optByteVal != None:
      oprot.writeFieldBegin('optByteVal', TType.BYTE, -15)
      oprot.writeByte(self.optByteVal)
      oprot.writeFieldEnd()
    if self.optBoolVal != None:
      oprot.writeFieldBegin('optBoolVal', TType.BOOL, -14)
      oprot.writeBool(self.optBoolVal)
      oprot.writeFieldEnd()
    if self.lateStructVal != None:
      oprot.writeFieldBegin('lateStructVal', TType.STRUCT, -13)
      self.lateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.unionVal != None:
      oprot.writeFieldBegin('unionVal', TType.STRUCT, -12)
      self.unionVal.write(oprot)
      oprot.writeFieldEnd()
    if self.structVal != None:
      oprot.writeFieldBegin('structVal', TType.STRUCT, -11)
      self.structVal.write(oprot)
      oprot.writeFieldEnd()
    if self.enumVal != None:
      oprot.writeFieldBegin('enumVal', TType.I32, -10)
      oprot.writeI32(self.enumVal)
      oprot.writeFieldEnd()
    if self.binaryVal != None:
      oprot.writeFieldBegin('binaryVal', TType.STRING, -9)
      oprot.writeString(self.binaryVal)
      oprot.writeFieldEnd()
    if self.stringVal != None:
      oprot.writeFieldBegin('stringVal', TType.STRING, -8)
      oprot.writeString(self.stringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.stringVal, bytes) else oprot.writeString(self.stringVal)
      oprot.writeFieldEnd()
    if self.doubleVal != None:
      oprot.writeFieldBegin('doubleVal', TType.DOUBLE, -7)
      oprot.writeDouble(self.doubleVal)
      oprot.writeFieldEnd()
    if self.floatVal != None:
      oprot.writeFieldBegin('floatVal', TType.FLOAT, -6)
      oprot.writeFloat(self.floatVal)
      oprot.writeFieldEnd()
    if self.i64Val != None:
      oprot.writeFieldBegin('i64Val', TType.I64, -5)
      oprot.writeI64(self.i64Val)
      oprot.writeFieldEnd()
    if self.i32Val != None:
      oprot.writeFieldBegin('i32Val', TType.I32, -4)
      oprot.writeI32(self.i32Val)
      oprot.writeFieldEnd()
    if self.i16Val != None:
      oprot.writeFieldBegin('i16Val', TType.I16, -3)
      oprot.writeI16(self.i16Val)
      oprot.writeFieldEnd()
    if self.byteVal != None:
      oprot.writeFieldBegin('byteVal', TType.BYTE, -2)
      oprot.writeByte(self.byteVal)
      oprot.writeFieldEnd()
    if self.boolVal != None:
      oprot.writeFieldBegin('boolVal', TType.BOOL, -1)
      oprot.writeBool(self.boolVal)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'boolVal' in json_obj and json_obj['boolVal'] is not None:
      self.boolVal = json_obj['boolVal']
    if 'byteVal' in json_obj and json_obj['byteVal'] is not None:
      self.byteVal = json_obj['byteVal']
      if self.byteVal > 0x7f or self.byteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i16Val' in json_obj and json_obj['i16Val'] is not None:
      self.i16Val = json_obj['i16Val']
      if self.i16Val > 0x7fff or self.i16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i32Val' in json_obj and json_obj['i32Val'] is not None:
      self.i32Val = json_obj['i32Val']
      if self.i32Val > 0x7fffffff or self.i32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i64Val' in json_obj and json_obj['i64Val'] is not None:
      self.i64Val = long(json_obj['i64Val'])
    if 'floatVal' in json_obj and json_obj['floatVal'] is not None:
      self.floatVal = float(json_obj['floatVal'])
    if 'doubleVal' in json_obj and json_obj['doubleVal'] is not None:
      self.doubleVal = float(json_obj['doubleVal'])
    if 'stringVal' in json_obj and json_obj['stringVal'] is not None:
      self.stringVal = json_obj['stringVal']
    if 'binaryVal' in json_obj and json_obj['binaryVal'] is not None:
      self.binaryVal = json_obj['binaryVal']
    if 'enumVal' in json_obj and json_obj['enumVal'] is not None:
      self.enumVal = json_obj['enumVal']
      if not self.enumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'structVal' in json_obj and json_obj['structVal'] is not None:
      self.structVal = MyData()
      self.structVal.readFromJson(json_obj['structVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'unionVal' in json_obj and json_obj['unionVal'] is not None:
      self.unionVal = MyUnion()
      self.unionVal.readFromJson(json_obj['unionVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'lateStructVal' in json_obj and json_obj['lateStructVal'] is not None:
      self.lateStructVal = LateDefStruct()
      self.lateStructVal.readFromJson(json_obj['lateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optBoolVal' in json_obj and json_obj['optBoolVal'] is not None:
      self.optBoolVal = json_obj['optBoolVal']
    if 'optByteVal' in json_obj and json_obj['optByteVal'] is not None:
      self.optByteVal = json_obj['optByteVal']
      if self.optByteVal > 0x7f or self.optByteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI16Val' in json_obj and json_obj['optI16Val'] is not None:
      self.optI16Val = json_obj['optI16Val']
      if self.optI16Val > 0x7fff or self.optI16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI32Val' in json_obj and json_obj['optI32Val'] is not None:
      self.optI32Val = json_obj['optI32Val']
      if self.optI32Val > 0x7fffffff or self.optI32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI64Val' in json_obj and json_obj['optI64Val'] is not None:
      self.optI64Val = long(json_obj['optI64Val'])
    if 'optFloatVal' in json_obj and json_obj['optFloatVal'] is not None:
      self.optFloatVal = float(json_obj['optFloatVal'])
    if 'optDoubleVal' in json_obj and json_obj['optDoubleVal'] is not None:
      self.optDoubleVal = float(json_obj['optDoubleVal'])
    if 'optStringVal' in json_obj and json_obj['optStringVal'] is not None:
      self.optStringVal = json_obj['optStringVal']
    if 'optBinaryVal' in json_obj and json_obj['optBinaryVal'] is not None:
      self.optBinaryVal = json_obj['optBinaryVal']
    if 'optEnumVal' in json_obj and json_obj['optEnumVal'] is not None:
      self.optEnumVal = json_obj['optEnumVal']
      if not self.optEnumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.optEnumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'optStructVal' in json_obj and json_obj['optStructVal'] is not None:
      self.optStructVal = MyData()
      self.optStructVal.readFromJson(json_obj['optStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optLateStructVal' in json_obj and json_obj['optLateStructVal'] is not None:
      self.optLateStructVal = LateDefStruct()
      self.optLateStructVal.readFromJson(json_obj['optLateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optListVal' in json_obj and json_obj['optListVal'] is not None:
      self.optListVal = []
      for _tmp_e86 in json_obj['optListVal']:
        if _tmp_e86 > 0x7fff or _tmp_e86 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.optListVal.append(_tmp_e86)
    if 'optSetVal' in json_obj and json_obj['optSetVal'] is not None:
      self.optSetVal = set_cls()
      for _tmp_e87 in json_obj['optSetVal']:
        self.optSetVal.add(_tmp_e87)
    if 'optMapVal' in json_obj and json_obj['optMapVal'] is not None:
      self.optMapVal = dict_cls()
      for _tmp_k88, _tmp_v89 in json_obj['optMapVal'].items():
        _tmp_kp90 = _tmp_k88
        self.optMapVal[_tmp_kp90] = _tmp_v89
    if 'listMap' in json_obj and json_obj['listMap'] is not None:
      self.listMap = []
      for _tmp_e91 in json_obj['listMap']:
        _map92 = dict_cls()
        for _tmp_k93, _tmp_v94 in _tmp_e91.items():
          _tmp_kp95 = _tmp_k93
          if _tmp_v94 > 0x7fffffff or _tmp_v94 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map92[_tmp_kp95] = _tmp_v94
        self.listMap.append(_map92)
    if 'mapMap' in json_obj and json_obj['mapMap'] is not None:
      self.mapMap = dict_cls()
      for _tmp_k96, _tmp_v97 in json_obj['mapMap'].items():
        _tmp_kp98 = _tmp_k96
        _map99 = dict_cls()
        for _tmp_k100, _tmp_v101 in _tmp_v97.items():
          _tmp_kp102 = _tmp_k100
          if _tmp_v101 > 0x7fffffff or _tmp_v101 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map99[_tmp_kp102] = _tmp_v101
        self.mapMap[_tmp_kp98] = _map99

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.boolVal is not None:
      value = pprint.pformat(self.boolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    boolVal=%s' % (value))
    if self.byteVal is not None:
      value = pprint.pformat(self.byteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byteVal=%s' % (value))
    if self.i16Val is not None:
      value = pprint.pformat(self.i16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i16Val=%s' % (value))
    if self.i32Val is not None:
      value = pprint.pformat(self.i32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32Val=%s' % (value))
    if self.i64Val is not None:
      value = pprint.pformat(self.i64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i64Val=%s' % (value))
    if self.floatVal is not None:
      value = pprint.pformat(self.floatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    floatVal=%s' % (value))
    if self.doubleVal is not None:
      value = pprint.pformat(self.doubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleVal=%s' % (value))
    if self.stringVal is not None:
      value = pprint.pformat(self.stringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stringVal=%s' % (value))
    if self.binaryVal is not None:
      value = pprint.pformat(self.binaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryVal=%s' % (value))
    if self.enumVal is not None:
      value = pprint.pformat(self.enumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enumVal=%s' % (value))
    if self.structVal is not None:
      value = pprint.pformat(self.structVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structVal=%s' % (value))
    if self.unionVal is not None:
      value = pprint.pformat(self.unionVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionVal=%s' % (value))
    if self.lateStructVal is not None:
      value = pprint.pformat(self.lateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lateStructVal=%s' % (value))
    if self.optBoolVal is not None:
      value = pprint.pformat(self.optBoolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBoolVal=%s' % (value))
    if self.optByteVal is not None:
      value = pprint.pformat(self.optByteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optByteVal=%s' % (value))
    if self.optI16Val is not None:
      value = pprint.pformat(self.optI16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI16Val=%s' % (value))
    if self.optI32Val is not None:
      value = pprint.pformat(self.optI32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI32Val=%s' % (value))
    if self.optI64Val is not None:
      value = pprint.pformat(self.optI64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI64Val=%s' % (value))
    if self.optFloatVal is not None:
      value = pprint.pformat(self.optFloatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optFloatVal=%s' % (value))
    if self.optDoubleVal is not None:
      value = pprint.pformat(self.optDoubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optDoubleVal=%s' % (value))
    if self.optStringVal is not None:
      value = pprint.pformat(self.optStringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStringVal=%s' % (value))
    if self.optBinaryVal is not None:
      value = pprint.pformat(self.optBinaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBinaryVal=%s' % (value))
    if self.optEnumVal is not None:
      value = pprint.pformat(self.optEnumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optEnumVal=%s' % (value))
    if self.optStructVal is not None:
      value = pprint.pformat(self.optStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStructVal=%s' % (value))
    if self.optLateStructVal is not None:
      value = pprint.pformat(self.optLateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optLateStructVal=%s' % (value))
    if self.optListVal is not None:
      value = pprint.pformat(self.optListVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optListVal=%s' % (value))
    if self.optSetVal is not None:
      value = pprint.pformat(self.optSetVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optSetVal=%s' % (value))
    if self.optMapVal is not None:
      value = pprint.pformat(self.optMapVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optMapVal=%s' % (value))
    if self.listMap is not None:
      value = pprint.pformat(self.listMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    listMap=%s' % (value))
    if self.mapMap is not None:
      value = pprint.pformat(self.mapMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapMap=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'mapMap',
      'listMap',
      'optMapVal',
      'optSetVal',
      'optListVal',
      'optLateStructVal',
      'optStructVal',
      'optEnumVal',
      'optBinaryVal',
      'optStringVal',
      'optDoubleVal',
      'optFloatVal',
      'optI64Val',
      'optI32Val',
      'optI16Val',
      'optByteVal',
      'optBoolVal',
      'lateStructVal',
      'unionVal',
      'structVal',
      'enumVal',
      'binaryVal',
      'stringVal',
      'doubleVal',
      'floatVal',
      'i64Val',
      'i32Val',
      'i16Val',
      'byteVal',
      'boolVal',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

class LateDefStruct:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LateDefStruct')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LateDefStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LateDefStruct, self)

  def _to_py_deprecated(self):
    return self

class Recursive:
  r"""
  Attributes:
   - nodes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.MAP:
          self.nodes = {}
          (_ktype104, _vtype105, _size103 ) = iprot.readMapBegin() 
          if _size103 >= 0:
            for _i107 in range(_size103):
              _key108 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val109 = Recursive()
              _val109.read(iprot)
              self.nodes[_key108] = _val109
          else: 
            while iprot.peekMap():
              _key110 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val111 = Recursive()
              _val111.read(iprot)
              self.nodes[_key110] = _val111
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Recursive')
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.MAP, -1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.nodes))
      for kiter112,viter113 in self.nodes.items():
        oprot.writeString(kiter112.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter112, bytes) else oprot.writeString(kiter112)
        viter113.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'nodes' in json_obj and json_obj['nodes'] is not None:
      self.nodes = dict_cls()
      for _tmp_k114, _tmp_v115 in json_obj['nodes'].items():
        _tmp_kp116 = _tmp_k114
        _struct117 = Recursive()
        _struct117.readFromJson(_tmp_v115, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.nodes[_tmp_kp116] = _struct117

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.nodes is not None:
      value = pprint.pformat(self.nodes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nodes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'nodes',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Recursive, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Recursive, self)

  def _to_py_deprecated(self):
    return self

class Bar:
  r"""
  Attributes:
   - loop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.loop = Loop()
          self.loop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Bar')
    if self.loop != None:
      oprot.writeFieldBegin('loop', TType.STRUCT, -1)
      self.loop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'loop' in json_obj and json_obj['loop'] is not None:
      self.loop = Loop()
      self.loop.readFromJson(json_obj['loop'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.loop is not None:
      value = pprint.pformat(self.loop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    loop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'loop',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Bar, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Bar, self)

  def _to_py_deprecated(self):
    return self

class Loop:
  r"""
  Attributes:
   - bar
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.bar = Bar()
          self.bar.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Loop')
    if self.bar != None:
      oprot.writeFieldBegin('bar', TType.STRUCT, -1)
      self.bar.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'bar' in json_obj and json_obj['bar'] is not None:
      self.bar = Bar()
      self.bar.readFromJson(json_obj['bar'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.bar is not None:
      value = pprint.pformat(self.bar, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bar=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'bar',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Loop, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Loop, self)

  def _to_py_deprecated(self):
    return self

class MyDataEnsureStruct:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.data2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataEnsureStruct')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRING, 1)
      oprot.writeString(self.data1.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data1, bytes) else oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.I32, 2)
      oprot.writeI32(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = json_obj['data1']
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = json_obj['data2']
      if self.data2 > 0x7fffffff or self.data2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class MyDataFieldPatch:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.data1 = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.data1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data2 = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.data2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataFieldPatch')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRUCT, 1)
      self.data1.write(oprot)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.STRUCT, 2)
      self.data2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.data1.readFromJson(json_obj['data1'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.data2.readFromJson(json_obj['data2'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyDataPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyData()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyDataFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = MyDataEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyDataFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyData()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyDataFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyDataEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyDataFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataPatch, self)

  def _to_py_deprecated(self):
    return self

class InnerUnionFieldPatch:
  r"""
  Attributes:
   - innerOption
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.innerOption = thrift.lib.thrift.patch.ttypes.BinaryPatch()
          self.innerOption.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InnerUnionFieldPatch')
    if self.innerOption != None:
      oprot.writeFieldBegin('innerOption', TType.STRUCT, 1)
      self.innerOption.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'innerOption' in json_obj and json_obj['innerOption'] is not None:
      self.innerOption = thrift.lib.thrift.patch.ttypes.BinaryPatch()
      self.innerOption.readFromJson(json_obj['innerOption'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.innerOption is not None:
      value = pprint.pformat(self.innerOption, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    innerOption=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'innerOption',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.InnerUnionFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.InnerUnionFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class InnerUnionPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = InnerUnion()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = InnerUnionFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ensure = InnerUnion()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = InnerUnionFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InnerUnionPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 4)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = InnerUnion()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = InnerUnionFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = InnerUnion()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = InnerUnionFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.InnerUnionPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.InnerUnionPatch, self)

  def _to_py_deprecated(self):
    return self

class MyUnionFieldPatch:
  r"""
  Attributes:
   - option1
   - option2
   - option3
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.option1 = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.option1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.option2 = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.option2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.option3 = InnerUnionPatch()
          self.option3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyUnionFieldPatch')
    if self.option1 != None:
      oprot.writeFieldBegin('option1', TType.STRUCT, 1)
      self.option1.write(oprot)
      oprot.writeFieldEnd()
    if self.option2 != None:
      oprot.writeFieldBegin('option2', TType.STRUCT, 2)
      self.option2.write(oprot)
      oprot.writeFieldEnd()
    if self.option3 != None:
      oprot.writeFieldBegin('option3', TType.STRUCT, 3)
      self.option3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'option1' in json_obj and json_obj['option1'] is not None:
      self.option1 = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.option1.readFromJson(json_obj['option1'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'option2' in json_obj and json_obj['option2'] is not None:
      self.option2 = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.option2.readFromJson(json_obj['option2'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'option3' in json_obj and json_obj['option3'] is not None:
      self.option3 = InnerUnionPatch()
      self.option3.readFromJson(json_obj['option3'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.option1 is not None:
      value = pprint.pformat(self.option1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    option1=%s' % (value))
    if self.option2 is not None:
      value = pprint.pformat(self.option2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    option2=%s' % (value))
    if self.option3 is not None:
      value = pprint.pformat(self.option3, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    option3=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'option1',
      'option2',
      'option3',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnionFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnionFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyUnionPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyUnion()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyUnionFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ensure = MyUnion()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyUnionFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyUnionPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 4)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyUnion()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyUnionFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyUnion()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyUnionFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnionPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnionPatch, self)

  def _to_py_deprecated(self):
    return self

class MyStructEnsureStruct:
  r"""
  Attributes:
   - mapMap
   - listMap
   - optMapVal
   - optSetVal
   - optListVal
   - optLateStructVal
   - optStructVal
   - optEnumVal
   - optBinaryVal
   - optStringVal
   - optDoubleVal
   - optFloatVal
   - optI64Val
   - optI32Val
   - optI16Val
   - optByteVal
   - optBoolVal
   - lateStructVal
   - unionVal
   - structVal
   - enumVal
   - binaryVal
   - stringVal
   - doubleVal
   - floatVal
   - i64Val
   - i32Val
   - i16Val
   - byteVal
   - boolVal
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -30:
        if ftype == TType.MAP:
          self.mapMap = {}
          (_ktype119, _vtype120, _size118 ) = iprot.readMapBegin() 
          if _size118 >= 0:
            for _i122 in range(_size118):
              _key123 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val124 = {}
              (_ktype126, _vtype127, _size125 ) = iprot.readMapBegin() 
              if _size125 >= 0:
                for _i129 in range(_size125):
                  _key130 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val131 = iprot.readI32()
                  _val124[_key130] = _val131
              else: 
                while iprot.peekMap():
                  _key132 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val133 = iprot.readI32()
                  _val124[_key132] = _val133
              iprot.readMapEnd()
              self.mapMap[_key123] = _val124
          else: 
            while iprot.peekMap():
              _key134 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val135 = {}
              (_ktype137, _vtype138, _size136 ) = iprot.readMapBegin() 
              if _size136 >= 0:
                for _i140 in range(_size136):
                  _key141 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val142 = iprot.readI32()
                  _val135[_key141] = _val142
              else: 
                while iprot.peekMap():
                  _key143 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val144 = iprot.readI32()
                  _val135[_key143] = _val144
              iprot.readMapEnd()
              self.mapMap[_key134] = _val135
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -29:
        if ftype == TType.LIST:
          self.listMap = []
          (_etype148, _size145) = iprot.readListBegin()
          if _size145 >= 0:
            for _i149 in range(_size145):
              _elem150 = {}
              (_ktype152, _vtype153, _size151 ) = iprot.readMapBegin() 
              if _size151 >= 0:
                for _i155 in range(_size151):
                  _key156 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val157 = iprot.readI32()
                  _elem150[_key156] = _val157
              else: 
                while iprot.peekMap():
                  _key158 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val159 = iprot.readI32()
                  _elem150[_key158] = _val159
              iprot.readMapEnd()
              self.listMap.append(_elem150)
          else: 
            while iprot.peekList():
              _elem160 = {}
              (_ktype162, _vtype163, _size161 ) = iprot.readMapBegin() 
              if _size161 >= 0:
                for _i165 in range(_size161):
                  _key166 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val167 = iprot.readI32()
                  _elem160[_key166] = _val167
              else: 
                while iprot.peekMap():
                  _key168 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val169 = iprot.readI32()
                  _elem160[_key168] = _val169
              iprot.readMapEnd()
              self.listMap.append(_elem160)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -28:
        if ftype == TType.MAP:
          self.optMapVal = {}
          (_ktype171, _vtype172, _size170 ) = iprot.readMapBegin() 
          if _size170 >= 0:
            for _i174 in range(_size170):
              _key175 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val176 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key175] = _val176
          else: 
            while iprot.peekMap():
              _key177 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val178 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key177] = _val178
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -27:
        if ftype == TType.SET:
          self.optSetVal = set()
          (_etype182, _size179) = iprot.readSetBegin()
          if _size179 >= 0:
            for _i183 in range(_size179):
              _elem184 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem184)
          else: 
            while iprot.peekSet():
              _elem185 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem185)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == -26:
        if ftype == TType.LIST:
          self.optListVal = []
          (_etype189, _size186) = iprot.readListBegin()
          if _size186 >= 0:
            for _i190 in range(_size186):
              _elem191 = iprot.readI16()
              self.optListVal.append(_elem191)
          else: 
            while iprot.peekList():
              _elem192 = iprot.readI16()
              self.optListVal.append(_elem192)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -25:
        if ftype == TType.STRUCT:
          self.optLateStructVal = LateDefStruct()
          self.optLateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -24:
        if ftype == TType.STRUCT:
          self.optStructVal = MyData()
          self.optStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -23:
        if ftype == TType.I32:
          self.optEnumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -22:
        if ftype == TType.STRING:
          self.optBinaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -21:
        if ftype == TType.STRING:
          self.optStringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -20:
        if ftype == TType.DOUBLE:
          self.optDoubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -19:
        if ftype == TType.FLOAT:
          self.optFloatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -18:
        if ftype == TType.I64:
          self.optI64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -17:
        if ftype == TType.I32:
          self.optI32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -16:
        if ftype == TType.I16:
          self.optI16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -15:
        if ftype == TType.BYTE:
          self.optByteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -14:
        if ftype == TType.BOOL:
          self.optBoolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == -13:
        if ftype == TType.STRUCT:
          self.lateStructVal = LateDefStruct()
          self.lateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -12:
        if ftype == TType.STRUCT:
          self.unionVal = MyUnion()
          self.unionVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -11:
        if ftype == TType.STRUCT:
          self.structVal = MyData()
          self.structVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -10:
        if ftype == TType.I32:
          self.enumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -9:
        if ftype == TType.STRING:
          self.binaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -8:
        if ftype == TType.STRING:
          self.stringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -7:
        if ftype == TType.DOUBLE:
          self.doubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -6:
        if ftype == TType.FLOAT:
          self.floatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.I64:
          self.i64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.I32:
          self.i32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.I16:
          self.i16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.BYTE:
          self.byteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.BOOL:
          self.boolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructEnsureStruct')
    if self.mapMap != None:
      oprot.writeFieldBegin('mapMap', TType.MAP, -30)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.mapMap))
      for kiter193,viter194 in self.mapMap.items():
        oprot.writeString(kiter193.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter193, bytes) else oprot.writeString(kiter193)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter194))
        for kiter195,viter196 in viter194.items():
          oprot.writeString(kiter195.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter195, bytes) else oprot.writeString(kiter195)
          oprot.writeI32(viter196)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.listMap != None:
      oprot.writeFieldBegin('listMap', TType.LIST, -29)
      oprot.writeListBegin(TType.MAP, len(self.listMap))
      for iter197 in self.listMap:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter197))
        for kiter198,viter199 in iter197.items():
          oprot.writeString(kiter198.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter198, bytes) else oprot.writeString(kiter198)
          oprot.writeI32(viter199)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optMapVal != None:
      oprot.writeFieldBegin('optMapVal', TType.MAP, -28)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.optMapVal))
      for kiter200,viter201 in self.optMapVal.items():
        oprot.writeString(kiter200.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter200, bytes) else oprot.writeString(kiter200)
        oprot.writeString(viter201.encode('utf-8')) if UTF8STRINGS and not isinstance(viter201, bytes) else oprot.writeString(viter201)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.optSetVal != None:
      oprot.writeFieldBegin('optSetVal', TType.SET, -27)
      oprot.writeSetBegin(TType.STRING, len(self.optSetVal))
      for iter202 in self.optSetVal:
        oprot.writeString(iter202.encode('utf-8')) if UTF8STRINGS and not isinstance(iter202, bytes) else oprot.writeString(iter202)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.optListVal != None:
      oprot.writeFieldBegin('optListVal', TType.LIST, -26)
      oprot.writeListBegin(TType.I16, len(self.optListVal))
      for iter203 in self.optListVal:
        oprot.writeI16(iter203)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optLateStructVal != None:
      oprot.writeFieldBegin('optLateStructVal', TType.STRUCT, -25)
      self.optLateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStructVal != None:
      oprot.writeFieldBegin('optStructVal', TType.STRUCT, -24)
      self.optStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optEnumVal != None:
      oprot.writeFieldBegin('optEnumVal', TType.I32, -23)
      oprot.writeI32(self.optEnumVal)
      oprot.writeFieldEnd()
    if self.optBinaryVal != None:
      oprot.writeFieldBegin('optBinaryVal', TType.STRING, -22)
      oprot.writeString(self.optBinaryVal)
      oprot.writeFieldEnd()
    if self.optStringVal != None:
      oprot.writeFieldBegin('optStringVal', TType.STRING, -21)
      oprot.writeString(self.optStringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.optStringVal, bytes) else oprot.writeString(self.optStringVal)
      oprot.writeFieldEnd()
    if self.optDoubleVal != None:
      oprot.writeFieldBegin('optDoubleVal', TType.DOUBLE, -20)
      oprot.writeDouble(self.optDoubleVal)
      oprot.writeFieldEnd()
    if self.optFloatVal != None:
      oprot.writeFieldBegin('optFloatVal', TType.FLOAT, -19)
      oprot.writeFloat(self.optFloatVal)
      oprot.writeFieldEnd()
    if self.optI64Val != None:
      oprot.writeFieldBegin('optI64Val', TType.I64, -18)
      oprot.writeI64(self.optI64Val)
      oprot.writeFieldEnd()
    if self.optI32Val != None:
      oprot.writeFieldBegin('optI32Val', TType.I32, -17)
      oprot.writeI32(self.optI32Val)
      oprot.writeFieldEnd()
    if self.optI16Val != None:
      oprot.writeFieldBegin('optI16Val', TType.I16, -16)
      oprot.writeI16(self.optI16Val)
      oprot.writeFieldEnd()
    if self.optByteVal != None:
      oprot.writeFieldBegin('optByteVal', TType.BYTE, -15)
      oprot.writeByte(self.optByteVal)
      oprot.writeFieldEnd()
    if self.optBoolVal != None:
      oprot.writeFieldBegin('optBoolVal', TType.BOOL, -14)
      oprot.writeBool(self.optBoolVal)
      oprot.writeFieldEnd()
    if self.lateStructVal != None:
      oprot.writeFieldBegin('lateStructVal', TType.STRUCT, -13)
      self.lateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.unionVal != None:
      oprot.writeFieldBegin('unionVal', TType.STRUCT, -12)
      self.unionVal.write(oprot)
      oprot.writeFieldEnd()
    if self.structVal != None:
      oprot.writeFieldBegin('structVal', TType.STRUCT, -11)
      self.structVal.write(oprot)
      oprot.writeFieldEnd()
    if self.enumVal != None:
      oprot.writeFieldBegin('enumVal', TType.I32, -10)
      oprot.writeI32(self.enumVal)
      oprot.writeFieldEnd()
    if self.binaryVal != None:
      oprot.writeFieldBegin('binaryVal', TType.STRING, -9)
      oprot.writeString(self.binaryVal)
      oprot.writeFieldEnd()
    if self.stringVal != None:
      oprot.writeFieldBegin('stringVal', TType.STRING, -8)
      oprot.writeString(self.stringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.stringVal, bytes) else oprot.writeString(self.stringVal)
      oprot.writeFieldEnd()
    if self.doubleVal != None:
      oprot.writeFieldBegin('doubleVal', TType.DOUBLE, -7)
      oprot.writeDouble(self.doubleVal)
      oprot.writeFieldEnd()
    if self.floatVal != None:
      oprot.writeFieldBegin('floatVal', TType.FLOAT, -6)
      oprot.writeFloat(self.floatVal)
      oprot.writeFieldEnd()
    if self.i64Val != None:
      oprot.writeFieldBegin('i64Val', TType.I64, -5)
      oprot.writeI64(self.i64Val)
      oprot.writeFieldEnd()
    if self.i32Val != None:
      oprot.writeFieldBegin('i32Val', TType.I32, -4)
      oprot.writeI32(self.i32Val)
      oprot.writeFieldEnd()
    if self.i16Val != None:
      oprot.writeFieldBegin('i16Val', TType.I16, -3)
      oprot.writeI16(self.i16Val)
      oprot.writeFieldEnd()
    if self.byteVal != None:
      oprot.writeFieldBegin('byteVal', TType.BYTE, -2)
      oprot.writeByte(self.byteVal)
      oprot.writeFieldEnd()
    if self.boolVal != None:
      oprot.writeFieldBegin('boolVal', TType.BOOL, -1)
      oprot.writeBool(self.boolVal)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'mapMap' in json_obj and json_obj['mapMap'] is not None:
      self.mapMap = dict_cls()
      for _tmp_k204, _tmp_v205 in json_obj['mapMap'].items():
        _tmp_kp206 = _tmp_k204
        _map207 = dict_cls()
        for _tmp_k208, _tmp_v209 in _tmp_v205.items():
          _tmp_kp210 = _tmp_k208
          if _tmp_v209 > 0x7fffffff or _tmp_v209 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map207[_tmp_kp210] = _tmp_v209
        self.mapMap[_tmp_kp206] = _map207
    if 'listMap' in json_obj and json_obj['listMap'] is not None:
      self.listMap = []
      for _tmp_e211 in json_obj['listMap']:
        _map212 = dict_cls()
        for _tmp_k213, _tmp_v214 in _tmp_e211.items():
          _tmp_kp215 = _tmp_k213
          if _tmp_v214 > 0x7fffffff or _tmp_v214 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map212[_tmp_kp215] = _tmp_v214
        self.listMap.append(_map212)
    if 'optMapVal' in json_obj and json_obj['optMapVal'] is not None:
      self.optMapVal = dict_cls()
      for _tmp_k216, _tmp_v217 in json_obj['optMapVal'].items():
        _tmp_kp218 = _tmp_k216
        self.optMapVal[_tmp_kp218] = _tmp_v217
    if 'optSetVal' in json_obj and json_obj['optSetVal'] is not None:
      self.optSetVal = set_cls()
      for _tmp_e219 in json_obj['optSetVal']:
        self.optSetVal.add(_tmp_e219)
    if 'optListVal' in json_obj and json_obj['optListVal'] is not None:
      self.optListVal = []
      for _tmp_e220 in json_obj['optListVal']:
        if _tmp_e220 > 0x7fff or _tmp_e220 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.optListVal.append(_tmp_e220)
    if 'optLateStructVal' in json_obj and json_obj['optLateStructVal'] is not None:
      self.optLateStructVal = LateDefStruct()
      self.optLateStructVal.readFromJson(json_obj['optLateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optStructVal' in json_obj and json_obj['optStructVal'] is not None:
      self.optStructVal = MyData()
      self.optStructVal.readFromJson(json_obj['optStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optEnumVal' in json_obj and json_obj['optEnumVal'] is not None:
      self.optEnumVal = json_obj['optEnumVal']
      if not self.optEnumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.optEnumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'optBinaryVal' in json_obj and json_obj['optBinaryVal'] is not None:
      self.optBinaryVal = json_obj['optBinaryVal']
    if 'optStringVal' in json_obj and json_obj['optStringVal'] is not None:
      self.optStringVal = json_obj['optStringVal']
    if 'optDoubleVal' in json_obj and json_obj['optDoubleVal'] is not None:
      self.optDoubleVal = float(json_obj['optDoubleVal'])
    if 'optFloatVal' in json_obj and json_obj['optFloatVal'] is not None:
      self.optFloatVal = float(json_obj['optFloatVal'])
    if 'optI64Val' in json_obj and json_obj['optI64Val'] is not None:
      self.optI64Val = long(json_obj['optI64Val'])
    if 'optI32Val' in json_obj and json_obj['optI32Val'] is not None:
      self.optI32Val = json_obj['optI32Val']
      if self.optI32Val > 0x7fffffff or self.optI32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI16Val' in json_obj and json_obj['optI16Val'] is not None:
      self.optI16Val = json_obj['optI16Val']
      if self.optI16Val > 0x7fff or self.optI16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optByteVal' in json_obj and json_obj['optByteVal'] is not None:
      self.optByteVal = json_obj['optByteVal']
      if self.optByteVal > 0x7f or self.optByteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optBoolVal' in json_obj and json_obj['optBoolVal'] is not None:
      self.optBoolVal = json_obj['optBoolVal']
    if 'lateStructVal' in json_obj and json_obj['lateStructVal'] is not None:
      self.lateStructVal = LateDefStruct()
      self.lateStructVal.readFromJson(json_obj['lateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'unionVal' in json_obj and json_obj['unionVal'] is not None:
      self.unionVal = MyUnion()
      self.unionVal.readFromJson(json_obj['unionVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structVal' in json_obj and json_obj['structVal'] is not None:
      self.structVal = MyData()
      self.structVal.readFromJson(json_obj['structVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'enumVal' in json_obj and json_obj['enumVal'] is not None:
      self.enumVal = json_obj['enumVal']
      if not self.enumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'binaryVal' in json_obj and json_obj['binaryVal'] is not None:
      self.binaryVal = json_obj['binaryVal']
    if 'stringVal' in json_obj and json_obj['stringVal'] is not None:
      self.stringVal = json_obj['stringVal']
    if 'doubleVal' in json_obj and json_obj['doubleVal'] is not None:
      self.doubleVal = float(json_obj['doubleVal'])
    if 'floatVal' in json_obj and json_obj['floatVal'] is not None:
      self.floatVal = float(json_obj['floatVal'])
    if 'i64Val' in json_obj and json_obj['i64Val'] is not None:
      self.i64Val = long(json_obj['i64Val'])
    if 'i32Val' in json_obj and json_obj['i32Val'] is not None:
      self.i32Val = json_obj['i32Val']
      if self.i32Val > 0x7fffffff or self.i32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i16Val' in json_obj and json_obj['i16Val'] is not None:
      self.i16Val = json_obj['i16Val']
      if self.i16Val > 0x7fff or self.i16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'byteVal' in json_obj and json_obj['byteVal'] is not None:
      self.byteVal = json_obj['byteVal']
      if self.byteVal > 0x7f or self.byteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'boolVal' in json_obj and json_obj['boolVal'] is not None:
      self.boolVal = json_obj['boolVal']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.mapMap is not None:
      value = pprint.pformat(self.mapMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapMap=%s' % (value))
    if self.listMap is not None:
      value = pprint.pformat(self.listMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    listMap=%s' % (value))
    if self.optMapVal is not None:
      value = pprint.pformat(self.optMapVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optMapVal=%s' % (value))
    if self.optSetVal is not None:
      value = pprint.pformat(self.optSetVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optSetVal=%s' % (value))
    if self.optListVal is not None:
      value = pprint.pformat(self.optListVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optListVal=%s' % (value))
    if self.optLateStructVal is not None:
      value = pprint.pformat(self.optLateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optLateStructVal=%s' % (value))
    if self.optStructVal is not None:
      value = pprint.pformat(self.optStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStructVal=%s' % (value))
    if self.optEnumVal is not None:
      value = pprint.pformat(self.optEnumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optEnumVal=%s' % (value))
    if self.optBinaryVal is not None:
      value = pprint.pformat(self.optBinaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBinaryVal=%s' % (value))
    if self.optStringVal is not None:
      value = pprint.pformat(self.optStringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStringVal=%s' % (value))
    if self.optDoubleVal is not None:
      value = pprint.pformat(self.optDoubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optDoubleVal=%s' % (value))
    if self.optFloatVal is not None:
      value = pprint.pformat(self.optFloatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optFloatVal=%s' % (value))
    if self.optI64Val is not None:
      value = pprint.pformat(self.optI64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI64Val=%s' % (value))
    if self.optI32Val is not None:
      value = pprint.pformat(self.optI32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI32Val=%s' % (value))
    if self.optI16Val is not None:
      value = pprint.pformat(self.optI16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI16Val=%s' % (value))
    if self.optByteVal is not None:
      value = pprint.pformat(self.optByteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optByteVal=%s' % (value))
    if self.optBoolVal is not None:
      value = pprint.pformat(self.optBoolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBoolVal=%s' % (value))
    if self.lateStructVal is not None:
      value = pprint.pformat(self.lateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lateStructVal=%s' % (value))
    if self.unionVal is not None:
      value = pprint.pformat(self.unionVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionVal=%s' % (value))
    if self.structVal is not None:
      value = pprint.pformat(self.structVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structVal=%s' % (value))
    if self.enumVal is not None:
      value = pprint.pformat(self.enumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enumVal=%s' % (value))
    if self.binaryVal is not None:
      value = pprint.pformat(self.binaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryVal=%s' % (value))
    if self.stringVal is not None:
      value = pprint.pformat(self.stringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stringVal=%s' % (value))
    if self.doubleVal is not None:
      value = pprint.pformat(self.doubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleVal=%s' % (value))
    if self.floatVal is not None:
      value = pprint.pformat(self.floatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    floatVal=%s' % (value))
    if self.i64Val is not None:
      value = pprint.pformat(self.i64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i64Val=%s' % (value))
    if self.i32Val is not None:
      value = pprint.pformat(self.i32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32Val=%s' % (value))
    if self.i16Val is not None:
      value = pprint.pformat(self.i16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i16Val=%s' % (value))
    if self.byteVal is not None:
      value = pprint.pformat(self.byteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byteVal=%s' % (value))
    if self.boolVal is not None:
      value = pprint.pformat(self.boolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    boolVal=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'mapMap',
      'listMap',
      'optMapVal',
      'optSetVal',
      'optListVal',
      'optLateStructVal',
      'optStructVal',
      'optEnumVal',
      'optBinaryVal',
      'optStringVal',
      'optDoubleVal',
      'optFloatVal',
      'optI64Val',
      'optI32Val',
      'optI16Val',
      'optByteVal',
      'optBoolVal',
      'lateStructVal',
      'unionVal',
      'structVal',
      'enumVal',
      'binaryVal',
      'stringVal',
      'doubleVal',
      'floatVal',
      'i64Val',
      'i32Val',
      'i16Val',
      'byteVal',
      'boolVal',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class MyStructField10Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.assign = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField10Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I32, 1)
      oprot.writeI32(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if not self.assign in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.assign
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField10Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField10Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField23Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.assign = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField23Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I32, 1)
      oprot.writeI32(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if not self.assign in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.assign
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField23Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField23Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField26Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patch: Patches list values by index. Applies second.
   - remove: Removes entries, if present. Applies third.
   - prepend: Prepends to the front of a given list.
   - append: Appends to the back of a given list.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.assign = []
          (_etype224, _size221) = iprot.readListBegin()
          if _size221 >= 0:
            for _i225 in range(_size221):
              _elem226 = iprot.readI16()
              self.assign.append(_elem226)
          else: 
            while iprot.peekList():
              _elem227 = iprot.readI16()
              self.assign.append(_elem227)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype229, _vtype230, _size228 ) = iprot.readMapBegin() 
          if _size228 >= 0:
            for _i232 in range(_size228):
              _key233 = iprot.readI32()
              _val234 = thrift.lib.thrift.patch.ttypes.I16Patch()
              _val234.read(iprot)
              self.patch[_key233] = _val234
          else: 
            while iprot.peekMap():
              _key235 = iprot.readI32()
              _val236 = thrift.lib.thrift.patch.ttypes.I16Patch()
              _val236.read(iprot)
              self.patch[_key235] = _val236
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.remove = []
          (_etype240, _size237) = iprot.readListBegin()
          if _size237 >= 0:
            for _i241 in range(_size237):
              _elem242 = iprot.readI16()
              self.remove.append(_elem242)
          else: 
            while iprot.peekList():
              _elem243 = iprot.readI16()
              self.remove.append(_elem243)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.prepend = []
          (_etype247, _size244) = iprot.readListBegin()
          if _size244 >= 0:
            for _i248 in range(_size244):
              _elem249 = iprot.readI16()
              self.prepend.append(_elem249)
          else: 
            while iprot.peekList():
              _elem250 = iprot.readI16()
              self.prepend.append(_elem250)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.append = []
          (_etype254, _size251) = iprot.readListBegin()
          if _size251 >= 0:
            for _i255 in range(_size251):
              _elem256 = iprot.readI16()
              self.append.append(_elem256)
          else: 
            while iprot.peekList():
              _elem257 = iprot.readI16()
              self.append.append(_elem257)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField26Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.LIST, 1)
      oprot.writeListBegin(TType.I16, len(self.assign))
      for iter258 in self.assign:
        oprot.writeI16(iter258)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.patch))
      for kiter259,viter260 in self.patch.items():
        oprot.writeI32(kiter259)
        viter260.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.LIST, 7)
      oprot.writeListBegin(TType.I16, len(self.remove))
      for iter261 in self.remove:
        oprot.writeI16(iter261)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.prepend != None:
      oprot.writeFieldBegin('prepend', TType.LIST, 8)
      oprot.writeListBegin(TType.I16, len(self.prepend))
      for iter262 in self.prepend:
        oprot.writeI16(iter262)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.append != None:
      oprot.writeFieldBegin('append', TType.LIST, 9)
      oprot.writeListBegin(TType.I16, len(self.append))
      for iter263 in self.append:
        oprot.writeI16(iter263)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = []
      for _tmp_e264 in json_obj['assign']:
        if _tmp_e264 > 0x7fff or _tmp_e264 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.assign.append(_tmp_e264)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k265, _tmp_v266 in json_obj['patch'].items():
        _tmp_kp267 = int(_tmp_k265)
        if _tmp_kp267 > 0x7fffffff or _tmp_kp267 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k265)
        _struct268 = thrift.lib.thrift.patch.ttypes.I16Patch()
        _struct268.readFromJson(_tmp_v266, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp267] = _struct268
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = []
      for _tmp_e269 in json_obj['remove']:
        if _tmp_e269 > 0x7fff or _tmp_e269 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.remove.append(_tmp_e269)
    if 'prepend' in json_obj and json_obj['prepend'] is not None:
      self.prepend = []
      for _tmp_e270 in json_obj['prepend']:
        if _tmp_e270 > 0x7fff or _tmp_e270 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.prepend.append(_tmp_e270)
    if 'append' in json_obj and json_obj['append'] is not None:
      self.append = []
      for _tmp_e271 in json_obj['append']:
        if _tmp_e271 > 0x7fff or _tmp_e271 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.append.append(_tmp_e271)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.prepend is not None:
      value = pprint.pformat(self.prepend, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prepend=%s' % (value))
    if self.append is not None:
      value = pprint.pformat(self.append, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    append=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patch',
      'remove',
      'prepend',
      'append',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField26Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField26Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField27Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - remove: Removes entries, if present. Applies third.
   - add: Adds entries, if not already present. Applies fourth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.assign = set()
          (_etype275, _size272) = iprot.readSetBegin()
          if _size272 >= 0:
            for _i276 in range(_size272):
              _elem277 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign.add(_elem277)
          else: 
            while iprot.peekSet():
              _elem278 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign.add(_elem278)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype282, _size279) = iprot.readSetBegin()
          if _size279 >= 0:
            for _i283 in range(_size279):
              _elem284 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem284)
          else: 
            while iprot.peekSet():
              _elem285 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem285)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.SET:
          self.add = set()
          (_etype289, _size286) = iprot.readSetBegin()
          if _size286 >= 0:
            for _i290 in range(_size286):
              _elem291 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add.add(_elem291)
          else: 
            while iprot.peekSet():
              _elem292 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add.add(_elem292)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField27Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.assign))
      for iter293 in self.assign:
        oprot.writeString(iter293.encode('utf-8')) if UTF8STRINGS and not isinstance(iter293, bytes) else oprot.writeString(iter293)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter294 in self.remove:
        oprot.writeString(iter294.encode('utf-8')) if UTF8STRINGS and not isinstance(iter294, bytes) else oprot.writeString(iter294)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.SET, 8)
      oprot.writeSetBegin(TType.STRING, len(self.add))
      for iter295 in self.add:
        oprot.writeString(iter295.encode('utf-8')) if UTF8STRINGS and not isinstance(iter295, bytes) else oprot.writeString(iter295)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = set_cls()
      for _tmp_e296 in json_obj['assign']:
        self.assign.add(_tmp_e296)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e297 in json_obj['remove']:
        self.remove.add(_tmp_e297)
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = set_cls()
      for _tmp_e298 in json_obj['add']:
        self.add.add(_tmp_e298)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'remove',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField27Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField27Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField28Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - add: Add the given values, if the keys are not already present. Applies forth.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
   - put: Adds or replaces the given key/value pairs. Applies fifth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype300, _vtype301, _size299 ) = iprot.readMapBegin() 
          if _size299 >= 0:
            for _i303 in range(_size299):
              _key304 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val305 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign[_key304] = _val305
          else: 
            while iprot.peekMap():
              _key306 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val307 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign[_key306] = _val307
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patchPrior = {}
          (_ktype309, _vtype310, _size308 ) = iprot.readMapBegin() 
          if _size308 >= 0:
            for _i312 in range(_size308):
              _key313 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val314 = thrift.lib.thrift.patch.ttypes.StringPatch()
              _val314.read(iprot)
              self.patchPrior[_key313] = _val314
          else: 
            while iprot.peekMap():
              _key315 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val316 = thrift.lib.thrift.patch.ttypes.StringPatch()
              _val316.read(iprot)
              self.patchPrior[_key315] = _val316
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.add = {}
          (_ktype318, _vtype319, _size317 ) = iprot.readMapBegin() 
          if _size317 >= 0:
            for _i321 in range(_size317):
              _key322 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val323 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add[_key322] = _val323
          else: 
            while iprot.peekMap():
              _key324 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val325 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add[_key324] = _val325
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype327, _vtype328, _size326 ) = iprot.readMapBegin() 
          if _size326 >= 0:
            for _i330 in range(_size326):
              _key331 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val332 = thrift.lib.thrift.patch.ttypes.StringPatch()
              _val332.read(iprot)
              self.patch[_key331] = _val332
          else: 
            while iprot.peekMap():
              _key333 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val334 = thrift.lib.thrift.patch.ttypes.StringPatch()
              _val334.read(iprot)
              self.patch[_key333] = _val334
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype338, _size335) = iprot.readSetBegin()
          if _size335 >= 0:
            for _i339 in range(_size335):
              _elem340 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem340)
          else: 
            while iprot.peekSet():
              _elem341 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem341)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.put = {}
          (_ktype343, _vtype344, _size342 ) = iprot.readMapBegin() 
          if _size342 >= 0:
            for _i346 in range(_size342):
              _key347 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val348 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.put[_key347] = _val348
          else: 
            while iprot.peekMap():
              _key349 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val350 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.put[_key349] = _val350
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField28Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.assign))
      for kiter351,viter352 in self.assign.items():
        oprot.writeString(kiter351.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter351, bytes) else oprot.writeString(kiter351)
        oprot.writeString(viter352.encode('utf-8')) if UTF8STRINGS and not isinstance(viter352, bytes) else oprot.writeString(viter352)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patchPrior))
      for kiter353,viter354 in self.patchPrior.items():
        oprot.writeString(kiter353.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter353, bytes) else oprot.writeString(kiter353)
        viter354.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.add))
      for kiter355,viter356 in self.add.items():
        oprot.writeString(kiter355.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter355, bytes) else oprot.writeString(kiter355)
        oprot.writeString(viter356.encode('utf-8')) if UTF8STRINGS and not isinstance(viter356, bytes) else oprot.writeString(viter356)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patch))
      for kiter357,viter358 in self.patch.items():
        oprot.writeString(kiter357.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter357, bytes) else oprot.writeString(kiter357)
        viter358.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter359 in self.remove:
        oprot.writeString(iter359.encode('utf-8')) if UTF8STRINGS and not isinstance(iter359, bytes) else oprot.writeString(iter359)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.put != None:
      oprot.writeFieldBegin('put', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.put))
      for kiter360,viter361 in self.put.items():
        oprot.writeString(kiter360.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter360, bytes) else oprot.writeString(kiter360)
        oprot.writeString(viter361.encode('utf-8')) if UTF8STRINGS and not isinstance(viter361, bytes) else oprot.writeString(viter361)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k362, _tmp_v363 in json_obj['assign'].items():
        _tmp_kp364 = _tmp_k362
        self.assign[_tmp_kp364] = _tmp_v363
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = dict_cls()
      for _tmp_k365, _tmp_v366 in json_obj['patchPrior'].items():
        _tmp_kp367 = _tmp_k365
        _struct368 = thrift.lib.thrift.patch.ttypes.StringPatch()
        _struct368.readFromJson(_tmp_v366, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patchPrior[_tmp_kp367] = _struct368
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = dict_cls()
      for _tmp_k369, _tmp_v370 in json_obj['add'].items():
        _tmp_kp371 = _tmp_k369
        self.add[_tmp_kp371] = _tmp_v370
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k372, _tmp_v373 in json_obj['patch'].items():
        _tmp_kp374 = _tmp_k372
        _struct375 = thrift.lib.thrift.patch.ttypes.StringPatch()
        _struct375.readFromJson(_tmp_v373, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp374] = _struct375
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e376 in json_obj['remove']:
        self.remove.add(_tmp_e376)
    if 'put' in json_obj and json_obj['put'] is not None:
      self.put = dict_cls()
      for _tmp_k377, _tmp_v378 in json_obj['put'].items():
        _tmp_kp379 = _tmp_k377
        self.put[_tmp_kp379] = _tmp_v378

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.put is not None:
      value = pprint.pformat(self.put, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    put=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'add',
      'patch',
      'remove',
      'put',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField28Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField28Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField29Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patch: Patches list values by index. Applies second.
   - remove: Removes entries, if present. Applies third.
   - prepend: Prepends to the front of a given list.
   - append: Appends to the back of a given list.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.assign = []
          (_etype383, _size380) = iprot.readListBegin()
          if _size380 >= 0:
            for _i384 in range(_size380):
              _elem385 = {}
              (_ktype387, _vtype388, _size386 ) = iprot.readMapBegin() 
              if _size386 >= 0:
                for _i390 in range(_size386):
                  _key391 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val392 = iprot.readI32()
                  _elem385[_key391] = _val392
              else: 
                while iprot.peekMap():
                  _key393 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val394 = iprot.readI32()
                  _elem385[_key393] = _val394
              iprot.readMapEnd()
              self.assign.append(_elem385)
          else: 
            while iprot.peekList():
              _elem395 = {}
              (_ktype397, _vtype398, _size396 ) = iprot.readMapBegin() 
              if _size396 >= 0:
                for _i400 in range(_size396):
                  _key401 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val402 = iprot.readI32()
                  _elem395[_key401] = _val402
              else: 
                while iprot.peekMap():
                  _key403 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val404 = iprot.readI32()
                  _elem395[_key403] = _val404
              iprot.readMapEnd()
              self.assign.append(_elem395)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype406, _vtype407, _size405 ) = iprot.readMapBegin() 
          if _size405 >= 0:
            for _i409 in range(_size405):
              _key410 = iprot.readI32()
              _val411 = MyStructField29Patch1()
              _val411.read(iprot)
              self.patch[_key410] = _val411
          else: 
            while iprot.peekMap():
              _key412 = iprot.readI32()
              _val413 = MyStructField29Patch1()
              _val413.read(iprot)
              self.patch[_key412] = _val413
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.remove = []
          (_etype417, _size414) = iprot.readListBegin()
          if _size414 >= 0:
            for _i418 in range(_size414):
              _elem419 = {}
              (_ktype421, _vtype422, _size420 ) = iprot.readMapBegin() 
              if _size420 >= 0:
                for _i424 in range(_size420):
                  _key425 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val426 = iprot.readI32()
                  _elem419[_key425] = _val426
              else: 
                while iprot.peekMap():
                  _key427 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val428 = iprot.readI32()
                  _elem419[_key427] = _val428
              iprot.readMapEnd()
              self.remove.append(_elem419)
          else: 
            while iprot.peekList():
              _elem429 = {}
              (_ktype431, _vtype432, _size430 ) = iprot.readMapBegin() 
              if _size430 >= 0:
                for _i434 in range(_size430):
                  _key435 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val436 = iprot.readI32()
                  _elem429[_key435] = _val436
              else: 
                while iprot.peekMap():
                  _key437 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val438 = iprot.readI32()
                  _elem429[_key437] = _val438
              iprot.readMapEnd()
              self.remove.append(_elem429)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.prepend = []
          (_etype442, _size439) = iprot.readListBegin()
          if _size439 >= 0:
            for _i443 in range(_size439):
              _elem444 = {}
              (_ktype446, _vtype447, _size445 ) = iprot.readMapBegin() 
              if _size445 >= 0:
                for _i449 in range(_size445):
                  _key450 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val451 = iprot.readI32()
                  _elem444[_key450] = _val451
              else: 
                while iprot.peekMap():
                  _key452 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val453 = iprot.readI32()
                  _elem444[_key452] = _val453
              iprot.readMapEnd()
              self.prepend.append(_elem444)
          else: 
            while iprot.peekList():
              _elem454 = {}
              (_ktype456, _vtype457, _size455 ) = iprot.readMapBegin() 
              if _size455 >= 0:
                for _i459 in range(_size455):
                  _key460 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val461 = iprot.readI32()
                  _elem454[_key460] = _val461
              else: 
                while iprot.peekMap():
                  _key462 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val463 = iprot.readI32()
                  _elem454[_key462] = _val463
              iprot.readMapEnd()
              self.prepend.append(_elem454)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.append = []
          (_etype467, _size464) = iprot.readListBegin()
          if _size464 >= 0:
            for _i468 in range(_size464):
              _elem469 = {}
              (_ktype471, _vtype472, _size470 ) = iprot.readMapBegin() 
              if _size470 >= 0:
                for _i474 in range(_size470):
                  _key475 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val476 = iprot.readI32()
                  _elem469[_key475] = _val476
              else: 
                while iprot.peekMap():
                  _key477 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val478 = iprot.readI32()
                  _elem469[_key477] = _val478
              iprot.readMapEnd()
              self.append.append(_elem469)
          else: 
            while iprot.peekList():
              _elem479 = {}
              (_ktype481, _vtype482, _size480 ) = iprot.readMapBegin() 
              if _size480 >= 0:
                for _i484 in range(_size480):
                  _key485 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val486 = iprot.readI32()
                  _elem479[_key485] = _val486
              else: 
                while iprot.peekMap():
                  _key487 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val488 = iprot.readI32()
                  _elem479[_key487] = _val488
              iprot.readMapEnd()
              self.append.append(_elem479)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField29Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.LIST, 1)
      oprot.writeListBegin(TType.MAP, len(self.assign))
      for iter489 in self.assign:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter489))
        for kiter490,viter491 in iter489.items():
          oprot.writeString(kiter490.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter490, bytes) else oprot.writeString(kiter490)
          oprot.writeI32(viter491)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.patch))
      for kiter492,viter493 in self.patch.items():
        oprot.writeI32(kiter492)
        viter493.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.LIST, 7)
      oprot.writeListBegin(TType.MAP, len(self.remove))
      for iter494 in self.remove:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter494))
        for kiter495,viter496 in iter494.items():
          oprot.writeString(kiter495.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter495, bytes) else oprot.writeString(kiter495)
          oprot.writeI32(viter496)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.prepend != None:
      oprot.writeFieldBegin('prepend', TType.LIST, 8)
      oprot.writeListBegin(TType.MAP, len(self.prepend))
      for iter497 in self.prepend:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter497))
        for kiter498,viter499 in iter497.items():
          oprot.writeString(kiter498.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter498, bytes) else oprot.writeString(kiter498)
          oprot.writeI32(viter499)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.append != None:
      oprot.writeFieldBegin('append', TType.LIST, 9)
      oprot.writeListBegin(TType.MAP, len(self.append))
      for iter500 in self.append:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter500))
        for kiter501,viter502 in iter500.items():
          oprot.writeString(kiter501.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter501, bytes) else oprot.writeString(kiter501)
          oprot.writeI32(viter502)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = []
      for _tmp_e503 in json_obj['assign']:
        _map504 = dict_cls()
        for _tmp_k505, _tmp_v506 in _tmp_e503.items():
          _tmp_kp507 = _tmp_k505
          if _tmp_v506 > 0x7fffffff or _tmp_v506 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map504[_tmp_kp507] = _tmp_v506
        self.assign.append(_map504)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k508, _tmp_v509 in json_obj['patch'].items():
        _tmp_kp510 = int(_tmp_k508)
        if _tmp_kp510 > 0x7fffffff or _tmp_kp510 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k508)
        _struct511 = MyStructField29Patch1()
        _struct511.readFromJson(_tmp_v509, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp510] = _struct511
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = []
      for _tmp_e512 in json_obj['remove']:
        _map513 = dict_cls()
        for _tmp_k514, _tmp_v515 in _tmp_e512.items():
          _tmp_kp516 = _tmp_k514
          if _tmp_v515 > 0x7fffffff or _tmp_v515 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map513[_tmp_kp516] = _tmp_v515
        self.remove.append(_map513)
    if 'prepend' in json_obj and json_obj['prepend'] is not None:
      self.prepend = []
      for _tmp_e517 in json_obj['prepend']:
        _map518 = dict_cls()
        for _tmp_k519, _tmp_v520 in _tmp_e517.items():
          _tmp_kp521 = _tmp_k519
          if _tmp_v520 > 0x7fffffff or _tmp_v520 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map518[_tmp_kp521] = _tmp_v520
        self.prepend.append(_map518)
    if 'append' in json_obj and json_obj['append'] is not None:
      self.append = []
      for _tmp_e522 in json_obj['append']:
        _map523 = dict_cls()
        for _tmp_k524, _tmp_v525 in _tmp_e522.items():
          _tmp_kp526 = _tmp_k524
          if _tmp_v525 > 0x7fffffff or _tmp_v525 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map523[_tmp_kp526] = _tmp_v525
        self.append.append(_map523)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.prepend is not None:
      value = pprint.pformat(self.prepend, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prepend=%s' % (value))
    if self.append is not None:
      value = pprint.pformat(self.append, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    append=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patch',
      'remove',
      'prepend',
      'append',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField29Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField29Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField29Patch1:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - add: Add the given values, if the keys are not already present. Applies forth.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
   - put: Adds or replaces the given key/value pairs. Applies fifth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype528, _vtype529, _size527 ) = iprot.readMapBegin() 
          if _size527 >= 0:
            for _i531 in range(_size527):
              _key532 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val533 = iprot.readI32()
              self.assign[_key532] = _val533
          else: 
            while iprot.peekMap():
              _key534 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val535 = iprot.readI32()
              self.assign[_key534] = _val535
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patchPrior = {}
          (_ktype537, _vtype538, _size536 ) = iprot.readMapBegin() 
          if _size536 >= 0:
            for _i540 in range(_size536):
              _key541 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val542 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val542.read(iprot)
              self.patchPrior[_key541] = _val542
          else: 
            while iprot.peekMap():
              _key543 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val544 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val544.read(iprot)
              self.patchPrior[_key543] = _val544
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.add = {}
          (_ktype546, _vtype547, _size545 ) = iprot.readMapBegin() 
          if _size545 >= 0:
            for _i549 in range(_size545):
              _key550 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val551 = iprot.readI32()
              self.add[_key550] = _val551
          else: 
            while iprot.peekMap():
              _key552 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val553 = iprot.readI32()
              self.add[_key552] = _val553
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype555, _vtype556, _size554 ) = iprot.readMapBegin() 
          if _size554 >= 0:
            for _i558 in range(_size554):
              _key559 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val560 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val560.read(iprot)
              self.patch[_key559] = _val560
          else: 
            while iprot.peekMap():
              _key561 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val562 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val562.read(iprot)
              self.patch[_key561] = _val562
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype566, _size563) = iprot.readSetBegin()
          if _size563 >= 0:
            for _i567 in range(_size563):
              _elem568 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem568)
          else: 
            while iprot.peekSet():
              _elem569 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem569)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.put = {}
          (_ktype571, _vtype572, _size570 ) = iprot.readMapBegin() 
          if _size570 >= 0:
            for _i574 in range(_size570):
              _key575 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val576 = iprot.readI32()
              self.put[_key575] = _val576
          else: 
            while iprot.peekMap():
              _key577 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val578 = iprot.readI32()
              self.put[_key577] = _val578
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField29Patch1')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.assign))
      for kiter579,viter580 in self.assign.items():
        oprot.writeString(kiter579.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter579, bytes) else oprot.writeString(kiter579)
        oprot.writeI32(viter580)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patchPrior))
      for kiter581,viter582 in self.patchPrior.items():
        oprot.writeString(kiter581.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter581, bytes) else oprot.writeString(kiter581)
        viter582.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.add))
      for kiter583,viter584 in self.add.items():
        oprot.writeString(kiter583.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter583, bytes) else oprot.writeString(kiter583)
        oprot.writeI32(viter584)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patch))
      for kiter585,viter586 in self.patch.items():
        oprot.writeString(kiter585.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter585, bytes) else oprot.writeString(kiter585)
        viter586.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter587 in self.remove:
        oprot.writeString(iter587.encode('utf-8')) if UTF8STRINGS and not isinstance(iter587, bytes) else oprot.writeString(iter587)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.put != None:
      oprot.writeFieldBegin('put', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.put))
      for kiter588,viter589 in self.put.items():
        oprot.writeString(kiter588.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter588, bytes) else oprot.writeString(kiter588)
        oprot.writeI32(viter589)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k590, _tmp_v591 in json_obj['assign'].items():
        _tmp_kp592 = _tmp_k590
        if _tmp_v591 > 0x7fffffff or _tmp_v591 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.assign[_tmp_kp592] = _tmp_v591
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = dict_cls()
      for _tmp_k593, _tmp_v594 in json_obj['patchPrior'].items():
        _tmp_kp595 = _tmp_k593
        _struct596 = thrift.lib.thrift.patch.ttypes.I32Patch()
        _struct596.readFromJson(_tmp_v594, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patchPrior[_tmp_kp595] = _struct596
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = dict_cls()
      for _tmp_k597, _tmp_v598 in json_obj['add'].items():
        _tmp_kp599 = _tmp_k597
        if _tmp_v598 > 0x7fffffff or _tmp_v598 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.add[_tmp_kp599] = _tmp_v598
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k600, _tmp_v601 in json_obj['patch'].items():
        _tmp_kp602 = _tmp_k600
        _struct603 = thrift.lib.thrift.patch.ttypes.I32Patch()
        _struct603.readFromJson(_tmp_v601, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp602] = _struct603
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e604 in json_obj['remove']:
        self.remove.add(_tmp_e604)
    if 'put' in json_obj and json_obj['put'] is not None:
      self.put = dict_cls()
      for _tmp_k605, _tmp_v606 in json_obj['put'].items():
        _tmp_kp607 = _tmp_k605
        if _tmp_v606 > 0x7fffffff or _tmp_v606 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.put[_tmp_kp607] = _tmp_v606

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.put is not None:
      value = pprint.pformat(self.put, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    put=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'add',
      'patch',
      'remove',
      'put',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField29Patch1, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField29Patch1, self)

  def _to_py_deprecated(self):
    return self

class MyStructField30Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - add: Add the given values, if the keys are not already present. Applies forth.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
   - put: Adds or replaces the given key/value pairs. Applies fifth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype609, _vtype610, _size608 ) = iprot.readMapBegin() 
          if _size608 >= 0:
            for _i612 in range(_size608):
              _key613 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val614 = {}
              (_ktype616, _vtype617, _size615 ) = iprot.readMapBegin() 
              if _size615 >= 0:
                for _i619 in range(_size615):
                  _key620 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val621 = iprot.readI32()
                  _val614[_key620] = _val621
              else: 
                while iprot.peekMap():
                  _key622 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val623 = iprot.readI32()
                  _val614[_key622] = _val623
              iprot.readMapEnd()
              self.assign[_key613] = _val614
          else: 
            while iprot.peekMap():
              _key624 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val625 = {}
              (_ktype627, _vtype628, _size626 ) = iprot.readMapBegin() 
              if _size626 >= 0:
                for _i630 in range(_size626):
                  _key631 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val632 = iprot.readI32()
                  _val625[_key631] = _val632
              else: 
                while iprot.peekMap():
                  _key633 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val634 = iprot.readI32()
                  _val625[_key633] = _val634
              iprot.readMapEnd()
              self.assign[_key624] = _val625
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patchPrior = {}
          (_ktype636, _vtype637, _size635 ) = iprot.readMapBegin() 
          if _size635 >= 0:
            for _i639 in range(_size635):
              _key640 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val641 = MyStructField30Patch1()
              _val641.read(iprot)
              self.patchPrior[_key640] = _val641
          else: 
            while iprot.peekMap():
              _key642 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val643 = MyStructField30Patch1()
              _val643.read(iprot)
              self.patchPrior[_key642] = _val643
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.add = {}
          (_ktype645, _vtype646, _size644 ) = iprot.readMapBegin() 
          if _size644 >= 0:
            for _i648 in range(_size644):
              _key649 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val650 = {}
              (_ktype652, _vtype653, _size651 ) = iprot.readMapBegin() 
              if _size651 >= 0:
                for _i655 in range(_size651):
                  _key656 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val657 = iprot.readI32()
                  _val650[_key656] = _val657
              else: 
                while iprot.peekMap():
                  _key658 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val659 = iprot.readI32()
                  _val650[_key658] = _val659
              iprot.readMapEnd()
              self.add[_key649] = _val650
          else: 
            while iprot.peekMap():
              _key660 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val661 = {}
              (_ktype663, _vtype664, _size662 ) = iprot.readMapBegin() 
              if _size662 >= 0:
                for _i666 in range(_size662):
                  _key667 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val668 = iprot.readI32()
                  _val661[_key667] = _val668
              else: 
                while iprot.peekMap():
                  _key669 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val670 = iprot.readI32()
                  _val661[_key669] = _val670
              iprot.readMapEnd()
              self.add[_key660] = _val661
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype672, _vtype673, _size671 ) = iprot.readMapBegin() 
          if _size671 >= 0:
            for _i675 in range(_size671):
              _key676 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val677 = MyStructField30Patch1()
              _val677.read(iprot)
              self.patch[_key676] = _val677
          else: 
            while iprot.peekMap():
              _key678 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val679 = MyStructField30Patch1()
              _val679.read(iprot)
              self.patch[_key678] = _val679
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype683, _size680) = iprot.readSetBegin()
          if _size680 >= 0:
            for _i684 in range(_size680):
              _elem685 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem685)
          else: 
            while iprot.peekSet():
              _elem686 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem686)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.put = {}
          (_ktype688, _vtype689, _size687 ) = iprot.readMapBegin() 
          if _size687 >= 0:
            for _i691 in range(_size687):
              _key692 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val693 = {}
              (_ktype695, _vtype696, _size694 ) = iprot.readMapBegin() 
              if _size694 >= 0:
                for _i698 in range(_size694):
                  _key699 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val700 = iprot.readI32()
                  _val693[_key699] = _val700
              else: 
                while iprot.peekMap():
                  _key701 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val702 = iprot.readI32()
                  _val693[_key701] = _val702
              iprot.readMapEnd()
              self.put[_key692] = _val693
          else: 
            while iprot.peekMap():
              _key703 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val704 = {}
              (_ktype706, _vtype707, _size705 ) = iprot.readMapBegin() 
              if _size705 >= 0:
                for _i709 in range(_size705):
                  _key710 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val711 = iprot.readI32()
                  _val704[_key710] = _val711
              else: 
                while iprot.peekMap():
                  _key712 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val713 = iprot.readI32()
                  _val704[_key712] = _val713
              iprot.readMapEnd()
              self.put[_key703] = _val704
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField30Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.assign))
      for kiter714,viter715 in self.assign.items():
        oprot.writeString(kiter714.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter714, bytes) else oprot.writeString(kiter714)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter715))
        for kiter716,viter717 in viter715.items():
          oprot.writeString(kiter716.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter716, bytes) else oprot.writeString(kiter716)
          oprot.writeI32(viter717)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patchPrior))
      for kiter718,viter719 in self.patchPrior.items():
        oprot.writeString(kiter718.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter718, bytes) else oprot.writeString(kiter718)
        viter719.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.add))
      for kiter720,viter721 in self.add.items():
        oprot.writeString(kiter720.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter720, bytes) else oprot.writeString(kiter720)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter721))
        for kiter722,viter723 in viter721.items():
          oprot.writeString(kiter722.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter722, bytes) else oprot.writeString(kiter722)
          oprot.writeI32(viter723)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patch))
      for kiter724,viter725 in self.patch.items():
        oprot.writeString(kiter724.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter724, bytes) else oprot.writeString(kiter724)
        viter725.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter726 in self.remove:
        oprot.writeString(iter726.encode('utf-8')) if UTF8STRINGS and not isinstance(iter726, bytes) else oprot.writeString(iter726)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.put != None:
      oprot.writeFieldBegin('put', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.put))
      for kiter727,viter728 in self.put.items():
        oprot.writeString(kiter727.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter727, bytes) else oprot.writeString(kiter727)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter728))
        for kiter729,viter730 in viter728.items():
          oprot.writeString(kiter729.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter729, bytes) else oprot.writeString(kiter729)
          oprot.writeI32(viter730)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k731, _tmp_v732 in json_obj['assign'].items():
        _tmp_kp733 = _tmp_k731
        _map734 = dict_cls()
        for _tmp_k735, _tmp_v736 in _tmp_v732.items():
          _tmp_kp737 = _tmp_k735
          if _tmp_v736 > 0x7fffffff or _tmp_v736 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map734[_tmp_kp737] = _tmp_v736
        self.assign[_tmp_kp733] = _map734
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = dict_cls()
      for _tmp_k738, _tmp_v739 in json_obj['patchPrior'].items():
        _tmp_kp740 = _tmp_k738
        _struct741 = MyStructField30Patch1()
        _struct741.readFromJson(_tmp_v739, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patchPrior[_tmp_kp740] = _struct741
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = dict_cls()
      for _tmp_k742, _tmp_v743 in json_obj['add'].items():
        _tmp_kp744 = _tmp_k742
        _map745 = dict_cls()
        for _tmp_k746, _tmp_v747 in _tmp_v743.items():
          _tmp_kp748 = _tmp_k746
          if _tmp_v747 > 0x7fffffff or _tmp_v747 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map745[_tmp_kp748] = _tmp_v747
        self.add[_tmp_kp744] = _map745
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k749, _tmp_v750 in json_obj['patch'].items():
        _tmp_kp751 = _tmp_k749
        _struct752 = MyStructField30Patch1()
        _struct752.readFromJson(_tmp_v750, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp751] = _struct752
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e753 in json_obj['remove']:
        self.remove.add(_tmp_e753)
    if 'put' in json_obj and json_obj['put'] is not None:
      self.put = dict_cls()
      for _tmp_k754, _tmp_v755 in json_obj['put'].items():
        _tmp_kp756 = _tmp_k754
        _map757 = dict_cls()
        for _tmp_k758, _tmp_v759 in _tmp_v755.items():
          _tmp_kp760 = _tmp_k758
          if _tmp_v759 > 0x7fffffff or _tmp_v759 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map757[_tmp_kp760] = _tmp_v759
        self.put[_tmp_kp756] = _map757

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.put is not None:
      value = pprint.pformat(self.put, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    put=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'add',
      'patch',
      'remove',
      'put',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField30Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField30Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField30Patch1:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - add: Add the given values, if the keys are not already present. Applies forth.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
   - put: Adds or replaces the given key/value pairs. Applies fifth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype762, _vtype763, _size761 ) = iprot.readMapBegin() 
          if _size761 >= 0:
            for _i765 in range(_size761):
              _key766 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val767 = iprot.readI32()
              self.assign[_key766] = _val767
          else: 
            while iprot.peekMap():
              _key768 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val769 = iprot.readI32()
              self.assign[_key768] = _val769
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patchPrior = {}
          (_ktype771, _vtype772, _size770 ) = iprot.readMapBegin() 
          if _size770 >= 0:
            for _i774 in range(_size770):
              _key775 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val776 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val776.read(iprot)
              self.patchPrior[_key775] = _val776
          else: 
            while iprot.peekMap():
              _key777 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val778 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val778.read(iprot)
              self.patchPrior[_key777] = _val778
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.add = {}
          (_ktype780, _vtype781, _size779 ) = iprot.readMapBegin() 
          if _size779 >= 0:
            for _i783 in range(_size779):
              _key784 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val785 = iprot.readI32()
              self.add[_key784] = _val785
          else: 
            while iprot.peekMap():
              _key786 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val787 = iprot.readI32()
              self.add[_key786] = _val787
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype789, _vtype790, _size788 ) = iprot.readMapBegin() 
          if _size788 >= 0:
            for _i792 in range(_size788):
              _key793 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val794 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val794.read(iprot)
              self.patch[_key793] = _val794
          else: 
            while iprot.peekMap():
              _key795 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val796 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val796.read(iprot)
              self.patch[_key795] = _val796
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype800, _size797) = iprot.readSetBegin()
          if _size797 >= 0:
            for _i801 in range(_size797):
              _elem802 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem802)
          else: 
            while iprot.peekSet():
              _elem803 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem803)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.put = {}
          (_ktype805, _vtype806, _size804 ) = iprot.readMapBegin() 
          if _size804 >= 0:
            for _i808 in range(_size804):
              _key809 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val810 = iprot.readI32()
              self.put[_key809] = _val810
          else: 
            while iprot.peekMap():
              _key811 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val812 = iprot.readI32()
              self.put[_key811] = _val812
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField30Patch1')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.assign))
      for kiter813,viter814 in self.assign.items():
        oprot.writeString(kiter813.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter813, bytes) else oprot.writeString(kiter813)
        oprot.writeI32(viter814)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patchPrior))
      for kiter815,viter816 in self.patchPrior.items():
        oprot.writeString(kiter815.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter815, bytes) else oprot.writeString(kiter815)
        viter816.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.add))
      for kiter817,viter818 in self.add.items():
        oprot.writeString(kiter817.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter817, bytes) else oprot.writeString(kiter817)
        oprot.writeI32(viter818)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patch))
      for kiter819,viter820 in self.patch.items():
        oprot.writeString(kiter819.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter819, bytes) else oprot.writeString(kiter819)
        viter820.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter821 in self.remove:
        oprot.writeString(iter821.encode('utf-8')) if UTF8STRINGS and not isinstance(iter821, bytes) else oprot.writeString(iter821)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.put != None:
      oprot.writeFieldBegin('put', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.put))
      for kiter822,viter823 in self.put.items():
        oprot.writeString(kiter822.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter822, bytes) else oprot.writeString(kiter822)
        oprot.writeI32(viter823)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k824, _tmp_v825 in json_obj['assign'].items():
        _tmp_kp826 = _tmp_k824
        if _tmp_v825 > 0x7fffffff or _tmp_v825 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.assign[_tmp_kp826] = _tmp_v825
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = dict_cls()
      for _tmp_k827, _tmp_v828 in json_obj['patchPrior'].items():
        _tmp_kp829 = _tmp_k827
        _struct830 = thrift.lib.thrift.patch.ttypes.I32Patch()
        _struct830.readFromJson(_tmp_v828, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patchPrior[_tmp_kp829] = _struct830
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = dict_cls()
      for _tmp_k831, _tmp_v832 in json_obj['add'].items():
        _tmp_kp833 = _tmp_k831
        if _tmp_v832 > 0x7fffffff or _tmp_v832 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.add[_tmp_kp833] = _tmp_v832
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k834, _tmp_v835 in json_obj['patch'].items():
        _tmp_kp836 = _tmp_k834
        _struct837 = thrift.lib.thrift.patch.ttypes.I32Patch()
        _struct837.readFromJson(_tmp_v835, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp836] = _struct837
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e838 in json_obj['remove']:
        self.remove.add(_tmp_e838)
    if 'put' in json_obj and json_obj['put'] is not None:
      self.put = dict_cls()
      for _tmp_k839, _tmp_v840 in json_obj['put'].items():
        _tmp_kp841 = _tmp_k839
        if _tmp_v840 > 0x7fffffff or _tmp_v840 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.put[_tmp_kp841] = _tmp_v840

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.put is not None:
      value = pprint.pformat(self.put, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    put=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'add',
      'patch',
      'remove',
      'put',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField30Patch1, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField30Patch1, self)

  def _to_py_deprecated(self):
    return self

class MyStructFieldPatch:
  r"""
  Attributes:
   - mapMap
   - listMap
   - optMapVal
   - optSetVal
   - optListVal
   - optLateStructVal
   - optStructVal
   - optEnumVal
   - optBinaryVal
   - optStringVal
   - optDoubleVal
   - optFloatVal
   - optI64Val
   - optI32Val
   - optI16Val
   - optByteVal
   - optBoolVal
   - lateStructVal
   - unionVal
   - structVal
   - enumVal
   - binaryVal
   - stringVal
   - doubleVal
   - floatVal
   - i64Val
   - i32Val
   - i16Val
   - byteVal
   - boolVal
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -30:
        if ftype == TType.STRUCT:
          self.mapMap = MyStructField30Patch()
          self.mapMap.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -29:
        if ftype == TType.STRUCT:
          self.listMap = MyStructField29Patch()
          self.listMap.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -28:
        if ftype == TType.STRUCT:
          self.optMapVal = MyStructField28Patch()
          self.optMapVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -27:
        if ftype == TType.STRUCT:
          self.optSetVal = MyStructField27Patch()
          self.optSetVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -26:
        if ftype == TType.STRUCT:
          self.optListVal = MyStructField26Patch()
          self.optListVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -25:
        if ftype == TType.STRUCT:
          self.optLateStructVal = LateDefStructPatch()
          self.optLateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -24:
        if ftype == TType.STRUCT:
          self.optStructVal = MyDataPatch()
          self.optStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -23:
        if ftype == TType.STRUCT:
          self.optEnumVal = MyStructField23Patch()
          self.optEnumVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -22:
        if ftype == TType.STRUCT:
          self.optBinaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
          self.optBinaryVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -21:
        if ftype == TType.STRUCT:
          self.optStringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.optStringVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -20:
        if ftype == TType.STRUCT:
          self.optDoubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
          self.optDoubleVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -19:
        if ftype == TType.STRUCT:
          self.optFloatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
          self.optFloatVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -18:
        if ftype == TType.STRUCT:
          self.optI64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
          self.optI64Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -17:
        if ftype == TType.STRUCT:
          self.optI32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.optI32Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -16:
        if ftype == TType.STRUCT:
          self.optI16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
          self.optI16Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -15:
        if ftype == TType.STRUCT:
          self.optByteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
          self.optByteVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -14:
        if ftype == TType.STRUCT:
          self.optBoolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
          self.optBoolVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -13:
        if ftype == TType.STRUCT:
          self.lateStructVal = LateDefStructPatch()
          self.lateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -12:
        if ftype == TType.STRUCT:
          self.unionVal = MyUnionPatch()
          self.unionVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -11:
        if ftype == TType.STRUCT:
          self.structVal = MyDataPatch()
          self.structVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -10:
        if ftype == TType.STRUCT:
          self.enumVal = MyStructField10Patch()
          self.enumVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -9:
        if ftype == TType.STRUCT:
          self.binaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
          self.binaryVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -8:
        if ftype == TType.STRUCT:
          self.stringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.stringVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -7:
        if ftype == TType.STRUCT:
          self.doubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
          self.doubleVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -6:
        if ftype == TType.STRUCT:
          self.floatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
          self.floatVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.STRUCT:
          self.i64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
          self.i64Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.STRUCT:
          self.i32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.i32Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRUCT:
          self.i16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
          self.i16Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRUCT:
          self.byteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
          self.byteVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.boolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
          self.boolVal.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructFieldPatch')
    if self.mapMap != None:
      oprot.writeFieldBegin('mapMap', TType.STRUCT, -30)
      self.mapMap.write(oprot)
      oprot.writeFieldEnd()
    if self.listMap != None:
      oprot.writeFieldBegin('listMap', TType.STRUCT, -29)
      self.listMap.write(oprot)
      oprot.writeFieldEnd()
    if self.optMapVal != None:
      oprot.writeFieldBegin('optMapVal', TType.STRUCT, -28)
      self.optMapVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optSetVal != None:
      oprot.writeFieldBegin('optSetVal', TType.STRUCT, -27)
      self.optSetVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optListVal != None:
      oprot.writeFieldBegin('optListVal', TType.STRUCT, -26)
      self.optListVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optLateStructVal != None:
      oprot.writeFieldBegin('optLateStructVal', TType.STRUCT, -25)
      self.optLateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStructVal != None:
      oprot.writeFieldBegin('optStructVal', TType.STRUCT, -24)
      self.optStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optEnumVal != None:
      oprot.writeFieldBegin('optEnumVal', TType.STRUCT, -23)
      self.optEnumVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optBinaryVal != None:
      oprot.writeFieldBegin('optBinaryVal', TType.STRUCT, -22)
      self.optBinaryVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStringVal != None:
      oprot.writeFieldBegin('optStringVal', TType.STRUCT, -21)
      self.optStringVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optDoubleVal != None:
      oprot.writeFieldBegin('optDoubleVal', TType.STRUCT, -20)
      self.optDoubleVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optFloatVal != None:
      oprot.writeFieldBegin('optFloatVal', TType.STRUCT, -19)
      self.optFloatVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optI64Val != None:
      oprot.writeFieldBegin('optI64Val', TType.STRUCT, -18)
      self.optI64Val.write(oprot)
      oprot.writeFieldEnd()
    if self.optI32Val != None:
      oprot.writeFieldBegin('optI32Val', TType.STRUCT, -17)
      self.optI32Val.write(oprot)
      oprot.writeFieldEnd()
    if self.optI16Val != None:
      oprot.writeFieldBegin('optI16Val', TType.STRUCT, -16)
      self.optI16Val.write(oprot)
      oprot.writeFieldEnd()
    if self.optByteVal != None:
      oprot.writeFieldBegin('optByteVal', TType.STRUCT, -15)
      self.optByteVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optBoolVal != None:
      oprot.writeFieldBegin('optBoolVal', TType.STRUCT, -14)
      self.optBoolVal.write(oprot)
      oprot.writeFieldEnd()
    if self.lateStructVal != None:
      oprot.writeFieldBegin('lateStructVal', TType.STRUCT, -13)
      self.lateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.unionVal != None:
      oprot.writeFieldBegin('unionVal', TType.STRUCT, -12)
      self.unionVal.write(oprot)
      oprot.writeFieldEnd()
    if self.structVal != None:
      oprot.writeFieldBegin('structVal', TType.STRUCT, -11)
      self.structVal.write(oprot)
      oprot.writeFieldEnd()
    if self.enumVal != None:
      oprot.writeFieldBegin('enumVal', TType.STRUCT, -10)
      self.enumVal.write(oprot)
      oprot.writeFieldEnd()
    if self.binaryVal != None:
      oprot.writeFieldBegin('binaryVal', TType.STRUCT, -9)
      self.binaryVal.write(oprot)
      oprot.writeFieldEnd()
    if self.stringVal != None:
      oprot.writeFieldBegin('stringVal', TType.STRUCT, -8)
      self.stringVal.write(oprot)
      oprot.writeFieldEnd()
    if self.doubleVal != None:
      oprot.writeFieldBegin('doubleVal', TType.STRUCT, -7)
      self.doubleVal.write(oprot)
      oprot.writeFieldEnd()
    if self.floatVal != None:
      oprot.writeFieldBegin('floatVal', TType.STRUCT, -6)
      self.floatVal.write(oprot)
      oprot.writeFieldEnd()
    if self.i64Val != None:
      oprot.writeFieldBegin('i64Val', TType.STRUCT, -5)
      self.i64Val.write(oprot)
      oprot.writeFieldEnd()
    if self.i32Val != None:
      oprot.writeFieldBegin('i32Val', TType.STRUCT, -4)
      self.i32Val.write(oprot)
      oprot.writeFieldEnd()
    if self.i16Val != None:
      oprot.writeFieldBegin('i16Val', TType.STRUCT, -3)
      self.i16Val.write(oprot)
      oprot.writeFieldEnd()
    if self.byteVal != None:
      oprot.writeFieldBegin('byteVal', TType.STRUCT, -2)
      self.byteVal.write(oprot)
      oprot.writeFieldEnd()
    if self.boolVal != None:
      oprot.writeFieldBegin('boolVal', TType.STRUCT, -1)
      self.boolVal.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'mapMap' in json_obj and json_obj['mapMap'] is not None:
      self.mapMap = MyStructField30Patch()
      self.mapMap.readFromJson(json_obj['mapMap'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'listMap' in json_obj and json_obj['listMap'] is not None:
      self.listMap = MyStructField29Patch()
      self.listMap.readFromJson(json_obj['listMap'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optMapVal' in json_obj and json_obj['optMapVal'] is not None:
      self.optMapVal = MyStructField28Patch()
      self.optMapVal.readFromJson(json_obj['optMapVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optSetVal' in json_obj and json_obj['optSetVal'] is not None:
      self.optSetVal = MyStructField27Patch()
      self.optSetVal.readFromJson(json_obj['optSetVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optListVal' in json_obj and json_obj['optListVal'] is not None:
      self.optListVal = MyStructField26Patch()
      self.optListVal.readFromJson(json_obj['optListVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optLateStructVal' in json_obj and json_obj['optLateStructVal'] is not None:
      self.optLateStructVal = LateDefStructPatch()
      self.optLateStructVal.readFromJson(json_obj['optLateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optStructVal' in json_obj and json_obj['optStructVal'] is not None:
      self.optStructVal = MyDataPatch()
      self.optStructVal.readFromJson(json_obj['optStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optEnumVal' in json_obj and json_obj['optEnumVal'] is not None:
      self.optEnumVal = MyStructField23Patch()
      self.optEnumVal.readFromJson(json_obj['optEnumVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optBinaryVal' in json_obj and json_obj['optBinaryVal'] is not None:
      self.optBinaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
      self.optBinaryVal.readFromJson(json_obj['optBinaryVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optStringVal' in json_obj and json_obj['optStringVal'] is not None:
      self.optStringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.optStringVal.readFromJson(json_obj['optStringVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optDoubleVal' in json_obj and json_obj['optDoubleVal'] is not None:
      self.optDoubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
      self.optDoubleVal.readFromJson(json_obj['optDoubleVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optFloatVal' in json_obj and json_obj['optFloatVal'] is not None:
      self.optFloatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
      self.optFloatVal.readFromJson(json_obj['optFloatVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optI64Val' in json_obj and json_obj['optI64Val'] is not None:
      self.optI64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
      self.optI64Val.readFromJson(json_obj['optI64Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optI32Val' in json_obj and json_obj['optI32Val'] is not None:
      self.optI32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.optI32Val.readFromJson(json_obj['optI32Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optI16Val' in json_obj and json_obj['optI16Val'] is not None:
      self.optI16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
      self.optI16Val.readFromJson(json_obj['optI16Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optByteVal' in json_obj and json_obj['optByteVal'] is not None:
      self.optByteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
      self.optByteVal.readFromJson(json_obj['optByteVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optBoolVal' in json_obj and json_obj['optBoolVal'] is not None:
      self.optBoolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
      self.optBoolVal.readFromJson(json_obj['optBoolVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'lateStructVal' in json_obj and json_obj['lateStructVal'] is not None:
      self.lateStructVal = LateDefStructPatch()
      self.lateStructVal.readFromJson(json_obj['lateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'unionVal' in json_obj and json_obj['unionVal'] is not None:
      self.unionVal = MyUnionPatch()
      self.unionVal.readFromJson(json_obj['unionVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structVal' in json_obj and json_obj['structVal'] is not None:
      self.structVal = MyDataPatch()
      self.structVal.readFromJson(json_obj['structVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'enumVal' in json_obj and json_obj['enumVal'] is not None:
      self.enumVal = MyStructField10Patch()
      self.enumVal.readFromJson(json_obj['enumVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'binaryVal' in json_obj and json_obj['binaryVal'] is not None:
      self.binaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
      self.binaryVal.readFromJson(json_obj['binaryVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'stringVal' in json_obj and json_obj['stringVal'] is not None:
      self.stringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.stringVal.readFromJson(json_obj['stringVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'doubleVal' in json_obj and json_obj['doubleVal'] is not None:
      self.doubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
      self.doubleVal.readFromJson(json_obj['doubleVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'floatVal' in json_obj and json_obj['floatVal'] is not None:
      self.floatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
      self.floatVal.readFromJson(json_obj['floatVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i64Val' in json_obj and json_obj['i64Val'] is not None:
      self.i64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
      self.i64Val.readFromJson(json_obj['i64Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i32Val' in json_obj and json_obj['i32Val'] is not None:
      self.i32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.i32Val.readFromJson(json_obj['i32Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i16Val' in json_obj and json_obj['i16Val'] is not None:
      self.i16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
      self.i16Val.readFromJson(json_obj['i16Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'byteVal' in json_obj and json_obj['byteVal'] is not None:
      self.byteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
      self.byteVal.readFromJson(json_obj['byteVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'boolVal' in json_obj and json_obj['boolVal'] is not None:
      self.boolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
      self.boolVal.readFromJson(json_obj['boolVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.mapMap is not None:
      value = pprint.pformat(self.mapMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapMap=%s' % (value))
    if self.listMap is not None:
      value = pprint.pformat(self.listMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    listMap=%s' % (value))
    if self.optMapVal is not None:
      value = pprint.pformat(self.optMapVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optMapVal=%s' % (value))
    if self.optSetVal is not None:
      value = pprint.pformat(self.optSetVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optSetVal=%s' % (value))
    if self.optListVal is not None:
      value = pprint.pformat(self.optListVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optListVal=%s' % (value))
    if self.optLateStructVal is not None:
      value = pprint.pformat(self.optLateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optLateStructVal=%s' % (value))
    if self.optStructVal is not None:
      value = pprint.pformat(self.optStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStructVal=%s' % (value))
    if self.optEnumVal is not None:
      value = pprint.pformat(self.optEnumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optEnumVal=%s' % (value))
    if self.optBinaryVal is not None:
      value = pprint.pformat(self.optBinaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBinaryVal=%s' % (value))
    if self.optStringVal is not None:
      value = pprint.pformat(self.optStringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStringVal=%s' % (value))
    if self.optDoubleVal is not None:
      value = pprint.pformat(self.optDoubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optDoubleVal=%s' % (value))
    if self.optFloatVal is not None:
      value = pprint.pformat(self.optFloatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optFloatVal=%s' % (value))
    if self.optI64Val is not None:
      value = pprint.pformat(self.optI64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI64Val=%s' % (value))
    if self.optI32Val is not None:
      value = pprint.pformat(self.optI32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI32Val=%s' % (value))
    if self.optI16Val is not None:
      value = pprint.pformat(self.optI16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI16Val=%s' % (value))
    if self.optByteVal is not None:
      value = pprint.pformat(self.optByteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optByteVal=%s' % (value))
    if self.optBoolVal is not None:
      value = pprint.pformat(self.optBoolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBoolVal=%s' % (value))
    if self.lateStructVal is not None:
      value = pprint.pformat(self.lateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lateStructVal=%s' % (value))
    if self.unionVal is not None:
      value = pprint.pformat(self.unionVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionVal=%s' % (value))
    if self.structVal is not None:
      value = pprint.pformat(self.structVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structVal=%s' % (value))
    if self.enumVal is not None:
      value = pprint.pformat(self.enumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enumVal=%s' % (value))
    if self.binaryVal is not None:
      value = pprint.pformat(self.binaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryVal=%s' % (value))
    if self.stringVal is not None:
      value = pprint.pformat(self.stringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stringVal=%s' % (value))
    if self.doubleVal is not None:
      value = pprint.pformat(self.doubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleVal=%s' % (value))
    if self.floatVal is not None:
      value = pprint.pformat(self.floatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    floatVal=%s' % (value))
    if self.i64Val is not None:
      value = pprint.pformat(self.i64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i64Val=%s' % (value))
    if self.i32Val is not None:
      value = pprint.pformat(self.i32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32Val=%s' % (value))
    if self.i16Val is not None:
      value = pprint.pformat(self.i16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i16Val=%s' % (value))
    if self.byteVal is not None:
      value = pprint.pformat(self.byteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byteVal=%s' % (value))
    if self.boolVal is not None:
      value = pprint.pformat(self.boolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    boolVal=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'mapMap',
      'listMap',
      'optMapVal',
      'optSetVal',
      'optListVal',
      'optLateStructVal',
      'optStructVal',
      'optEnumVal',
      'optBinaryVal',
      'optStringVal',
      'optDoubleVal',
      'optFloatVal',
      'optI64Val',
      'optI32Val',
      'optI16Val',
      'optByteVal',
      'optBoolVal',
      'lateStructVal',
      'unionVal',
      'structVal',
      'enumVal',
      'binaryVal',
      'stringVal',
      'doubleVal',
      'floatVal',
      'i64Val',
      'i32Val',
      'i16Val',
      'byteVal',
      'boolVal',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyStructPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyStruct()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyStructFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = MyStructEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyStructFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyStruct()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyStructFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyStructEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyStructFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructPatch, self)

  def _to_py_deprecated(self):
    return self

class LateDefStructEnsureStruct:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LateDefStructEnsureStruct')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LateDefStructEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LateDefStructEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class LateDefStructFieldPatch:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LateDefStructFieldPatch')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LateDefStructFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LateDefStructFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class LateDefStructPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = LateDefStruct()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = LateDefStructFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = LateDefStructEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = LateDefStructFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LateDefStructPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = LateDefStruct()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = LateDefStructFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = LateDefStructEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = LateDefStructFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LateDefStructPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LateDefStructPatch, self)

  def _to_py_deprecated(self):
    return self

class RecursiveEnsureStruct:
  r"""
  Attributes:
   - nodes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.MAP:
          self.nodes = {}
          (_ktype843, _vtype844, _size842 ) = iprot.readMapBegin() 
          if _size842 >= 0:
            for _i846 in range(_size842):
              _key847 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val848 = Recursive()
              _val848.read(iprot)
              self.nodes[_key847] = _val848
          else: 
            while iprot.peekMap():
              _key849 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val850 = Recursive()
              _val850.read(iprot)
              self.nodes[_key849] = _val850
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RecursiveEnsureStruct')
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.MAP, -1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.nodes))
      for kiter851,viter852 in self.nodes.items():
        oprot.writeString(kiter851.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter851, bytes) else oprot.writeString(kiter851)
        viter852.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'nodes' in json_obj and json_obj['nodes'] is not None:
      self.nodes = dict_cls()
      for _tmp_k853, _tmp_v854 in json_obj['nodes'].items():
        _tmp_kp855 = _tmp_k853
        _struct856 = Recursive()
        _struct856.readFromJson(_tmp_v854, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.nodes[_tmp_kp855] = _struct856

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.nodes is not None:
      value = pprint.pformat(self.nodes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nodes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'nodes',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RecursiveEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RecursiveEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class RecursiveField1Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype858, _vtype859, _size857 ) = iprot.readMapBegin() 
          if _size857 >= 0:
            for _i861 in range(_size857):
              _key862 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val863 = Recursive()
              _val863.read(iprot)
              self.assign[_key862] = _val863
          else: 
            while iprot.peekMap():
              _key864 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val865 = Recursive()
              _val865.read(iprot)
              self.assign[_key864] = _val865
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RecursiveField1Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.assign))
      for kiter866,viter867 in self.assign.items():
        oprot.writeString(kiter866.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter866, bytes) else oprot.writeString(kiter866)
        viter867.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k868, _tmp_v869 in json_obj['assign'].items():
        _tmp_kp870 = _tmp_k868
        _struct871 = Recursive()
        _struct871.readFromJson(_tmp_v869, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.assign[_tmp_kp870] = _struct871
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RecursiveField1Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RecursiveField1Patch, self)

  def _to_py_deprecated(self):
    return self

class RecursiveFieldPatch:
  r"""
  Attributes:
   - nodes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.nodes = RecursiveField1Patch()
          self.nodes.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RecursiveFieldPatch')
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.STRUCT, -1)
      self.nodes.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'nodes' in json_obj and json_obj['nodes'] is not None:
      self.nodes = RecursiveField1Patch()
      self.nodes.readFromJson(json_obj['nodes'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.nodes is not None:
      value = pprint.pformat(self.nodes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nodes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'nodes',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RecursiveFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RecursiveFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class RecursivePatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = Recursive()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = RecursiveFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = RecursiveEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = RecursiveFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RecursivePatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = Recursive()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = RecursiveFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = RecursiveEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = RecursiveFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RecursivePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RecursivePatch, self)

  def _to_py_deprecated(self):
    return self

class BarEnsureStruct:
  r"""
  Attributes:
   - loop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.loop = Loop()
          self.loop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BarEnsureStruct')
    if self.loop != None:
      oprot.writeFieldBegin('loop', TType.STRUCT, -1)
      self.loop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'loop' in json_obj and json_obj['loop'] is not None:
      self.loop = Loop()
      self.loop.readFromJson(json_obj['loop'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.loop is not None:
      value = pprint.pformat(self.loop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    loop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'loop',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BarEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BarEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class BarFieldPatch:
  r"""
  Attributes:
   - loop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.loop = LoopPatch()
          self.loop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BarFieldPatch')
    if self.loop != None:
      oprot.writeFieldBegin('loop', TType.STRUCT, -1)
      self.loop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'loop' in json_obj and json_obj['loop'] is not None:
      self.loop = LoopPatch()
      self.loop.readFromJson(json_obj['loop'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.loop is not None:
      value = pprint.pformat(self.loop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    loop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'loop',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BarFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BarFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class BarPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = Bar()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = BarFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = BarEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = BarFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BarPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = Bar()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = BarFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = BarEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = BarFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BarPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BarPatch, self)

  def _to_py_deprecated(self):
    return self

class LoopEnsureStruct:
  r"""
  Attributes:
   - bar
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.bar = Bar()
          self.bar.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LoopEnsureStruct')
    if self.bar != None:
      oprot.writeFieldBegin('bar', TType.STRUCT, -1)
      self.bar.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'bar' in json_obj and json_obj['bar'] is not None:
      self.bar = Bar()
      self.bar.readFromJson(json_obj['bar'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.bar is not None:
      value = pprint.pformat(self.bar, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bar=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'bar',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LoopEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LoopEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class LoopFieldPatch:
  r"""
  Attributes:
   - bar
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.bar = BarPatch()
          self.bar.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LoopFieldPatch')
    if self.bar != None:
      oprot.writeFieldBegin('bar', TType.STRUCT, -1)
      self.bar.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'bar' in json_obj and json_obj['bar'] is not None:
      self.bar = BarPatch()
      self.bar.readFromJson(json_obj['bar'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.bar is not None:
      value = pprint.pformat(self.bar, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bar=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'bar',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LoopFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LoopFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class LoopPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = Loop()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LoopPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = Loop()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LoopPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LoopPatch, self)

  def _to_py_deprecated(self):
    return self

all_structs.append(MyData)
MyData.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'data1', True, None, 3, ), # 1
  (2, TType.I32, 'data2', None, None, 3, ), # 2
)

MyData.thrift_struct_annotations = {
}
MyData.thrift_field_annotations = {
}

def MyData__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyData.__init__ = MyData__init__

def MyData__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyData.__getstate__ = lambda self: self.__dict__.copy()
MyData.__setstate__ = MyData__setstate__

all_structs.append(InnerUnion)
InnerUnion.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'innerOption', False, None, 2, ), # 1
)

InnerUnion.thrift_struct_annotations = {
}
InnerUnion.thrift_field_annotations = {
}

def InnerUnion__init__(self, innerOption=None,):
  self.field = 0
  self.value = None
  if innerOption is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = innerOption

InnerUnion.__init__ = InnerUnion__init__

all_structs.append(MyUnion)
MyUnion.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'option1', True, None, 2, ), # 1
  (2, TType.I32, 'option2', None, None, 2, ), # 2
  (3, TType.STRUCT, 'option3', [InnerUnion, InnerUnion.thrift_spec, True], None, 2, ), # 3
)

MyUnion.thrift_struct_annotations = {
}
MyUnion.thrift_field_annotations = {
}

def MyUnion__init__(self, option1=None, option2=None, option3=None,):
  self.field = 0
  self.value = None
  if option1 is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = option1
  if option2 is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = option2
  if option3 is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = option3

MyUnion.__init__ = MyUnion__init__

all_structs.append(MyStruct)
MyStruct.thrift_spec = (
  (-30, TType.MAP, 'mapMap', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # -30
  (-29, TType.LIST, 'listMap', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # -29
  (-28, TType.MAP, 'optMapVal', (TType.STRING,True,TType.STRING,True), None, 1, ), # -28
  (-27, TType.SET, 'optSetVal', (TType.STRING,True), None, 1, ), # -27
  (-26, TType.LIST, 'optListVal', (TType.I16,None), None, 1, ), # -26
  (-25, TType.STRUCT, 'optLateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 1, ), # -25
  (-24, TType.STRUCT, 'optStructVal', [MyData, MyData.thrift_spec, False], None, 1, ), # -24
  (-23, TType.I32, 'optEnumVal', MyEnum, None, 1, ), # -23
  (-22, TType.STRING, 'optBinaryVal', False, None, 1, ), # -22
  (-21, TType.STRING, 'optStringVal', True, None, 1, ), # -21
  (-20, TType.DOUBLE, 'optDoubleVal', None, None, 1, ), # -20
  (-19, TType.FLOAT, 'optFloatVal', None, None, 1, ), # -19
  (-18, TType.I64, 'optI64Val', None, None, 1, ), # -18
  (-17, TType.I32, 'optI32Val', None, None, 1, ), # -17
  (-16, TType.I16, 'optI16Val', None, None, 1, ), # -16
  (-15, TType.BYTE, 'optByteVal', None, None, 1, ), # -15
  (-14, TType.BOOL, 'optBoolVal', None, None, 1, ), # -14
  (-13, TType.STRUCT, 'lateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 3, ), # -13
  (-12, TType.STRUCT, 'unionVal', [MyUnion, MyUnion.thrift_spec, True], None, 3, ), # -12
  (-11, TType.STRUCT, 'structVal', [MyData, MyData.thrift_spec, False], None, 3, ), # -11
  (-10, TType.I32, 'enumVal', MyEnum, None, 3, ), # -10
  (-9, TType.STRING, 'binaryVal', False, None, 3, ), # -9
  (-8, TType.STRING, 'stringVal', True, None, 3, ), # -8
  (-7, TType.DOUBLE, 'doubleVal', None, None, 3, ), # -7
  (-6, TType.FLOAT, 'floatVal', None, None, 3, ), # -6
  (-5, TType.I64, 'i64Val', None, None, 3, ), # -5
  (-4, TType.I32, 'i32Val', None, None, 3, ), # -4
  (-3, TType.I16, 'i16Val', None, None, 3, ), # -3
  (-2, TType.BYTE, 'byteVal', None, None, 3, ), # -2
  (-1, TType.BOOL, 'boolVal', None, None, 3, ), # -1
)

MyStruct.thrift_struct_annotations = {
}
MyStruct.thrift_field_annotations = {
}

def MyStruct__init__(self, boolVal=None, byteVal=None, i16Val=None, i32Val=None, i64Val=None, floatVal=None, doubleVal=None, stringVal=None, binaryVal=None, enumVal=None, structVal=None, unionVal=None, lateStructVal=None, optBoolVal=None, optByteVal=None, optI16Val=None, optI32Val=None, optI64Val=None, optFloatVal=None, optDoubleVal=None, optStringVal=None, optBinaryVal=None, optEnumVal=None, optStructVal=None, optLateStructVal=None, optListVal=None, optSetVal=None, optMapVal=None, listMap=None, mapMap=None,):
  self.boolVal = boolVal
  self.byteVal = byteVal
  self.i16Val = i16Val
  self.i32Val = i32Val
  self.i64Val = i64Val
  self.floatVal = floatVal
  self.doubleVal = doubleVal
  self.stringVal = stringVal
  self.binaryVal = binaryVal
  self.enumVal = enumVal
  self.structVal = structVal
  self.unionVal = unionVal
  self.lateStructVal = lateStructVal
  self.optBoolVal = optBoolVal
  self.optByteVal = optByteVal
  self.optI16Val = optI16Val
  self.optI32Val = optI32Val
  self.optI64Val = optI64Val
  self.optFloatVal = optFloatVal
  self.optDoubleVal = optDoubleVal
  self.optStringVal = optStringVal
  self.optBinaryVal = optBinaryVal
  self.optEnumVal = optEnumVal
  self.optStructVal = optStructVal
  self.optLateStructVal = optLateStructVal
  self.optListVal = optListVal
  self.optSetVal = optSetVal
  self.optMapVal = optMapVal
  self.listMap = listMap
  self.mapMap = mapMap

MyStruct.__init__ = MyStruct__init__

def MyStruct__setstate__(self, state):
  state.setdefault('boolVal', None)
  state.setdefault('byteVal', None)
  state.setdefault('i16Val', None)
  state.setdefault('i32Val', None)
  state.setdefault('i64Val', None)
  state.setdefault('floatVal', None)
  state.setdefault('doubleVal', None)
  state.setdefault('stringVal', None)
  state.setdefault('binaryVal', None)
  state.setdefault('enumVal', None)
  state.setdefault('structVal', None)
  state.setdefault('unionVal', None)
  state.setdefault('lateStructVal', None)
  state.setdefault('optBoolVal', None)
  state.setdefault('optByteVal', None)
  state.setdefault('optI16Val', None)
  state.setdefault('optI32Val', None)
  state.setdefault('optI64Val', None)
  state.setdefault('optFloatVal', None)
  state.setdefault('optDoubleVal', None)
  state.setdefault('optStringVal', None)
  state.setdefault('optBinaryVal', None)
  state.setdefault('optEnumVal', None)
  state.setdefault('optStructVal', None)
  state.setdefault('optLateStructVal', None)
  state.setdefault('optListVal', None)
  state.setdefault('optSetVal', None)
  state.setdefault('optMapVal', None)
  state.setdefault('listMap', None)
  state.setdefault('mapMap', None)
  self.__dict__ = state

MyStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStruct.__setstate__ = MyStruct__setstate__

all_structs.append(LateDefStruct)
LateDefStruct.thrift_spec = (
)

LateDefStruct.thrift_struct_annotations = {
}
LateDefStruct.thrift_field_annotations = {
}

all_structs.append(Recursive)
Recursive.thrift_spec = (
  (-1, TType.MAP, 'nodes', (TType.STRING,True,TType.STRUCT,[Recursive, Recursive.thrift_spec, False]), None, 3, ), # -1
)

Recursive.thrift_struct_annotations = {
}
Recursive.thrift_field_annotations = {
}

def Recursive__init__(self, nodes=None,):
  self.nodes = nodes

Recursive.__init__ = Recursive__init__

def Recursive__setstate__(self, state):
  state.setdefault('nodes', None)
  self.__dict__ = state

Recursive.__getstate__ = lambda self: self.__dict__.copy()
Recursive.__setstate__ = Recursive__setstate__

all_structs.append(Bar)
Bar.thrift_spec = (
  (-1, TType.STRUCT, 'loop', [Loop, Loop.thrift_spec, False], None, 3, ), # -1
)

Bar.thrift_struct_annotations = {
}
Bar.thrift_field_annotations = {
  -1: {
    "cpp.ref": "1",
  },
}

def Bar__init__(self, loop=None,):
  self.loop = loop

Bar.__init__ = Bar__init__

def Bar__setstate__(self, state):
  state.setdefault('loop', None)
  self.__dict__ = state

Bar.__getstate__ = lambda self: self.__dict__.copy()
Bar.__setstate__ = Bar__setstate__

all_structs.append(Loop)
Loop.thrift_spec = (
  (-1, TType.STRUCT, 'bar', [Bar, Bar.thrift_spec, False], None, 3, ), # -1
)

Loop.thrift_struct_annotations = {
}
Loop.thrift_field_annotations = {
}

def Loop__init__(self, bar=None,):
  self.bar = bar

Loop.__init__ = Loop__init__

def Loop__setstate__(self, state):
  state.setdefault('bar', None)
  self.__dict__ = state

Loop.__getstate__ = lambda self: self.__dict__.copy()
Loop.__setstate__ = Loop__setstate__

all_structs.append(MyDataEnsureStruct)
MyDataEnsureStruct.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'data1', True, None, 1, ), # 1
  (2, TType.I32, 'data2', None, None, 1, ), # 2
)

MyDataEnsureStruct.thrift_struct_annotations = {
}
MyDataEnsureStruct.thrift_field_annotations = {
}

def MyDataEnsureStruct__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyDataEnsureStruct.__init__ = MyDataEnsureStruct__init__

def MyDataEnsureStruct__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyDataEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
MyDataEnsureStruct.__setstate__ = MyDataEnsureStruct__setstate__

all_structs.append(MyDataFieldPatch)
MyDataFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'data1', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # 1
  (2, TType.STRUCT, 'data2', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # 2
)

MyDataFieldPatch.thrift_struct_annotations = {
}
MyDataFieldPatch.thrift_field_annotations = {
}

def MyDataFieldPatch__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyDataFieldPatch.__init__ = MyDataFieldPatch__init__

def MyDataFieldPatch__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyDataFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyDataFieldPatch.__setstate__ = MyDataFieldPatch__setstate__

all_structs.append(MyDataPatch)
MyDataPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyData, MyData.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyDataFieldPatch, MyDataFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [MyDataEnsureStruct, MyDataEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [MyDataFieldPatch, MyDataFieldPatch.thrift_spec, False], None, 3, ), # 6
)

MyDataPatch.thrift_struct_annotations = {
}
MyDataPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyDataPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

MyDataPatch.__init__ = MyDataPatch__init__

def MyDataPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

MyDataPatch.__getstate__ = lambda self: self.__dict__.copy()
MyDataPatch.__setstate__ = MyDataPatch__setstate__

all_structs.append(InnerUnionFieldPatch)
InnerUnionFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'innerOption', [thrift.lib.thrift.patch.ttypes.BinaryPatch, thrift.lib.thrift.patch.ttypes.BinaryPatch.thrift_spec, False], None, 3, ), # 1
)

InnerUnionFieldPatch.thrift_struct_annotations = {
}
InnerUnionFieldPatch.thrift_field_annotations = {
}

def InnerUnionFieldPatch__init__(self, innerOption=None,):
  self.innerOption = innerOption

InnerUnionFieldPatch.__init__ = InnerUnionFieldPatch__init__

def InnerUnionFieldPatch__setstate__(self, state):
  state.setdefault('innerOption', None)
  self.__dict__ = state

InnerUnionFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
InnerUnionFieldPatch.__setstate__ = InnerUnionFieldPatch__setstate__

all_structs.append(InnerUnionPatch)
InnerUnionPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [InnerUnion, InnerUnion.thrift_spec, True], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [InnerUnionFieldPatch, InnerUnionFieldPatch.thrift_spec, False], None, 3, ), # 3
  (4, TType.STRUCT, 'ensure', [InnerUnion, InnerUnion.thrift_spec, True], None, 3, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [InnerUnionFieldPatch, InnerUnionFieldPatch.thrift_spec, False], None, 3, ), # 6
)

InnerUnionPatch.thrift_struct_annotations = {
}
InnerUnionPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def InnerUnionPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

InnerUnionPatch.__init__ = InnerUnionPatch__init__

def InnerUnionPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

InnerUnionPatch.__getstate__ = lambda self: self.__dict__.copy()
InnerUnionPatch.__setstate__ = InnerUnionPatch__setstate__

all_structs.append(MyUnionFieldPatch)
MyUnionFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'option1', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # 1
  (2, TType.STRUCT, 'option2', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # 2
  (3, TType.STRUCT, 'option3', [InnerUnionPatch, InnerUnionPatch.thrift_spec, False], None, 3, ), # 3
)

MyUnionFieldPatch.thrift_struct_annotations = {
}
MyUnionFieldPatch.thrift_field_annotations = {
}

def MyUnionFieldPatch__init__(self, option1=None, option2=None, option3=None,):
  self.option1 = option1
  self.option2 = option2
  self.option3 = option3

MyUnionFieldPatch.__init__ = MyUnionFieldPatch__init__

def MyUnionFieldPatch__setstate__(self, state):
  state.setdefault('option1', None)
  state.setdefault('option2', None)
  state.setdefault('option3', None)
  self.__dict__ = state

MyUnionFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyUnionFieldPatch.__setstate__ = MyUnionFieldPatch__setstate__

all_structs.append(MyUnionPatch)
MyUnionPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyUnion, MyUnion.thrift_spec, True], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyUnionFieldPatch, MyUnionFieldPatch.thrift_spec, False], None, 3, ), # 3
  (4, TType.STRUCT, 'ensure', [MyUnion, MyUnion.thrift_spec, True], None, 3, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [MyUnionFieldPatch, MyUnionFieldPatch.thrift_spec, False], None, 3, ), # 6
)

MyUnionPatch.thrift_struct_annotations = {
}
MyUnionPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyUnionPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

MyUnionPatch.__init__ = MyUnionPatch__init__

def MyUnionPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

MyUnionPatch.__getstate__ = lambda self: self.__dict__.copy()
MyUnionPatch.__setstate__ = MyUnionPatch__setstate__

all_structs.append(MyStructEnsureStruct)
MyStructEnsureStruct.thrift_spec = (
  (-30, TType.MAP, 'mapMap', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 1, ), # -30
  (-29, TType.LIST, 'listMap', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 1, ), # -29
  (-28, TType.MAP, 'optMapVal', (TType.STRING,True,TType.STRING,True), None, 1, ), # -28
  (-27, TType.SET, 'optSetVal', (TType.STRING,True), None, 1, ), # -27
  (-26, TType.LIST, 'optListVal', (TType.I16,None), None, 1, ), # -26
  (-25, TType.STRUCT, 'optLateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 1, ), # -25
  (-24, TType.STRUCT, 'optStructVal', [MyData, MyData.thrift_spec, False], None, 1, ), # -24
  (-23, TType.I32, 'optEnumVal', MyEnum, None, 1, ), # -23
  (-22, TType.STRING, 'optBinaryVal', False, None, 1, ), # -22
  (-21, TType.STRING, 'optStringVal', True, None, 1, ), # -21
  (-20, TType.DOUBLE, 'optDoubleVal', None, None, 1, ), # -20
  (-19, TType.FLOAT, 'optFloatVal', None, None, 1, ), # -19
  (-18, TType.I64, 'optI64Val', None, None, 1, ), # -18
  (-17, TType.I32, 'optI32Val', None, None, 1, ), # -17
  (-16, TType.I16, 'optI16Val', None, None, 1, ), # -16
  (-15, TType.BYTE, 'optByteVal', None, None, 1, ), # -15
  (-14, TType.BOOL, 'optBoolVal', None, None, 1, ), # -14
  (-13, TType.STRUCT, 'lateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 1, ), # -13
  (-12, TType.STRUCT, 'unionVal', [MyUnion, MyUnion.thrift_spec, True], None, 1, ), # -12
  (-11, TType.STRUCT, 'structVal', [MyData, MyData.thrift_spec, False], None, 1, ), # -11
  (-10, TType.I32, 'enumVal', MyEnum, None, 1, ), # -10
  (-9, TType.STRING, 'binaryVal', False, None, 1, ), # -9
  (-8, TType.STRING, 'stringVal', True, None, 1, ), # -8
  (-7, TType.DOUBLE, 'doubleVal', None, None, 1, ), # -7
  (-6, TType.FLOAT, 'floatVal', None, None, 1, ), # -6
  (-5, TType.I64, 'i64Val', None, None, 1, ), # -5
  (-4, TType.I32, 'i32Val', None, None, 1, ), # -4
  (-3, TType.I16, 'i16Val', None, None, 1, ), # -3
  (-2, TType.BYTE, 'byteVal', None, None, 1, ), # -2
  (-1, TType.BOOL, 'boolVal', None, None, 1, ), # -1
)

MyStructEnsureStruct.thrift_struct_annotations = {
}
MyStructEnsureStruct.thrift_field_annotations = {
  -25: {
    "thrift.box": "",
  },
  -24: {
    "thrift.box": "",
  },
  -13: {
    "thrift.box": "",
  },
  -12: {
    "thrift.box": "",
  },
  -11: {
    "thrift.box": "",
  },
}

def MyStructEnsureStruct__init__(self, mapMap=None, listMap=None, optMapVal=None, optSetVal=None, optListVal=None, optLateStructVal=None, optStructVal=None, optEnumVal=None, optBinaryVal=None, optStringVal=None, optDoubleVal=None, optFloatVal=None, optI64Val=None, optI32Val=None, optI16Val=None, optByteVal=None, optBoolVal=None, lateStructVal=None, unionVal=None, structVal=None, enumVal=None, binaryVal=None, stringVal=None, doubleVal=None, floatVal=None, i64Val=None, i32Val=None, i16Val=None, byteVal=None, boolVal=None,):
  self.mapMap = mapMap
  self.listMap = listMap
  self.optMapVal = optMapVal
  self.optSetVal = optSetVal
  self.optListVal = optListVal
  self.optLateStructVal = optLateStructVal
  self.optStructVal = optStructVal
  self.optEnumVal = optEnumVal
  self.optBinaryVal = optBinaryVal
  self.optStringVal = optStringVal
  self.optDoubleVal = optDoubleVal
  self.optFloatVal = optFloatVal
  self.optI64Val = optI64Val
  self.optI32Val = optI32Val
  self.optI16Val = optI16Val
  self.optByteVal = optByteVal
  self.optBoolVal = optBoolVal
  self.lateStructVal = lateStructVal
  self.unionVal = unionVal
  self.structVal = structVal
  self.enumVal = enumVal
  self.binaryVal = binaryVal
  self.stringVal = stringVal
  self.doubleVal = doubleVal
  self.floatVal = floatVal
  self.i64Val = i64Val
  self.i32Val = i32Val
  self.i16Val = i16Val
  self.byteVal = byteVal
  self.boolVal = boolVal

MyStructEnsureStruct.__init__ = MyStructEnsureStruct__init__

def MyStructEnsureStruct__setstate__(self, state):
  state.setdefault('mapMap', None)
  state.setdefault('listMap', None)
  state.setdefault('optMapVal', None)
  state.setdefault('optSetVal', None)
  state.setdefault('optListVal', None)
  state.setdefault('optLateStructVal', None)
  state.setdefault('optStructVal', None)
  state.setdefault('optEnumVal', None)
  state.setdefault('optBinaryVal', None)
  state.setdefault('optStringVal', None)
  state.setdefault('optDoubleVal', None)
  state.setdefault('optFloatVal', None)
  state.setdefault('optI64Val', None)
  state.setdefault('optI32Val', None)
  state.setdefault('optI16Val', None)
  state.setdefault('optByteVal', None)
  state.setdefault('optBoolVal', None)
  state.setdefault('lateStructVal', None)
  state.setdefault('unionVal', None)
  state.setdefault('structVal', None)
  state.setdefault('enumVal', None)
  state.setdefault('binaryVal', None)
  state.setdefault('stringVal', None)
  state.setdefault('doubleVal', None)
  state.setdefault('floatVal', None)
  state.setdefault('i64Val', None)
  state.setdefault('i32Val', None)
  state.setdefault('i16Val', None)
  state.setdefault('byteVal', None)
  state.setdefault('boolVal', None)
  self.__dict__ = state

MyStructEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStructEnsureStruct.__setstate__ = MyStructEnsureStruct__setstate__

all_structs.append(MyStructField10Patch)
MyStructField10Patch.thrift_spec = (
  None, # 0
  (1, TType.I32, 'assign', MyEnum, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
)

MyStructField10Patch.thrift_struct_annotations = {
}
MyStructField10Patch.thrift_field_annotations = {
}

def MyStructField10Patch__init__(self, assign=None, clear=None,):
  self.assign = assign
  self.clear = clear

MyStructField10Patch.__init__ = MyStructField10Patch__init__

def MyStructField10Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  self.__dict__ = state

MyStructField10Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField10Patch.__setstate__ = MyStructField10Patch__setstate__

all_structs.append(MyStructField23Patch)
MyStructField23Patch.thrift_spec = (
  None, # 0
  (1, TType.I32, 'assign', MyEnum, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
)

MyStructField23Patch.thrift_struct_annotations = {
}
MyStructField23Patch.thrift_field_annotations = {
}

def MyStructField23Patch__init__(self, assign=None, clear=None,):
  self.assign = assign
  self.clear = clear

MyStructField23Patch.__init__ = MyStructField23Patch__init__

def MyStructField23Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  self.__dict__ = state

MyStructField23Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField23Patch.__setstate__ = MyStructField23Patch__setstate__

all_structs.append(MyStructField26Patch)
MyStructField26Patch.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'assign', (TType.I16,None), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patch', (TType.I32,None,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I16Patch, thrift.lib.thrift.patch.ttypes.I16Patch.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  None, # 5
  None, # 6
  (7, TType.LIST, 'remove', (TType.I16,None), None, 3, ), # 7
  (8, TType.LIST, 'prepend', (TType.I16,None), None, 3, ), # 8
  (9, TType.LIST, 'append', (TType.I16,None), None, 3, ), # 9
)

MyStructField26Patch.thrift_struct_annotations = {
}
MyStructField26Patch.thrift_field_annotations = {
}

def MyStructField26Patch__init__(self, assign=None, clear=None, patch=None, remove=None, prepend=None, append=None,):
  self.assign = assign
  self.clear = clear
  self.patch = patch
  self.remove = remove
  self.prepend = prepend
  self.append = append

MyStructField26Patch.__init__ = MyStructField26Patch__init__

def MyStructField26Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('prepend', None)
  state.setdefault('append', None)
  self.__dict__ = state

MyStructField26Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField26Patch.__setstate__ = MyStructField26Patch__setstate__

all_structs.append(MyStructField27Patch)
MyStructField27Patch.thrift_spec = (
  None, # 0
  (1, TType.SET, 'assign', (TType.STRING,True), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  (8, TType.SET, 'add', (TType.STRING,True), None, 3, ), # 8
)

MyStructField27Patch.thrift_struct_annotations = {
}
MyStructField27Patch.thrift_field_annotations = {
}

def MyStructField27Patch__init__(self, assign=None, clear=None, remove=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.remove = remove
  self.add = add

MyStructField27Patch.__init__ = MyStructField27Patch__init__

def MyStructField27Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('remove', None)
  state.setdefault('add', None)
  self.__dict__ = state

MyStructField27Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField27Patch.__setstate__ = MyStructField27Patch__setstate__

all_structs.append(MyStructField28Patch)
MyStructField28Patch.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.STRING,True), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patchPrior', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  (5, TType.MAP, 'add', (TType.STRING,True,TType.STRING,True), None, 3, ), # 5
  (6, TType.MAP, 'patch', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False]), None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  None, # 8
  (9, TType.MAP, 'put', (TType.STRING,True,TType.STRING,True), None, 3, ), # 9
)

MyStructField28Patch.thrift_struct_annotations = {
}
MyStructField28Patch.thrift_field_annotations = {
}

def MyStructField28Patch__init__(self, assign=None, clear=None, patchPrior=None, add=None, patch=None, remove=None, put=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.add = add
  self.patch = patch
  self.remove = remove
  self.put = put

MyStructField28Patch.__init__ = MyStructField28Patch__init__

def MyStructField28Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('add', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('put', None)
  self.__dict__ = state

MyStructField28Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField28Patch.__setstate__ = MyStructField28Patch__setstate__

all_structs.append(MyStructField29Patch)
MyStructField29Patch.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'assign', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patch', (TType.I32,None,TType.STRUCT,[MyStructField29Patch1, MyStructField29Patch1.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  None, # 5
  None, # 6
  (7, TType.LIST, 'remove', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 7
  (8, TType.LIST, 'prepend', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 8
  (9, TType.LIST, 'append', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 9
)

MyStructField29Patch.thrift_struct_annotations = {
}
MyStructField29Patch.thrift_field_annotations = {
}

def MyStructField29Patch__init__(self, assign=None, clear=None, patch=None, remove=None, prepend=None, append=None,):
  self.assign = assign
  self.clear = clear
  self.patch = patch
  self.remove = remove
  self.prepend = prepend
  self.append = append

MyStructField29Patch.__init__ = MyStructField29Patch__init__

def MyStructField29Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('prepend', None)
  state.setdefault('append', None)
  self.__dict__ = state

MyStructField29Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField29Patch.__setstate__ = MyStructField29Patch__setstate__

all_structs.append(MyStructField29Patch1)
MyStructField29Patch1.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.I32,None), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patchPrior', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  (5, TType.MAP, 'add', (TType.STRING,True,TType.I32,None), None, 3, ), # 5
  (6, TType.MAP, 'patch', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False]), None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  None, # 8
  (9, TType.MAP, 'put', (TType.STRING,True,TType.I32,None), None, 3, ), # 9
)

MyStructField29Patch1.thrift_struct_annotations = {
}
MyStructField29Patch1.thrift_field_annotations = {
}

def MyStructField29Patch1__init__(self, assign=None, clear=None, patchPrior=None, add=None, patch=None, remove=None, put=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.add = add
  self.patch = patch
  self.remove = remove
  self.put = put

MyStructField29Patch1.__init__ = MyStructField29Patch1__init__

def MyStructField29Patch1__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('add', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('put', None)
  self.__dict__ = state

MyStructField29Patch1.__getstate__ = lambda self: self.__dict__.copy()
MyStructField29Patch1.__setstate__ = MyStructField29Patch1__setstate__

all_structs.append(MyStructField30Patch)
MyStructField30Patch.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patchPrior', (TType.STRING,True,TType.STRUCT,[MyStructField30Patch1, MyStructField30Patch1.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  (5, TType.MAP, 'add', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 5
  (6, TType.MAP, 'patch', (TType.STRING,True,TType.STRUCT,[MyStructField30Patch1, MyStructField30Patch1.thrift_spec, False]), None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  None, # 8
  (9, TType.MAP, 'put', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 9
)

MyStructField30Patch.thrift_struct_annotations = {
}
MyStructField30Patch.thrift_field_annotations = {
}

def MyStructField30Patch__init__(self, assign=None, clear=None, patchPrior=None, add=None, patch=None, remove=None, put=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.add = add
  self.patch = patch
  self.remove = remove
  self.put = put

MyStructField30Patch.__init__ = MyStructField30Patch__init__

def MyStructField30Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('add', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('put', None)
  self.__dict__ = state

MyStructField30Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField30Patch.__setstate__ = MyStructField30Patch__setstate__

all_structs.append(MyStructField30Patch1)
MyStructField30Patch1.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.I32,None), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patchPrior', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  (5, TType.MAP, 'add', (TType.STRING,True,TType.I32,None), None, 3, ), # 5
  (6, TType.MAP, 'patch', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False]), None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  None, # 8
  (9, TType.MAP, 'put', (TType.STRING,True,TType.I32,None), None, 3, ), # 9
)

MyStructField30Patch1.thrift_struct_annotations = {
}
MyStructField30Patch1.thrift_field_annotations = {
}

def MyStructField30Patch1__init__(self, assign=None, clear=None, patchPrior=None, add=None, patch=None, remove=None, put=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.add = add
  self.patch = patch
  self.remove = remove
  self.put = put

MyStructField30Patch1.__init__ = MyStructField30Patch1__init__

def MyStructField30Patch1__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('add', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('put', None)
  self.__dict__ = state

MyStructField30Patch1.__getstate__ = lambda self: self.__dict__.copy()
MyStructField30Patch1.__setstate__ = MyStructField30Patch1__setstate__

all_structs.append(MyStructFieldPatch)
MyStructFieldPatch.thrift_spec = (
  (-30, TType.STRUCT, 'mapMap', [MyStructField30Patch, MyStructField30Patch.thrift_spec, False], None, 3, ), # -30
  (-29, TType.STRUCT, 'listMap', [MyStructField29Patch, MyStructField29Patch.thrift_spec, False], None, 3, ), # -29
  (-28, TType.STRUCT, 'optMapVal', [MyStructField28Patch, MyStructField28Patch.thrift_spec, False], None, 3, ), # -28
  (-27, TType.STRUCT, 'optSetVal', [MyStructField27Patch, MyStructField27Patch.thrift_spec, False], None, 3, ), # -27
  (-26, TType.STRUCT, 'optListVal', [MyStructField26Patch, MyStructField26Patch.thrift_spec, False], None, 3, ), # -26
  (-25, TType.STRUCT, 'optLateStructVal', [LateDefStructPatch, LateDefStructPatch.thrift_spec, False], None, 3, ), # -25
  (-24, TType.STRUCT, 'optStructVal', [MyDataPatch, MyDataPatch.thrift_spec, False], None, 3, ), # -24
  (-23, TType.STRUCT, 'optEnumVal', [MyStructField23Patch, MyStructField23Patch.thrift_spec, False], None, 3, ), # -23
  (-22, TType.STRUCT, 'optBinaryVal', [thrift.lib.thrift.patch.ttypes.BinaryPatch, thrift.lib.thrift.patch.ttypes.BinaryPatch.thrift_spec, False], None, 3, ), # -22
  (-21, TType.STRUCT, 'optStringVal', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # -21
  (-20, TType.STRUCT, 'optDoubleVal', [thrift.lib.thrift.patch.ttypes.DoublePatch, thrift.lib.thrift.patch.ttypes.DoublePatch.thrift_spec, False], None, 3, ), # -20
  (-19, TType.STRUCT, 'optFloatVal', [thrift.lib.thrift.patch.ttypes.FloatPatch, thrift.lib.thrift.patch.ttypes.FloatPatch.thrift_spec, False], None, 3, ), # -19
  (-18, TType.STRUCT, 'optI64Val', [thrift.lib.thrift.patch.ttypes.I64Patch, thrift.lib.thrift.patch.ttypes.I64Patch.thrift_spec, False], None, 3, ), # -18
  (-17, TType.STRUCT, 'optI32Val', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # -17
  (-16, TType.STRUCT, 'optI16Val', [thrift.lib.thrift.patch.ttypes.I16Patch, thrift.lib.thrift.patch.ttypes.I16Patch.thrift_spec, False], None, 3, ), # -16
  (-15, TType.STRUCT, 'optByteVal', [thrift.lib.thrift.patch.ttypes.BytePatch, thrift.lib.thrift.patch.ttypes.BytePatch.thrift_spec, False], None, 3, ), # -15
  (-14, TType.STRUCT, 'optBoolVal', [thrift.lib.thrift.patch.ttypes.BoolPatch, thrift.lib.thrift.patch.ttypes.BoolPatch.thrift_spec, False], None, 3, ), # -14
  (-13, TType.STRUCT, 'lateStructVal', [LateDefStructPatch, LateDefStructPatch.thrift_spec, False], None, 3, ), # -13
  (-12, TType.STRUCT, 'unionVal', [MyUnionPatch, MyUnionPatch.thrift_spec, False], None, 3, ), # -12
  (-11, TType.STRUCT, 'structVal', [MyDataPatch, MyDataPatch.thrift_spec, False], None, 3, ), # -11
  (-10, TType.STRUCT, 'enumVal', [MyStructField10Patch, MyStructField10Patch.thrift_spec, False], None, 3, ), # -10
  (-9, TType.STRUCT, 'binaryVal', [thrift.lib.thrift.patch.ttypes.BinaryPatch, thrift.lib.thrift.patch.ttypes.BinaryPatch.thrift_spec, False], None, 3, ), # -9
  (-8, TType.STRUCT, 'stringVal', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # -8
  (-7, TType.STRUCT, 'doubleVal', [thrift.lib.thrift.patch.ttypes.DoublePatch, thrift.lib.thrift.patch.ttypes.DoublePatch.thrift_spec, False], None, 3, ), # -7
  (-6, TType.STRUCT, 'floatVal', [thrift.lib.thrift.patch.ttypes.FloatPatch, thrift.lib.thrift.patch.ttypes.FloatPatch.thrift_spec, False], None, 3, ), # -6
  (-5, TType.STRUCT, 'i64Val', [thrift.lib.thrift.patch.ttypes.I64Patch, thrift.lib.thrift.patch.ttypes.I64Patch.thrift_spec, False], None, 3, ), # -5
  (-4, TType.STRUCT, 'i32Val', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # -4
  (-3, TType.STRUCT, 'i16Val', [thrift.lib.thrift.patch.ttypes.I16Patch, thrift.lib.thrift.patch.ttypes.I16Patch.thrift_spec, False], None, 3, ), # -3
  (-2, TType.STRUCT, 'byteVal', [thrift.lib.thrift.patch.ttypes.BytePatch, thrift.lib.thrift.patch.ttypes.BytePatch.thrift_spec, False], None, 3, ), # -2
  (-1, TType.STRUCT, 'boolVal', [thrift.lib.thrift.patch.ttypes.BoolPatch, thrift.lib.thrift.patch.ttypes.BoolPatch.thrift_spec, False], None, 3, ), # -1
)

MyStructFieldPatch.thrift_struct_annotations = {
}
MyStructFieldPatch.thrift_field_annotations = {
}

def MyStructFieldPatch__init__(self, mapMap=None, listMap=None, optMapVal=None, optSetVal=None, optListVal=None, optLateStructVal=None, optStructVal=None, optEnumVal=None, optBinaryVal=None, optStringVal=None, optDoubleVal=None, optFloatVal=None, optI64Val=None, optI32Val=None, optI16Val=None, optByteVal=None, optBoolVal=None, lateStructVal=None, unionVal=None, structVal=None, enumVal=None, binaryVal=None, stringVal=None, doubleVal=None, floatVal=None, i64Val=None, i32Val=None, i16Val=None, byteVal=None, boolVal=None,):
  self.mapMap = mapMap
  self.listMap = listMap
  self.optMapVal = optMapVal
  self.optSetVal = optSetVal
  self.optListVal = optListVal
  self.optLateStructVal = optLateStructVal
  self.optStructVal = optStructVal
  self.optEnumVal = optEnumVal
  self.optBinaryVal = optBinaryVal
  self.optStringVal = optStringVal
  self.optDoubleVal = optDoubleVal
  self.optFloatVal = optFloatVal
  self.optI64Val = optI64Val
  self.optI32Val = optI32Val
  self.optI16Val = optI16Val
  self.optByteVal = optByteVal
  self.optBoolVal = optBoolVal
  self.lateStructVal = lateStructVal
  self.unionVal = unionVal
  self.structVal = structVal
  self.enumVal = enumVal
  self.binaryVal = binaryVal
  self.stringVal = stringVal
  self.doubleVal = doubleVal
  self.floatVal = floatVal
  self.i64Val = i64Val
  self.i32Val = i32Val
  self.i16Val = i16Val
  self.byteVal = byteVal
  self.boolVal = boolVal

MyStructFieldPatch.__init__ = MyStructFieldPatch__init__

def MyStructFieldPatch__setstate__(self, state):
  state.setdefault('mapMap', None)
  state.setdefault('listMap', None)
  state.setdefault('optMapVal', None)
  state.setdefault('optSetVal', None)
  state.setdefault('optListVal', None)
  state.setdefault('optLateStructVal', None)
  state.setdefault('optStructVal', None)
  state.setdefault('optEnumVal', None)
  state.setdefault('optBinaryVal', None)
  state.setdefault('optStringVal', None)
  state.setdefault('optDoubleVal', None)
  state.setdefault('optFloatVal', None)
  state.setdefault('optI64Val', None)
  state.setdefault('optI32Val', None)
  state.setdefault('optI16Val', None)
  state.setdefault('optByteVal', None)
  state.setdefault('optBoolVal', None)
  state.setdefault('lateStructVal', None)
  state.setdefault('unionVal', None)
  state.setdefault('structVal', None)
  state.setdefault('enumVal', None)
  state.setdefault('binaryVal', None)
  state.setdefault('stringVal', None)
  state.setdefault('doubleVal', None)
  state.setdefault('floatVal', None)
  state.setdefault('i64Val', None)
  state.setdefault('i32Val', None)
  state.setdefault('i16Val', None)
  state.setdefault('byteVal', None)
  state.setdefault('boolVal', None)
  self.__dict__ = state

MyStructFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyStructFieldPatch.__setstate__ = MyStructFieldPatch__setstate__

all_structs.append(MyStructPatch)
MyStructPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyStruct, MyStruct.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyStructFieldPatch, MyStructFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [MyStructEnsureStruct, MyStructEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [MyStructFieldPatch, MyStructFieldPatch.thrift_spec, False], None, 3, ), # 6
)

MyStructPatch.thrift_struct_annotations = {
}
MyStructPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyStructPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

MyStructPatch.__init__ = MyStructPatch__init__

def MyStructPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

MyStructPatch.__getstate__ = lambda self: self.__dict__.copy()
MyStructPatch.__setstate__ = MyStructPatch__setstate__

all_structs.append(LateDefStructEnsureStruct)
LateDefStructEnsureStruct.thrift_spec = (
)

LateDefStructEnsureStruct.thrift_struct_annotations = {
}
LateDefStructEnsureStruct.thrift_field_annotations = {
}

all_structs.append(LateDefStructFieldPatch)
LateDefStructFieldPatch.thrift_spec = (
)

LateDefStructFieldPatch.thrift_struct_annotations = {
}
LateDefStructFieldPatch.thrift_field_annotations = {
}

all_structs.append(LateDefStructPatch)
LateDefStructPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [LateDefStructFieldPatch, LateDefStructFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [LateDefStructEnsureStruct, LateDefStructEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [LateDefStructFieldPatch, LateDefStructFieldPatch.thrift_spec, False], None, 3, ), # 6
)

LateDefStructPatch.thrift_struct_annotations = {
}
LateDefStructPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def LateDefStructPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

LateDefStructPatch.__init__ = LateDefStructPatch__init__

def LateDefStructPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

LateDefStructPatch.__getstate__ = lambda self: self.__dict__.copy()
LateDefStructPatch.__setstate__ = LateDefStructPatch__setstate__

all_structs.append(RecursiveEnsureStruct)
RecursiveEnsureStruct.thrift_spec = (
  (-1, TType.MAP, 'nodes', (TType.STRING,True,TType.STRUCT,[Recursive, Recursive.thrift_spec, False]), None, 1, ), # -1
)

RecursiveEnsureStruct.thrift_struct_annotations = {
}
RecursiveEnsureStruct.thrift_field_annotations = {
}

def RecursiveEnsureStruct__init__(self, nodes=None,):
  self.nodes = nodes

RecursiveEnsureStruct.__init__ = RecursiveEnsureStruct__init__

def RecursiveEnsureStruct__setstate__(self, state):
  state.setdefault('nodes', None)
  self.__dict__ = state

RecursiveEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
RecursiveEnsureStruct.__setstate__ = RecursiveEnsureStruct__setstate__

all_structs.append(RecursiveField1Patch)
RecursiveField1Patch.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.STRUCT,[Recursive, Recursive.thrift_spec, False]), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
)

RecursiveField1Patch.thrift_struct_annotations = {
}
RecursiveField1Patch.thrift_field_annotations = {
}

def RecursiveField1Patch__init__(self, assign=None, clear=None,):
  self.assign = assign
  self.clear = clear

RecursiveField1Patch.__init__ = RecursiveField1Patch__init__

def RecursiveField1Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  self.__dict__ = state

RecursiveField1Patch.__getstate__ = lambda self: self.__dict__.copy()
RecursiveField1Patch.__setstate__ = RecursiveField1Patch__setstate__

all_structs.append(RecursiveFieldPatch)
RecursiveFieldPatch.thrift_spec = (
  (-1, TType.STRUCT, 'nodes', [RecursiveField1Patch, RecursiveField1Patch.thrift_spec, False], None, 3, ), # -1
)

RecursiveFieldPatch.thrift_struct_annotations = {
}
RecursiveFieldPatch.thrift_field_annotations = {
}

def RecursiveFieldPatch__init__(self, nodes=None,):
  self.nodes = nodes

RecursiveFieldPatch.__init__ = RecursiveFieldPatch__init__

def RecursiveFieldPatch__setstate__(self, state):
  state.setdefault('nodes', None)
  self.__dict__ = state

RecursiveFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
RecursiveFieldPatch.__setstate__ = RecursiveFieldPatch__setstate__

all_structs.append(RecursivePatch)
RecursivePatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [Recursive, Recursive.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [RecursiveFieldPatch, RecursiveFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [RecursiveEnsureStruct, RecursiveEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [RecursiveFieldPatch, RecursiveFieldPatch.thrift_spec, False], None, 3, ), # 6
)

RecursivePatch.thrift_struct_annotations = {
}
RecursivePatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def RecursivePatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

RecursivePatch.__init__ = RecursivePatch__init__

def RecursivePatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

RecursivePatch.__getstate__ = lambda self: self.__dict__.copy()
RecursivePatch.__setstate__ = RecursivePatch__setstate__

all_structs.append(BarEnsureStruct)
BarEnsureStruct.thrift_spec = (
  (-1, TType.STRUCT, 'loop', [Loop, Loop.thrift_spec, False], None, 1, ), # -1
)

BarEnsureStruct.thrift_struct_annotations = {
}
BarEnsureStruct.thrift_field_annotations = {
  -1: {
    "thrift.box": "",
  },
}

def BarEnsureStruct__init__(self, loop=None,):
  self.loop = loop

BarEnsureStruct.__init__ = BarEnsureStruct__init__

def BarEnsureStruct__setstate__(self, state):
  state.setdefault('loop', None)
  self.__dict__ = state

BarEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
BarEnsureStruct.__setstate__ = BarEnsureStruct__setstate__

all_structs.append(BarFieldPatch)
BarFieldPatch.thrift_spec = (
  (-1, TType.STRUCT, 'loop', [LoopPatch, LoopPatch.thrift_spec, False], None, 3, ), # -1
)

BarFieldPatch.thrift_struct_annotations = {
}
BarFieldPatch.thrift_field_annotations = {
}

def BarFieldPatch__init__(self, loop=None,):
  self.loop = loop

BarFieldPatch.__init__ = BarFieldPatch__init__

def BarFieldPatch__setstate__(self, state):
  state.setdefault('loop', None)
  self.__dict__ = state

BarFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
BarFieldPatch.__setstate__ = BarFieldPatch__setstate__

all_structs.append(BarPatch)
BarPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [Bar, Bar.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [BarFieldPatch, BarFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [BarEnsureStruct, BarEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [BarFieldPatch, BarFieldPatch.thrift_spec, False], None, 3, ), # 6
)

BarPatch.thrift_struct_annotations = {
}
BarPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def BarPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

BarPatch.__init__ = BarPatch__init__

def BarPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

BarPatch.__getstate__ = lambda self: self.__dict__.copy()
BarPatch.__setstate__ = BarPatch__setstate__

all_structs.append(LoopEnsureStruct)
LoopEnsureStruct.thrift_spec = (
  (-1, TType.STRUCT, 'bar', [Bar, Bar.thrift_spec, False], None, 1, ), # -1
)

LoopEnsureStruct.thrift_struct_annotations = {
}
LoopEnsureStruct.thrift_field_annotations = {
  -1: {
    "thrift.box": "",
  },
}

def LoopEnsureStruct__init__(self, bar=None,):
  self.bar = bar

LoopEnsureStruct.__init__ = LoopEnsureStruct__init__

def LoopEnsureStruct__setstate__(self, state):
  state.setdefault('bar', None)
  self.__dict__ = state

LoopEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
LoopEnsureStruct.__setstate__ = LoopEnsureStruct__setstate__

all_structs.append(LoopFieldPatch)
LoopFieldPatch.thrift_spec = (
  (-1, TType.STRUCT, 'bar', [BarPatch, BarPatch.thrift_spec, False], None, 3, ), # -1
)

LoopFieldPatch.thrift_struct_annotations = {
}
LoopFieldPatch.thrift_field_annotations = {
}

def LoopFieldPatch__init__(self, bar=None,):
  self.bar = bar

LoopFieldPatch.__init__ = LoopFieldPatch__init__

def LoopFieldPatch__setstate__(self, state):
  state.setdefault('bar', None)
  self.__dict__ = state

LoopFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
LoopFieldPatch.__setstate__ = LoopFieldPatch__setstate__

all_structs.append(LoopPatch)
LoopPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [Loop, Loop.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
)

LoopPatch.thrift_struct_annotations = {
}
LoopPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def LoopPatch__init__(self, assign=None, clear=None,):
  self.assign = assign
  self.clear = clear

LoopPatch.__init__ = LoopPatch__init__

def LoopPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  self.__dict__ = state

LoopPatch.__getstate__ = lambda self: self.__dict__.copy()
LoopPatch.__setstate__ = LoopPatch__setstate__

fix_spec(all_structs)
del all_structs
