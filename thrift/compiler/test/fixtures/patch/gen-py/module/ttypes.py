#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.lib.thrift.patch.ttypes
import thrift.lib.thrift.standard.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'MyEnum', 'MyData', 'MyDataWithCustomDefault', 'InnerUnion', 'MyUnion', 'MyStruct', 'LateDefStruct', 'Recursive', 'Bar', 'Loop', 'MyDataPatch', 'MyDataFieldPatch', 'MyDataEnsureStruct', 'MyDataWithCustomDefaultPatch', 'MyDataWithCustomDefaultFieldPatch', 'MyDataWithCustomDefaultEnsureStruct', 'InnerUnionPatch', 'InnerUnionFieldPatch', 'MyUnionPatch', 'MyUnionFieldPatch', 'MyStructPatch', 'MyStructField10Patch', 'MyStructField23Patch', 'MyStructField26Patch', 'MyStructField27Patch', 'MyStructField28Patch', 'MyStructField29Patch', 'MyStructField29Patch1', 'MyStructField30Patch', 'MyStructField30Patch1', 'MyStructFieldPatch', 'MyStructEnsureStruct', 'LateDefStructPatch', 'LateDefStructFieldPatch', 'LateDefStructEnsureStruct', 'RecursivePatch', 'RecursiveField1Patch', 'RecursiveFieldPatch', 'RecursiveEnsureStruct', 'BarPatch', 'BarFieldPatch', 'BarEnsureStruct', 'LoopPatch']

class MyEnum:
  MyValue0 = 0

  _VALUES_TO_NAMES = {
    0: "MyValue0",
  }

  _NAMES_TO_VALUES = {
    "MyValue0": 0,
  }

class MyData:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.data2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyData')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRING, 1)
      oprot.writeString(self.data1.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data1, bytes) else oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.I32, 2)
      oprot.writeI32(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = json_obj['data1']
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = json_obj['data2']
      if self.data2 > 0x7fffffff or self.data2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyData, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyData, self)

  def _to_py_deprecated(self):
    return self

class MyDataWithCustomDefault:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.data2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataWithCustomDefault')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRING, 1)
      oprot.writeString(self.data1.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data1, bytes) else oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.I32, 2)
      oprot.writeI32(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = json_obj['data1']
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = json_obj['data2']
      if self.data2 > 0x7fffffff or self.data2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataWithCustomDefault, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataWithCustomDefault, self)

  def _to_py_deprecated(self):
    return self

class InnerUnion(object):
  r"""
  Attributes:
   - innerOption
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  INNEROPTION = 1
  
  @staticmethod
  def isUnion():
    return True

  def get_innerOption(self):
    assert self.field == 1
    return self.value

  def set_innerOption(self, value):
    self.field = 1
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('innerOption', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRING:
          _fbthrift_innerOption = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_innerOption(_fbthrift_innerOption)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('InnerUnion')
    if self.field == 1:
      oprot.writeFieldBegin('innerOption', TType.STRING, 1)
      innerOption = self.value
      oprot.writeString(innerOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'innerOption' in obj:
      _fbthrift_innerOption = obj['innerOption']
      self.set_innerOption(_fbthrift_innerOption)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.InnerUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.InnerUnion, self)

  def _to_py_deprecated(self):
    return self

class MyUnion(object):
  r"""
  Attributes:
   - option1
   - option2
   - option3
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  OPTION1 = 1
  OPTION2 = 2
  OPTION3 = 3
  
  @staticmethod
  def isUnion():
    return True

  def get_option1(self):
    assert self.field == 1
    return self.value

  def get_option2(self):
    assert self.field == 2
    return self.value

  def get_option3(self):
    assert self.field == 3
    return self.value

  def set_option1(self, value):
    self.field = 1
    self.value = value

  def set_option2(self, value):
    self.field = 2
    self.value = value

  def set_option3(self, value):
    self.field = 3
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option1', value)
    if self.field == 2:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option2', value)
    if self.field == 3:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option3', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRING:
          _fbthrift_option1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_option1(_fbthrift_option1)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          _fbthrift_option2 = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_option2(_fbthrift_option2)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          _fbthrift_option3 = InnerUnion()
          _fbthrift_option3.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_option3(_fbthrift_option3)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('MyUnion')
    if self.field == 1:
      oprot.writeFieldBegin('option1', TType.STRING, 1)
      option1 = self.value
      oprot.writeString(option1.encode('utf-8')) if UTF8STRINGS and not isinstance(option1, bytes) else oprot.writeString(option1)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('option2', TType.I32, 2)
      option2 = self.value
      oprot.writeI32(option2)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('option3', TType.STRUCT, 3)
      option3 = self.value
      option3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'option1' in obj:
      _fbthrift_option1 = obj['option1']
      self.set_option1(_fbthrift_option1)
    if 'option2' in obj:
      _fbthrift_option2 = obj['option2']
      if _fbthrift_option2 > 0x7fffffff or _fbthrift_option2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_option2(_fbthrift_option2)
    if 'option3' in obj:
      _fbthrift_option3 = InnerUnion()
      _fbthrift_option3.readFromJson(obj['option3'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
      self.set_option3(_fbthrift_option3)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnion, self)

  def _to_py_deprecated(self):
    return self

class MyStruct:
  r"""
  Attributes:
   - boolVal
   - byteVal
   - i16Val
   - i32Val
   - i64Val
   - floatVal
   - doubleVal
   - stringVal
   - binaryVal
   - enumVal
   - structVal
   - unionVal
   - lateStructVal
   - optBoolVal
   - optByteVal
   - optI16Val
   - optI32Val
   - optI64Val
   - optFloatVal
   - optDoubleVal
   - optStringVal
   - optBinaryVal
   - optEnumVal
   - optStructVal
   - optLateStructVal
   - optListVal
   - optSetVal
   - optMapVal
   - listMap
   - mapMap
   - i32WithCustomDefault
   - structWithCustomDefault
   - structWithFieldCustomDefault
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.BOOL:
          self.boolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.BYTE:
          self.byteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.I16:
          self.i16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.I32:
          self.i32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.I64:
          self.i64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -6:
        if ftype == TType.FLOAT:
          self.floatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -7:
        if ftype == TType.DOUBLE:
          self.doubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -8:
        if ftype == TType.STRING:
          self.stringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -9:
        if ftype == TType.STRING:
          self.binaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -10:
        if ftype == TType.I32:
          self.enumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -11:
        if ftype == TType.STRUCT:
          self.structVal = MyData()
          self.structVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -12:
        if ftype == TType.STRUCT:
          self.unionVal = MyUnion()
          self.unionVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -13:
        if ftype == TType.STRUCT:
          self.lateStructVal = LateDefStruct()
          self.lateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -14:
        if ftype == TType.BOOL:
          self.optBoolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == -15:
        if ftype == TType.BYTE:
          self.optByteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -16:
        if ftype == TType.I16:
          self.optI16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -17:
        if ftype == TType.I32:
          self.optI32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -18:
        if ftype == TType.I64:
          self.optI64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -19:
        if ftype == TType.FLOAT:
          self.optFloatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -20:
        if ftype == TType.DOUBLE:
          self.optDoubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -21:
        if ftype == TType.STRING:
          self.optStringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -22:
        if ftype == TType.STRING:
          self.optBinaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -23:
        if ftype == TType.I32:
          self.optEnumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -24:
        if ftype == TType.STRUCT:
          self.optStructVal = MyData()
          self.optStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -25:
        if ftype == TType.STRUCT:
          self.optLateStructVal = LateDefStruct()
          self.optLateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -26:
        if ftype == TType.LIST:
          self.optListVal = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readI16()
              self.optListVal.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readI16()
              self.optListVal.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -27:
        if ftype == TType.SET:
          self.optSetVal = set()
          (_etype10, _size7) = iprot.readSetBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem12)
          else: 
            while iprot.peekSet():
              _elem13 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem13)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == -28:
        if ftype == TType.MAP:
          self.optMapVal = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in range(_size14):
              _key19 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val20 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key21 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val22 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -29:
        if ftype == TType.LIST:
          self.listMap = []
          (_etype26, _size23) = iprot.readListBegin()
          if _size23 >= 0:
            for _i27 in range(_size23):
              _elem28 = {}
              (_ktype30, _vtype31, _size29 ) = iprot.readMapBegin() 
              if _size29 >= 0:
                for _i33 in range(_size29):
                  _key34 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val35 = iprot.readI32()
                  _elem28[_key34] = _val35
              else: 
                while iprot.peekMap():
                  _key36 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val37 = iprot.readI32()
                  _elem28[_key36] = _val37
              iprot.readMapEnd()
              self.listMap.append(_elem28)
          else: 
            while iprot.peekList():
              _elem38 = {}
              (_ktype40, _vtype41, _size39 ) = iprot.readMapBegin() 
              if _size39 >= 0:
                for _i43 in range(_size39):
                  _key44 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val45 = iprot.readI32()
                  _elem38[_key44] = _val45
              else: 
                while iprot.peekMap():
                  _key46 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val47 = iprot.readI32()
                  _elem38[_key46] = _val47
              iprot.readMapEnd()
              self.listMap.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -30:
        if ftype == TType.MAP:
          self.mapMap = {}
          (_ktype49, _vtype50, _size48 ) = iprot.readMapBegin() 
          if _size48 >= 0:
            for _i52 in range(_size48):
              _key53 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val54 = {}
              (_ktype56, _vtype57, _size55 ) = iprot.readMapBegin() 
              if _size55 >= 0:
                for _i59 in range(_size55):
                  _key60 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val61 = iprot.readI32()
                  _val54[_key60] = _val61
              else: 
                while iprot.peekMap():
                  _key62 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val63 = iprot.readI32()
                  _val54[_key62] = _val63
              iprot.readMapEnd()
              self.mapMap[_key53] = _val54
          else: 
            while iprot.peekMap():
              _key64 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val65 = {}
              (_ktype67, _vtype68, _size66 ) = iprot.readMapBegin() 
              if _size66 >= 0:
                for _i70 in range(_size66):
                  _key71 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val72 = iprot.readI32()
                  _val65[_key71] = _val72
              else: 
                while iprot.peekMap():
                  _key73 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val74 = iprot.readI32()
                  _val65[_key73] = _val74
              iprot.readMapEnd()
              self.mapMap[_key64] = _val65
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -31:
        if ftype == TType.I32:
          self.i32WithCustomDefault = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -32:
        if ftype == TType.STRUCT:
          self.structWithCustomDefault = MyDataWithCustomDefault()
          self.structWithCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.structWithFieldCustomDefault = MyData()
          self.structWithFieldCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    if self.structWithCustomDefault != None:
      oprot.writeFieldBegin('structWithCustomDefault', TType.STRUCT, -32)
      self.structWithCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    if self.i32WithCustomDefault != None:
      oprot.writeFieldBegin('i32WithCustomDefault', TType.I32, -31)
      oprot.writeI32(self.i32WithCustomDefault)
      oprot.writeFieldEnd()
    if self.mapMap != None:
      oprot.writeFieldBegin('mapMap', TType.MAP, -30)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.mapMap))
      for kiter75,viter76 in self.mapMap.items():
        oprot.writeString(kiter75.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter75, bytes) else oprot.writeString(kiter75)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter76))
        for kiter77,viter78 in viter76.items():
          oprot.writeString(kiter77.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter77, bytes) else oprot.writeString(kiter77)
          oprot.writeI32(viter78)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.listMap != None:
      oprot.writeFieldBegin('listMap', TType.LIST, -29)
      oprot.writeListBegin(TType.MAP, len(self.listMap))
      for iter79 in self.listMap:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter79))
        for kiter80,viter81 in iter79.items():
          oprot.writeString(kiter80.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter80, bytes) else oprot.writeString(kiter80)
          oprot.writeI32(viter81)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optMapVal != None:
      oprot.writeFieldBegin('optMapVal', TType.MAP, -28)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.optMapVal))
      for kiter82,viter83 in self.optMapVal.items():
        oprot.writeString(kiter82.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter82, bytes) else oprot.writeString(kiter82)
        oprot.writeString(viter83.encode('utf-8')) if UTF8STRINGS and not isinstance(viter83, bytes) else oprot.writeString(viter83)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.optSetVal != None:
      oprot.writeFieldBegin('optSetVal', TType.SET, -27)
      oprot.writeSetBegin(TType.STRING, len(self.optSetVal))
      for iter84 in self.optSetVal:
        oprot.writeString(iter84.encode('utf-8')) if UTF8STRINGS and not isinstance(iter84, bytes) else oprot.writeString(iter84)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.optListVal != None:
      oprot.writeFieldBegin('optListVal', TType.LIST, -26)
      oprot.writeListBegin(TType.I16, len(self.optListVal))
      for iter85 in self.optListVal:
        oprot.writeI16(iter85)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optLateStructVal != None:
      oprot.writeFieldBegin('optLateStructVal', TType.STRUCT, -25)
      self.optLateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStructVal != None:
      oprot.writeFieldBegin('optStructVal', TType.STRUCT, -24)
      self.optStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optEnumVal != None:
      oprot.writeFieldBegin('optEnumVal', TType.I32, -23)
      oprot.writeI32(self.optEnumVal)
      oprot.writeFieldEnd()
    if self.optBinaryVal != None:
      oprot.writeFieldBegin('optBinaryVal', TType.STRING, -22)
      oprot.writeString(self.optBinaryVal)
      oprot.writeFieldEnd()
    if self.optStringVal != None:
      oprot.writeFieldBegin('optStringVal', TType.STRING, -21)
      oprot.writeString(self.optStringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.optStringVal, bytes) else oprot.writeString(self.optStringVal)
      oprot.writeFieldEnd()
    if self.optDoubleVal != None:
      oprot.writeFieldBegin('optDoubleVal', TType.DOUBLE, -20)
      oprot.writeDouble(self.optDoubleVal)
      oprot.writeFieldEnd()
    if self.optFloatVal != None:
      oprot.writeFieldBegin('optFloatVal', TType.FLOAT, -19)
      oprot.writeFloat(self.optFloatVal)
      oprot.writeFieldEnd()
    if self.optI64Val != None:
      oprot.writeFieldBegin('optI64Val', TType.I64, -18)
      oprot.writeI64(self.optI64Val)
      oprot.writeFieldEnd()
    if self.optI32Val != None:
      oprot.writeFieldBegin('optI32Val', TType.I32, -17)
      oprot.writeI32(self.optI32Val)
      oprot.writeFieldEnd()
    if self.optI16Val != None:
      oprot.writeFieldBegin('optI16Val', TType.I16, -16)
      oprot.writeI16(self.optI16Val)
      oprot.writeFieldEnd()
    if self.optByteVal != None:
      oprot.writeFieldBegin('optByteVal', TType.BYTE, -15)
      oprot.writeByte(self.optByteVal)
      oprot.writeFieldEnd()
    if self.optBoolVal != None:
      oprot.writeFieldBegin('optBoolVal', TType.BOOL, -14)
      oprot.writeBool(self.optBoolVal)
      oprot.writeFieldEnd()
    if self.lateStructVal != None:
      oprot.writeFieldBegin('lateStructVal', TType.STRUCT, -13)
      self.lateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.unionVal != None:
      oprot.writeFieldBegin('unionVal', TType.STRUCT, -12)
      self.unionVal.write(oprot)
      oprot.writeFieldEnd()
    if self.structVal != None:
      oprot.writeFieldBegin('structVal', TType.STRUCT, -11)
      self.structVal.write(oprot)
      oprot.writeFieldEnd()
    if self.enumVal != None:
      oprot.writeFieldBegin('enumVal', TType.I32, -10)
      oprot.writeI32(self.enumVal)
      oprot.writeFieldEnd()
    if self.binaryVal != None:
      oprot.writeFieldBegin('binaryVal', TType.STRING, -9)
      oprot.writeString(self.binaryVal)
      oprot.writeFieldEnd()
    if self.stringVal != None:
      oprot.writeFieldBegin('stringVal', TType.STRING, -8)
      oprot.writeString(self.stringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.stringVal, bytes) else oprot.writeString(self.stringVal)
      oprot.writeFieldEnd()
    if self.doubleVal != None:
      oprot.writeFieldBegin('doubleVal', TType.DOUBLE, -7)
      oprot.writeDouble(self.doubleVal)
      oprot.writeFieldEnd()
    if self.floatVal != None:
      oprot.writeFieldBegin('floatVal', TType.FLOAT, -6)
      oprot.writeFloat(self.floatVal)
      oprot.writeFieldEnd()
    if self.i64Val != None:
      oprot.writeFieldBegin('i64Val', TType.I64, -5)
      oprot.writeI64(self.i64Val)
      oprot.writeFieldEnd()
    if self.i32Val != None:
      oprot.writeFieldBegin('i32Val', TType.I32, -4)
      oprot.writeI32(self.i32Val)
      oprot.writeFieldEnd()
    if self.i16Val != None:
      oprot.writeFieldBegin('i16Val', TType.I16, -3)
      oprot.writeI16(self.i16Val)
      oprot.writeFieldEnd()
    if self.byteVal != None:
      oprot.writeFieldBegin('byteVal', TType.BYTE, -2)
      oprot.writeByte(self.byteVal)
      oprot.writeFieldEnd()
    if self.boolVal != None:
      oprot.writeFieldBegin('boolVal', TType.BOOL, -1)
      oprot.writeBool(self.boolVal)
      oprot.writeFieldEnd()
    if self.structWithFieldCustomDefault != None:
      oprot.writeFieldBegin('structWithFieldCustomDefault', TType.STRUCT, 1)
      self.structWithFieldCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'boolVal' in json_obj and json_obj['boolVal'] is not None:
      self.boolVal = json_obj['boolVal']
    if 'byteVal' in json_obj and json_obj['byteVal'] is not None:
      self.byteVal = json_obj['byteVal']
      if self.byteVal > 0x7f or self.byteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i16Val' in json_obj and json_obj['i16Val'] is not None:
      self.i16Val = json_obj['i16Val']
      if self.i16Val > 0x7fff or self.i16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i32Val' in json_obj and json_obj['i32Val'] is not None:
      self.i32Val = json_obj['i32Val']
      if self.i32Val > 0x7fffffff or self.i32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i64Val' in json_obj and json_obj['i64Val'] is not None:
      self.i64Val = long(json_obj['i64Val'])
    if 'floatVal' in json_obj and json_obj['floatVal'] is not None:
      self.floatVal = float(json_obj['floatVal'])
    if 'doubleVal' in json_obj and json_obj['doubleVal'] is not None:
      self.doubleVal = float(json_obj['doubleVal'])
    if 'stringVal' in json_obj and json_obj['stringVal'] is not None:
      self.stringVal = json_obj['stringVal']
    if 'binaryVal' in json_obj and json_obj['binaryVal'] is not None:
      self.binaryVal = json_obj['binaryVal']
    if 'enumVal' in json_obj and json_obj['enumVal'] is not None:
      self.enumVal = json_obj['enumVal']
      if not self.enumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'structVal' in json_obj and json_obj['structVal'] is not None:
      self.structVal = MyData()
      self.structVal.readFromJson(json_obj['structVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'unionVal' in json_obj and json_obj['unionVal'] is not None:
      self.unionVal = MyUnion()
      self.unionVal.readFromJson(json_obj['unionVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'lateStructVal' in json_obj and json_obj['lateStructVal'] is not None:
      self.lateStructVal = LateDefStruct()
      self.lateStructVal.readFromJson(json_obj['lateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optBoolVal' in json_obj and json_obj['optBoolVal'] is not None:
      self.optBoolVal = json_obj['optBoolVal']
    if 'optByteVal' in json_obj and json_obj['optByteVal'] is not None:
      self.optByteVal = json_obj['optByteVal']
      if self.optByteVal > 0x7f or self.optByteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI16Val' in json_obj and json_obj['optI16Val'] is not None:
      self.optI16Val = json_obj['optI16Val']
      if self.optI16Val > 0x7fff or self.optI16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI32Val' in json_obj and json_obj['optI32Val'] is not None:
      self.optI32Val = json_obj['optI32Val']
      if self.optI32Val > 0x7fffffff or self.optI32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI64Val' in json_obj and json_obj['optI64Val'] is not None:
      self.optI64Val = long(json_obj['optI64Val'])
    if 'optFloatVal' in json_obj and json_obj['optFloatVal'] is not None:
      self.optFloatVal = float(json_obj['optFloatVal'])
    if 'optDoubleVal' in json_obj and json_obj['optDoubleVal'] is not None:
      self.optDoubleVal = float(json_obj['optDoubleVal'])
    if 'optStringVal' in json_obj and json_obj['optStringVal'] is not None:
      self.optStringVal = json_obj['optStringVal']
    if 'optBinaryVal' in json_obj and json_obj['optBinaryVal'] is not None:
      self.optBinaryVal = json_obj['optBinaryVal']
    if 'optEnumVal' in json_obj and json_obj['optEnumVal'] is not None:
      self.optEnumVal = json_obj['optEnumVal']
      if not self.optEnumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.optEnumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'optStructVal' in json_obj and json_obj['optStructVal'] is not None:
      self.optStructVal = MyData()
      self.optStructVal.readFromJson(json_obj['optStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optLateStructVal' in json_obj and json_obj['optLateStructVal'] is not None:
      self.optLateStructVal = LateDefStruct()
      self.optLateStructVal.readFromJson(json_obj['optLateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optListVal' in json_obj and json_obj['optListVal'] is not None:
      self.optListVal = []
      for _tmp_e86 in json_obj['optListVal']:
        if _tmp_e86 > 0x7fff or _tmp_e86 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.optListVal.append(_tmp_e86)
    if 'optSetVal' in json_obj and json_obj['optSetVal'] is not None:
      self.optSetVal = set_cls()
      for _tmp_e87 in json_obj['optSetVal']:
        self.optSetVal.add(_tmp_e87)
    if 'optMapVal' in json_obj and json_obj['optMapVal'] is not None:
      self.optMapVal = dict_cls()
      for _tmp_k88, _tmp_v89 in json_obj['optMapVal'].items():
        _tmp_kp90 = _tmp_k88
        self.optMapVal[_tmp_kp90] = _tmp_v89
    if 'listMap' in json_obj and json_obj['listMap'] is not None:
      self.listMap = []
      for _tmp_e91 in json_obj['listMap']:
        _map92 = dict_cls()
        for _tmp_k93, _tmp_v94 in _tmp_e91.items():
          _tmp_kp95 = _tmp_k93
          if _tmp_v94 > 0x7fffffff or _tmp_v94 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map92[_tmp_kp95] = _tmp_v94
        self.listMap.append(_map92)
    if 'mapMap' in json_obj and json_obj['mapMap'] is not None:
      self.mapMap = dict_cls()
      for _tmp_k96, _tmp_v97 in json_obj['mapMap'].items():
        _tmp_kp98 = _tmp_k96
        _map99 = dict_cls()
        for _tmp_k100, _tmp_v101 in _tmp_v97.items():
          _tmp_kp102 = _tmp_k100
          if _tmp_v101 > 0x7fffffff or _tmp_v101 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map99[_tmp_kp102] = _tmp_v101
        self.mapMap[_tmp_kp98] = _map99
    if 'i32WithCustomDefault' in json_obj and json_obj['i32WithCustomDefault'] is not None:
      self.i32WithCustomDefault = json_obj['i32WithCustomDefault']
      if self.i32WithCustomDefault > 0x7fffffff or self.i32WithCustomDefault < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'structWithCustomDefault' in json_obj and json_obj['structWithCustomDefault'] is not None:
      self.structWithCustomDefault = MyDataWithCustomDefault()
      self.structWithCustomDefault.readFromJson(json_obj['structWithCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structWithFieldCustomDefault' in json_obj and json_obj['structWithFieldCustomDefault'] is not None:
      self.structWithFieldCustomDefault = MyData()
      self.structWithFieldCustomDefault.readFromJson(json_obj['structWithFieldCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.boolVal is not None:
      value = pprint.pformat(self.boolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    boolVal=%s' % (value))
    if self.byteVal is not None:
      value = pprint.pformat(self.byteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byteVal=%s' % (value))
    if self.i16Val is not None:
      value = pprint.pformat(self.i16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i16Val=%s' % (value))
    if self.i32Val is not None:
      value = pprint.pformat(self.i32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32Val=%s' % (value))
    if self.i64Val is not None:
      value = pprint.pformat(self.i64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i64Val=%s' % (value))
    if self.floatVal is not None:
      value = pprint.pformat(self.floatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    floatVal=%s' % (value))
    if self.doubleVal is not None:
      value = pprint.pformat(self.doubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleVal=%s' % (value))
    if self.stringVal is not None:
      value = pprint.pformat(self.stringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stringVal=%s' % (value))
    if self.binaryVal is not None:
      value = pprint.pformat(self.binaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryVal=%s' % (value))
    if self.enumVal is not None:
      value = pprint.pformat(self.enumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enumVal=%s' % (value))
    if self.structVal is not None:
      value = pprint.pformat(self.structVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structVal=%s' % (value))
    if self.unionVal is not None:
      value = pprint.pformat(self.unionVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionVal=%s' % (value))
    if self.lateStructVal is not None:
      value = pprint.pformat(self.lateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lateStructVal=%s' % (value))
    if self.optBoolVal is not None:
      value = pprint.pformat(self.optBoolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBoolVal=%s' % (value))
    if self.optByteVal is not None:
      value = pprint.pformat(self.optByteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optByteVal=%s' % (value))
    if self.optI16Val is not None:
      value = pprint.pformat(self.optI16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI16Val=%s' % (value))
    if self.optI32Val is not None:
      value = pprint.pformat(self.optI32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI32Val=%s' % (value))
    if self.optI64Val is not None:
      value = pprint.pformat(self.optI64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI64Val=%s' % (value))
    if self.optFloatVal is not None:
      value = pprint.pformat(self.optFloatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optFloatVal=%s' % (value))
    if self.optDoubleVal is not None:
      value = pprint.pformat(self.optDoubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optDoubleVal=%s' % (value))
    if self.optStringVal is not None:
      value = pprint.pformat(self.optStringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStringVal=%s' % (value))
    if self.optBinaryVal is not None:
      value = pprint.pformat(self.optBinaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBinaryVal=%s' % (value))
    if self.optEnumVal is not None:
      value = pprint.pformat(self.optEnumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optEnumVal=%s' % (value))
    if self.optStructVal is not None:
      value = pprint.pformat(self.optStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStructVal=%s' % (value))
    if self.optLateStructVal is not None:
      value = pprint.pformat(self.optLateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optLateStructVal=%s' % (value))
    if self.optListVal is not None:
      value = pprint.pformat(self.optListVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optListVal=%s' % (value))
    if self.optSetVal is not None:
      value = pprint.pformat(self.optSetVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optSetVal=%s' % (value))
    if self.optMapVal is not None:
      value = pprint.pformat(self.optMapVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optMapVal=%s' % (value))
    if self.listMap is not None:
      value = pprint.pformat(self.listMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    listMap=%s' % (value))
    if self.mapMap is not None:
      value = pprint.pformat(self.mapMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapMap=%s' % (value))
    if self.i32WithCustomDefault is not None:
      value = pprint.pformat(self.i32WithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32WithCustomDefault=%s' % (value))
    if self.structWithCustomDefault is not None:
      value = pprint.pformat(self.structWithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithCustomDefault=%s' % (value))
    if self.structWithFieldCustomDefault is not None:
      value = pprint.pformat(self.structWithFieldCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithFieldCustomDefault=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'structWithCustomDefault',
      'i32WithCustomDefault',
      'mapMap',
      'listMap',
      'optMapVal',
      'optSetVal',
      'optListVal',
      'optLateStructVal',
      'optStructVal',
      'optEnumVal',
      'optBinaryVal',
      'optStringVal',
      'optDoubleVal',
      'optFloatVal',
      'optI64Val',
      'optI32Val',
      'optI16Val',
      'optByteVal',
      'optBoolVal',
      'lateStructVal',
      'unionVal',
      'structVal',
      'enumVal',
      'binaryVal',
      'stringVal',
      'doubleVal',
      'floatVal',
      'i64Val',
      'i32Val',
      'i16Val',
      'byteVal',
      'boolVal',
      'structWithFieldCustomDefault',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

class LateDefStruct:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LateDefStruct')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LateDefStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LateDefStruct, self)

  def _to_py_deprecated(self):
    return self

class Recursive:
  r"""
  Attributes:
   - nodes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.MAP:
          self.nodes = {}
          (_ktype104, _vtype105, _size103 ) = iprot.readMapBegin() 
          if _size103 >= 0:
            for _i107 in range(_size103):
              _key108 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val109 = Recursive()
              _val109.read(iprot)
              self.nodes[_key108] = _val109
          else: 
            while iprot.peekMap():
              _key110 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val111 = Recursive()
              _val111.read(iprot)
              self.nodes[_key110] = _val111
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Recursive')
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.MAP, -1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.nodes))
      for kiter112,viter113 in self.nodes.items():
        oprot.writeString(kiter112.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter112, bytes) else oprot.writeString(kiter112)
        viter113.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'nodes' in json_obj and json_obj['nodes'] is not None:
      self.nodes = dict_cls()
      for _tmp_k114, _tmp_v115 in json_obj['nodes'].items():
        _tmp_kp116 = _tmp_k114
        _struct117 = Recursive()
        _struct117.readFromJson(_tmp_v115, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.nodes[_tmp_kp116] = _struct117

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.nodes is not None:
      value = pprint.pformat(self.nodes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nodes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'nodes',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Recursive, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Recursive, self)

  def _to_py_deprecated(self):
    return self

class Bar:
  r"""
  Attributes:
   - loop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.loop = Loop()
          self.loop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Bar')
    if self.loop != None:
      oprot.writeFieldBegin('loop', TType.STRUCT, -1)
      self.loop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'loop' in json_obj and json_obj['loop'] is not None:
      self.loop = Loop()
      self.loop.readFromJson(json_obj['loop'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.loop is not None:
      value = pprint.pformat(self.loop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    loop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'loop',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Bar, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Bar, self)

  def _to_py_deprecated(self):
    return self

class Loop:
  r"""
  Attributes:
   - bar
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.bar = Bar()
          self.bar.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Loop')
    if self.bar != None:
      oprot.writeFieldBegin('bar', TType.STRUCT, -1)
      self.bar.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'bar' in json_obj and json_obj['bar'] is not None:
      self.bar = Bar()
      self.bar.readFromJson(json_obj['bar'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.bar is not None:
      value = pprint.pformat(self.bar, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bar=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'bar',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Loop, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Loop, self)

  def _to_py_deprecated(self):
    return self

class MyDataPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyData()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyDataFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = MyDataEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyDataFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype121, _size118) = iprot.readSetBegin()
          if _size118 >= 0:
            for _i122 in range(_size118):
              _elem123 = iprot.readI16()
              self.remove.add(_elem123)
          else: 
            while iprot.peekSet():
              _elem124 = iprot.readI16()
              self.remove.add(_elem124)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.I16, len(self.remove))
      for iter125 in self.remove:
        oprot.writeI16(iter125)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyData()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyDataFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyDataEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyDataFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e126 in json_obj['remove']:
        if _tmp_e126 > 0x7fff or _tmp_e126 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.remove.add(_tmp_e126)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
      'remove',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataPatch, self)

  def _to_py_deprecated(self):
    return self

class MyDataFieldPatch:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.data1 = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.data1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data2 = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.data2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataFieldPatch')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRUCT, 1)
      self.data1.write(oprot)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.STRUCT, 2)
      self.data2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.data1.readFromJson(json_obj['data1'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.data2.readFromJson(json_obj['data2'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyDataEnsureStruct:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.data2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataEnsureStruct')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRING, 1)
      oprot.writeString(self.data1.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data1, bytes) else oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.I32, 2)
      oprot.writeI32(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = json_obj['data1']
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = json_obj['data2']
      if self.data2 > 0x7fffffff or self.data2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class MyDataWithCustomDefaultPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyDataWithCustomDefault()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyDataWithCustomDefaultFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = MyDataWithCustomDefaultEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyDataWithCustomDefaultFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype130, _size127) = iprot.readSetBegin()
          if _size127 >= 0:
            for _i131 in range(_size127):
              _elem132 = iprot.readI16()
              self.remove.add(_elem132)
          else: 
            while iprot.peekSet():
              _elem133 = iprot.readI16()
              self.remove.add(_elem133)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataWithCustomDefaultPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.I16, len(self.remove))
      for iter134 in self.remove:
        oprot.writeI16(iter134)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyDataWithCustomDefault()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyDataWithCustomDefaultFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyDataWithCustomDefaultEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyDataWithCustomDefaultFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e135 in json_obj['remove']:
        if _tmp_e135 > 0x7fff or _tmp_e135 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.remove.add(_tmp_e135)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
      'remove',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataWithCustomDefaultPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataWithCustomDefaultPatch, self)

  def _to_py_deprecated(self):
    return self

class MyDataWithCustomDefaultFieldPatch:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.data1 = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.data1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data2 = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.data2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataWithCustomDefaultFieldPatch')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRUCT, 1)
      self.data1.write(oprot)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.STRUCT, 2)
      self.data2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.data1.readFromJson(json_obj['data1'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.data2.readFromJson(json_obj['data2'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataWithCustomDefaultFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataWithCustomDefaultFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyDataWithCustomDefaultEnsureStruct:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.data2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataWithCustomDefaultEnsureStruct')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRING, 1)
      oprot.writeString(self.data1.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data1, bytes) else oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.I32, 2)
      oprot.writeI32(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = json_obj['data1']
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = json_obj['data2']
      if self.data2 > 0x7fffffff or self.data2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataWithCustomDefaultEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataWithCustomDefaultEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class InnerUnionPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = InnerUnion()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = InnerUnionFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ensure = InnerUnion()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = InnerUnionFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InnerUnionPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 4)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = InnerUnion()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = InnerUnionFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = InnerUnion()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = InnerUnionFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.InnerUnionPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.InnerUnionPatch, self)

  def _to_py_deprecated(self):
    return self

class InnerUnionFieldPatch:
  r"""
  Attributes:
   - innerOption
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.innerOption = thrift.lib.thrift.patch.ttypes.BinaryPatch()
          self.innerOption.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InnerUnionFieldPatch')
    if self.innerOption != None:
      oprot.writeFieldBegin('innerOption', TType.STRUCT, 1)
      self.innerOption.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'innerOption' in json_obj and json_obj['innerOption'] is not None:
      self.innerOption = thrift.lib.thrift.patch.ttypes.BinaryPatch()
      self.innerOption.readFromJson(json_obj['innerOption'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.innerOption is not None:
      value = pprint.pformat(self.innerOption, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    innerOption=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'innerOption',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.InnerUnionFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.InnerUnionFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyUnionPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyUnion()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyUnionFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ensure = MyUnion()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyUnionFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyUnionPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 4)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyUnion()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyUnionFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyUnion()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyUnionFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnionPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnionPatch, self)

  def _to_py_deprecated(self):
    return self

class MyUnionFieldPatch:
  r"""
  Attributes:
   - option1
   - option2
   - option3
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.option1 = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.option1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.option2 = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.option2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.option3 = InnerUnionPatch()
          self.option3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyUnionFieldPatch')
    if self.option1 != None:
      oprot.writeFieldBegin('option1', TType.STRUCT, 1)
      self.option1.write(oprot)
      oprot.writeFieldEnd()
    if self.option2 != None:
      oprot.writeFieldBegin('option2', TType.STRUCT, 2)
      self.option2.write(oprot)
      oprot.writeFieldEnd()
    if self.option3 != None:
      oprot.writeFieldBegin('option3', TType.STRUCT, 3)
      self.option3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'option1' in json_obj and json_obj['option1'] is not None:
      self.option1 = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.option1.readFromJson(json_obj['option1'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'option2' in json_obj and json_obj['option2'] is not None:
      self.option2 = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.option2.readFromJson(json_obj['option2'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'option3' in json_obj and json_obj['option3'] is not None:
      self.option3 = InnerUnionPatch()
      self.option3.readFromJson(json_obj['option3'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.option1 is not None:
      value = pprint.pformat(self.option1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    option1=%s' % (value))
    if self.option2 is not None:
      value = pprint.pformat(self.option2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    option2=%s' % (value))
    if self.option3 is not None:
      value = pprint.pformat(self.option3, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    option3=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'option1',
      'option2',
      'option3',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnionFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnionFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyStructPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyStruct()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyStructFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = MyStructEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyStructFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype139, _size136) = iprot.readSetBegin()
          if _size136 >= 0:
            for _i140 in range(_size136):
              _elem141 = iprot.readI16()
              self.remove.add(_elem141)
          else: 
            while iprot.peekSet():
              _elem142 = iprot.readI16()
              self.remove.add(_elem142)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.I16, len(self.remove))
      for iter143 in self.remove:
        oprot.writeI16(iter143)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyStruct()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyStructFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyStructEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyStructFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e144 in json_obj['remove']:
        if _tmp_e144 > 0x7fff or _tmp_e144 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.remove.add(_tmp_e144)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
      'remove',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructPatch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField10Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.assign = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField10Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I32, 1)
      oprot.writeI32(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if not self.assign in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.assign
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField10Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField10Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField23Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.assign = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField23Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I32, 1)
      oprot.writeI32(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if not self.assign in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.assign
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField23Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField23Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField26Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patch: Patches list values by index. Applies second.
   - prepend: Prepends to the front of a given list.
   - append: Appends to the back of a given list.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.assign = []
          (_etype148, _size145) = iprot.readListBegin()
          if _size145 >= 0:
            for _i149 in range(_size145):
              _elem150 = iprot.readI16()
              self.assign.append(_elem150)
          else: 
            while iprot.peekList():
              _elem151 = iprot.readI16()
              self.assign.append(_elem151)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype153, _vtype154, _size152 ) = iprot.readMapBegin() 
          if _size152 >= 0:
            for _i156 in range(_size152):
              _key157 = iprot.readI32()
              _val158 = thrift.lib.thrift.patch.ttypes.I16Patch()
              _val158.read(iprot)
              self.patch[_key157] = _val158
          else: 
            while iprot.peekMap():
              _key159 = iprot.readI32()
              _val160 = thrift.lib.thrift.patch.ttypes.I16Patch()
              _val160.read(iprot)
              self.patch[_key159] = _val160
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.prepend = []
          (_etype164, _size161) = iprot.readListBegin()
          if _size161 >= 0:
            for _i165 in range(_size161):
              _elem166 = iprot.readI16()
              self.prepend.append(_elem166)
          else: 
            while iprot.peekList():
              _elem167 = iprot.readI16()
              self.prepend.append(_elem167)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.append = []
          (_etype171, _size168) = iprot.readListBegin()
          if _size168 >= 0:
            for _i172 in range(_size168):
              _elem173 = iprot.readI16()
              self.append.append(_elem173)
          else: 
            while iprot.peekList():
              _elem174 = iprot.readI16()
              self.append.append(_elem174)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField26Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.LIST, 1)
      oprot.writeListBegin(TType.I16, len(self.assign))
      for iter175 in self.assign:
        oprot.writeI16(iter175)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.patch))
      for kiter176,viter177 in self.patch.items():
        oprot.writeI32(kiter176)
        viter177.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.prepend != None:
      oprot.writeFieldBegin('prepend', TType.LIST, 8)
      oprot.writeListBegin(TType.I16, len(self.prepend))
      for iter178 in self.prepend:
        oprot.writeI16(iter178)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.append != None:
      oprot.writeFieldBegin('append', TType.LIST, 9)
      oprot.writeListBegin(TType.I16, len(self.append))
      for iter179 in self.append:
        oprot.writeI16(iter179)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = []
      for _tmp_e180 in json_obj['assign']:
        if _tmp_e180 > 0x7fff or _tmp_e180 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.assign.append(_tmp_e180)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k181, _tmp_v182 in json_obj['patch'].items():
        _tmp_kp183 = int(_tmp_k181)
        if _tmp_kp183 > 0x7fffffff or _tmp_kp183 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k181)
        _struct184 = thrift.lib.thrift.patch.ttypes.I16Patch()
        _struct184.readFromJson(_tmp_v182, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp183] = _struct184
    if 'prepend' in json_obj and json_obj['prepend'] is not None:
      self.prepend = []
      for _tmp_e185 in json_obj['prepend']:
        if _tmp_e185 > 0x7fff or _tmp_e185 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.prepend.append(_tmp_e185)
    if 'append' in json_obj and json_obj['append'] is not None:
      self.append = []
      for _tmp_e186 in json_obj['append']:
        if _tmp_e186 > 0x7fff or _tmp_e186 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.append.append(_tmp_e186)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.prepend is not None:
      value = pprint.pformat(self.prepend, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prepend=%s' % (value))
    if self.append is not None:
      value = pprint.pformat(self.append, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    append=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patch',
      'prepend',
      'append',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField26Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField26Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField27Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - remove: Removes entries, if present. Applies third.
   - add: Adds entries, if not already present. Applies fourth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.assign = set()
          (_etype190, _size187) = iprot.readSetBegin()
          if _size187 >= 0:
            for _i191 in range(_size187):
              _elem192 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign.add(_elem192)
          else: 
            while iprot.peekSet():
              _elem193 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign.add(_elem193)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype197, _size194) = iprot.readSetBegin()
          if _size194 >= 0:
            for _i198 in range(_size194):
              _elem199 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem199)
          else: 
            while iprot.peekSet():
              _elem200 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem200)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.SET:
          self.add = set()
          (_etype204, _size201) = iprot.readSetBegin()
          if _size201 >= 0:
            for _i205 in range(_size201):
              _elem206 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add.add(_elem206)
          else: 
            while iprot.peekSet():
              _elem207 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add.add(_elem207)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField27Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.assign))
      for iter208 in self.assign:
        oprot.writeString(iter208.encode('utf-8')) if UTF8STRINGS and not isinstance(iter208, bytes) else oprot.writeString(iter208)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter209 in self.remove:
        oprot.writeString(iter209.encode('utf-8')) if UTF8STRINGS and not isinstance(iter209, bytes) else oprot.writeString(iter209)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.SET, 8)
      oprot.writeSetBegin(TType.STRING, len(self.add))
      for iter210 in self.add:
        oprot.writeString(iter210.encode('utf-8')) if UTF8STRINGS and not isinstance(iter210, bytes) else oprot.writeString(iter210)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = set_cls()
      for _tmp_e211 in json_obj['assign']:
        self.assign.add(_tmp_e211)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e212 in json_obj['remove']:
        self.remove.add(_tmp_e212)
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = set_cls()
      for _tmp_e213 in json_obj['add']:
        self.add.add(_tmp_e213)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'remove',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField27Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField27Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField28Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - add: Add the given values, if the keys are not already present. Applies forth.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
   - put: Adds or replaces the given key/value pairs. Applies fifth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype215, _vtype216, _size214 ) = iprot.readMapBegin() 
          if _size214 >= 0:
            for _i218 in range(_size214):
              _key219 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val220 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign[_key219] = _val220
          else: 
            while iprot.peekMap():
              _key221 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val222 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign[_key221] = _val222
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patchPrior = {}
          (_ktype224, _vtype225, _size223 ) = iprot.readMapBegin() 
          if _size223 >= 0:
            for _i227 in range(_size223):
              _key228 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val229 = thrift.lib.thrift.patch.ttypes.StringPatch()
              _val229.read(iprot)
              self.patchPrior[_key228] = _val229
          else: 
            while iprot.peekMap():
              _key230 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val231 = thrift.lib.thrift.patch.ttypes.StringPatch()
              _val231.read(iprot)
              self.patchPrior[_key230] = _val231
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.add = {}
          (_ktype233, _vtype234, _size232 ) = iprot.readMapBegin() 
          if _size232 >= 0:
            for _i236 in range(_size232):
              _key237 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val238 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add[_key237] = _val238
          else: 
            while iprot.peekMap():
              _key239 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val240 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add[_key239] = _val240
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype242, _vtype243, _size241 ) = iprot.readMapBegin() 
          if _size241 >= 0:
            for _i245 in range(_size241):
              _key246 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val247 = thrift.lib.thrift.patch.ttypes.StringPatch()
              _val247.read(iprot)
              self.patch[_key246] = _val247
          else: 
            while iprot.peekMap():
              _key248 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val249 = thrift.lib.thrift.patch.ttypes.StringPatch()
              _val249.read(iprot)
              self.patch[_key248] = _val249
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype253, _size250) = iprot.readSetBegin()
          if _size250 >= 0:
            for _i254 in range(_size250):
              _elem255 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem255)
          else: 
            while iprot.peekSet():
              _elem256 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem256)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.put = {}
          (_ktype258, _vtype259, _size257 ) = iprot.readMapBegin() 
          if _size257 >= 0:
            for _i261 in range(_size257):
              _key262 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val263 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.put[_key262] = _val263
          else: 
            while iprot.peekMap():
              _key264 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val265 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.put[_key264] = _val265
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField28Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.assign))
      for kiter266,viter267 in self.assign.items():
        oprot.writeString(kiter266.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter266, bytes) else oprot.writeString(kiter266)
        oprot.writeString(viter267.encode('utf-8')) if UTF8STRINGS and not isinstance(viter267, bytes) else oprot.writeString(viter267)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patchPrior))
      for kiter268,viter269 in self.patchPrior.items():
        oprot.writeString(kiter268.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter268, bytes) else oprot.writeString(kiter268)
        viter269.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.add))
      for kiter270,viter271 in self.add.items():
        oprot.writeString(kiter270.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter270, bytes) else oprot.writeString(kiter270)
        oprot.writeString(viter271.encode('utf-8')) if UTF8STRINGS and not isinstance(viter271, bytes) else oprot.writeString(viter271)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patch))
      for kiter272,viter273 in self.patch.items():
        oprot.writeString(kiter272.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter272, bytes) else oprot.writeString(kiter272)
        viter273.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter274 in self.remove:
        oprot.writeString(iter274.encode('utf-8')) if UTF8STRINGS and not isinstance(iter274, bytes) else oprot.writeString(iter274)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.put != None:
      oprot.writeFieldBegin('put', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.put))
      for kiter275,viter276 in self.put.items():
        oprot.writeString(kiter275.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter275, bytes) else oprot.writeString(kiter275)
        oprot.writeString(viter276.encode('utf-8')) if UTF8STRINGS and not isinstance(viter276, bytes) else oprot.writeString(viter276)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k277, _tmp_v278 in json_obj['assign'].items():
        _tmp_kp279 = _tmp_k277
        self.assign[_tmp_kp279] = _tmp_v278
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = dict_cls()
      for _tmp_k280, _tmp_v281 in json_obj['patchPrior'].items():
        _tmp_kp282 = _tmp_k280
        _struct283 = thrift.lib.thrift.patch.ttypes.StringPatch()
        _struct283.readFromJson(_tmp_v281, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patchPrior[_tmp_kp282] = _struct283
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = dict_cls()
      for _tmp_k284, _tmp_v285 in json_obj['add'].items():
        _tmp_kp286 = _tmp_k284
        self.add[_tmp_kp286] = _tmp_v285
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k287, _tmp_v288 in json_obj['patch'].items():
        _tmp_kp289 = _tmp_k287
        _struct290 = thrift.lib.thrift.patch.ttypes.StringPatch()
        _struct290.readFromJson(_tmp_v288, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp289] = _struct290
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e291 in json_obj['remove']:
        self.remove.add(_tmp_e291)
    if 'put' in json_obj and json_obj['put'] is not None:
      self.put = dict_cls()
      for _tmp_k292, _tmp_v293 in json_obj['put'].items():
        _tmp_kp294 = _tmp_k292
        self.put[_tmp_kp294] = _tmp_v293

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.put is not None:
      value = pprint.pformat(self.put, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    put=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'add',
      'patch',
      'remove',
      'put',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField28Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField28Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField29Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patch: Patches list values by index. Applies second.
   - prepend: Prepends to the front of a given list.
   - append: Appends to the back of a given list.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.assign = []
          (_etype298, _size295) = iprot.readListBegin()
          if _size295 >= 0:
            for _i299 in range(_size295):
              _elem300 = {}
              (_ktype302, _vtype303, _size301 ) = iprot.readMapBegin() 
              if _size301 >= 0:
                for _i305 in range(_size301):
                  _key306 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val307 = iprot.readI32()
                  _elem300[_key306] = _val307
              else: 
                while iprot.peekMap():
                  _key308 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val309 = iprot.readI32()
                  _elem300[_key308] = _val309
              iprot.readMapEnd()
              self.assign.append(_elem300)
          else: 
            while iprot.peekList():
              _elem310 = {}
              (_ktype312, _vtype313, _size311 ) = iprot.readMapBegin() 
              if _size311 >= 0:
                for _i315 in range(_size311):
                  _key316 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val317 = iprot.readI32()
                  _elem310[_key316] = _val317
              else: 
                while iprot.peekMap():
                  _key318 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val319 = iprot.readI32()
                  _elem310[_key318] = _val319
              iprot.readMapEnd()
              self.assign.append(_elem310)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype321, _vtype322, _size320 ) = iprot.readMapBegin() 
          if _size320 >= 0:
            for _i324 in range(_size320):
              _key325 = iprot.readI32()
              _val326 = MyStructField29Patch1()
              _val326.read(iprot)
              self.patch[_key325] = _val326
          else: 
            while iprot.peekMap():
              _key327 = iprot.readI32()
              _val328 = MyStructField29Patch1()
              _val328.read(iprot)
              self.patch[_key327] = _val328
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.prepend = []
          (_etype332, _size329) = iprot.readListBegin()
          if _size329 >= 0:
            for _i333 in range(_size329):
              _elem334 = {}
              (_ktype336, _vtype337, _size335 ) = iprot.readMapBegin() 
              if _size335 >= 0:
                for _i339 in range(_size335):
                  _key340 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val341 = iprot.readI32()
                  _elem334[_key340] = _val341
              else: 
                while iprot.peekMap():
                  _key342 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val343 = iprot.readI32()
                  _elem334[_key342] = _val343
              iprot.readMapEnd()
              self.prepend.append(_elem334)
          else: 
            while iprot.peekList():
              _elem344 = {}
              (_ktype346, _vtype347, _size345 ) = iprot.readMapBegin() 
              if _size345 >= 0:
                for _i349 in range(_size345):
                  _key350 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val351 = iprot.readI32()
                  _elem344[_key350] = _val351
              else: 
                while iprot.peekMap():
                  _key352 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val353 = iprot.readI32()
                  _elem344[_key352] = _val353
              iprot.readMapEnd()
              self.prepend.append(_elem344)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.append = []
          (_etype357, _size354) = iprot.readListBegin()
          if _size354 >= 0:
            for _i358 in range(_size354):
              _elem359 = {}
              (_ktype361, _vtype362, _size360 ) = iprot.readMapBegin() 
              if _size360 >= 0:
                for _i364 in range(_size360):
                  _key365 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val366 = iprot.readI32()
                  _elem359[_key365] = _val366
              else: 
                while iprot.peekMap():
                  _key367 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val368 = iprot.readI32()
                  _elem359[_key367] = _val368
              iprot.readMapEnd()
              self.append.append(_elem359)
          else: 
            while iprot.peekList():
              _elem369 = {}
              (_ktype371, _vtype372, _size370 ) = iprot.readMapBegin() 
              if _size370 >= 0:
                for _i374 in range(_size370):
                  _key375 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val376 = iprot.readI32()
                  _elem369[_key375] = _val376
              else: 
                while iprot.peekMap():
                  _key377 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val378 = iprot.readI32()
                  _elem369[_key377] = _val378
              iprot.readMapEnd()
              self.append.append(_elem369)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField29Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.LIST, 1)
      oprot.writeListBegin(TType.MAP, len(self.assign))
      for iter379 in self.assign:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter379))
        for kiter380,viter381 in iter379.items():
          oprot.writeString(kiter380.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter380, bytes) else oprot.writeString(kiter380)
          oprot.writeI32(viter381)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.patch))
      for kiter382,viter383 in self.patch.items():
        oprot.writeI32(kiter382)
        viter383.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.prepend != None:
      oprot.writeFieldBegin('prepend', TType.LIST, 8)
      oprot.writeListBegin(TType.MAP, len(self.prepend))
      for iter384 in self.prepend:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter384))
        for kiter385,viter386 in iter384.items():
          oprot.writeString(kiter385.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter385, bytes) else oprot.writeString(kiter385)
          oprot.writeI32(viter386)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.append != None:
      oprot.writeFieldBegin('append', TType.LIST, 9)
      oprot.writeListBegin(TType.MAP, len(self.append))
      for iter387 in self.append:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter387))
        for kiter388,viter389 in iter387.items():
          oprot.writeString(kiter388.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter388, bytes) else oprot.writeString(kiter388)
          oprot.writeI32(viter389)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = []
      for _tmp_e390 in json_obj['assign']:
        _map391 = dict_cls()
        for _tmp_k392, _tmp_v393 in _tmp_e390.items():
          _tmp_kp394 = _tmp_k392
          if _tmp_v393 > 0x7fffffff or _tmp_v393 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map391[_tmp_kp394] = _tmp_v393
        self.assign.append(_map391)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k395, _tmp_v396 in json_obj['patch'].items():
        _tmp_kp397 = int(_tmp_k395)
        if _tmp_kp397 > 0x7fffffff or _tmp_kp397 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k395)
        _struct398 = MyStructField29Patch1()
        _struct398.readFromJson(_tmp_v396, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp397] = _struct398
    if 'prepend' in json_obj and json_obj['prepend'] is not None:
      self.prepend = []
      for _tmp_e399 in json_obj['prepend']:
        _map400 = dict_cls()
        for _tmp_k401, _tmp_v402 in _tmp_e399.items():
          _tmp_kp403 = _tmp_k401
          if _tmp_v402 > 0x7fffffff or _tmp_v402 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map400[_tmp_kp403] = _tmp_v402
        self.prepend.append(_map400)
    if 'append' in json_obj and json_obj['append'] is not None:
      self.append = []
      for _tmp_e404 in json_obj['append']:
        _map405 = dict_cls()
        for _tmp_k406, _tmp_v407 in _tmp_e404.items():
          _tmp_kp408 = _tmp_k406
          if _tmp_v407 > 0x7fffffff or _tmp_v407 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map405[_tmp_kp408] = _tmp_v407
        self.append.append(_map405)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.prepend is not None:
      value = pprint.pformat(self.prepend, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prepend=%s' % (value))
    if self.append is not None:
      value = pprint.pformat(self.append, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    append=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patch',
      'prepend',
      'append',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField29Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField29Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField29Patch1:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - add: Add the given values, if the keys are not already present. Applies forth.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
   - put: Adds or replaces the given key/value pairs. Applies fifth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype410, _vtype411, _size409 ) = iprot.readMapBegin() 
          if _size409 >= 0:
            for _i413 in range(_size409):
              _key414 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val415 = iprot.readI32()
              self.assign[_key414] = _val415
          else: 
            while iprot.peekMap():
              _key416 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val417 = iprot.readI32()
              self.assign[_key416] = _val417
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patchPrior = {}
          (_ktype419, _vtype420, _size418 ) = iprot.readMapBegin() 
          if _size418 >= 0:
            for _i422 in range(_size418):
              _key423 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val424 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val424.read(iprot)
              self.patchPrior[_key423] = _val424
          else: 
            while iprot.peekMap():
              _key425 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val426 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val426.read(iprot)
              self.patchPrior[_key425] = _val426
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.add = {}
          (_ktype428, _vtype429, _size427 ) = iprot.readMapBegin() 
          if _size427 >= 0:
            for _i431 in range(_size427):
              _key432 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val433 = iprot.readI32()
              self.add[_key432] = _val433
          else: 
            while iprot.peekMap():
              _key434 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val435 = iprot.readI32()
              self.add[_key434] = _val435
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype437, _vtype438, _size436 ) = iprot.readMapBegin() 
          if _size436 >= 0:
            for _i440 in range(_size436):
              _key441 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val442 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val442.read(iprot)
              self.patch[_key441] = _val442
          else: 
            while iprot.peekMap():
              _key443 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val444 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val444.read(iprot)
              self.patch[_key443] = _val444
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype448, _size445) = iprot.readSetBegin()
          if _size445 >= 0:
            for _i449 in range(_size445):
              _elem450 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem450)
          else: 
            while iprot.peekSet():
              _elem451 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem451)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.put = {}
          (_ktype453, _vtype454, _size452 ) = iprot.readMapBegin() 
          if _size452 >= 0:
            for _i456 in range(_size452):
              _key457 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val458 = iprot.readI32()
              self.put[_key457] = _val458
          else: 
            while iprot.peekMap():
              _key459 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val460 = iprot.readI32()
              self.put[_key459] = _val460
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField29Patch1')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.assign))
      for kiter461,viter462 in self.assign.items():
        oprot.writeString(kiter461.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter461, bytes) else oprot.writeString(kiter461)
        oprot.writeI32(viter462)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patchPrior))
      for kiter463,viter464 in self.patchPrior.items():
        oprot.writeString(kiter463.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter463, bytes) else oprot.writeString(kiter463)
        viter464.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.add))
      for kiter465,viter466 in self.add.items():
        oprot.writeString(kiter465.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter465, bytes) else oprot.writeString(kiter465)
        oprot.writeI32(viter466)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patch))
      for kiter467,viter468 in self.patch.items():
        oprot.writeString(kiter467.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter467, bytes) else oprot.writeString(kiter467)
        viter468.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter469 in self.remove:
        oprot.writeString(iter469.encode('utf-8')) if UTF8STRINGS and not isinstance(iter469, bytes) else oprot.writeString(iter469)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.put != None:
      oprot.writeFieldBegin('put', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.put))
      for kiter470,viter471 in self.put.items():
        oprot.writeString(kiter470.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter470, bytes) else oprot.writeString(kiter470)
        oprot.writeI32(viter471)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k472, _tmp_v473 in json_obj['assign'].items():
        _tmp_kp474 = _tmp_k472
        if _tmp_v473 > 0x7fffffff or _tmp_v473 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.assign[_tmp_kp474] = _tmp_v473
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = dict_cls()
      for _tmp_k475, _tmp_v476 in json_obj['patchPrior'].items():
        _tmp_kp477 = _tmp_k475
        _struct478 = thrift.lib.thrift.patch.ttypes.I32Patch()
        _struct478.readFromJson(_tmp_v476, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patchPrior[_tmp_kp477] = _struct478
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = dict_cls()
      for _tmp_k479, _tmp_v480 in json_obj['add'].items():
        _tmp_kp481 = _tmp_k479
        if _tmp_v480 > 0x7fffffff or _tmp_v480 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.add[_tmp_kp481] = _tmp_v480
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k482, _tmp_v483 in json_obj['patch'].items():
        _tmp_kp484 = _tmp_k482
        _struct485 = thrift.lib.thrift.patch.ttypes.I32Patch()
        _struct485.readFromJson(_tmp_v483, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp484] = _struct485
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e486 in json_obj['remove']:
        self.remove.add(_tmp_e486)
    if 'put' in json_obj and json_obj['put'] is not None:
      self.put = dict_cls()
      for _tmp_k487, _tmp_v488 in json_obj['put'].items():
        _tmp_kp489 = _tmp_k487
        if _tmp_v488 > 0x7fffffff or _tmp_v488 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.put[_tmp_kp489] = _tmp_v488

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.put is not None:
      value = pprint.pformat(self.put, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    put=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'add',
      'patch',
      'remove',
      'put',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField29Patch1, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField29Patch1, self)

  def _to_py_deprecated(self):
    return self

class MyStructField30Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - add: Add the given values, if the keys are not already present. Applies forth.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
   - put: Adds or replaces the given key/value pairs. Applies fifth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype491, _vtype492, _size490 ) = iprot.readMapBegin() 
          if _size490 >= 0:
            for _i494 in range(_size490):
              _key495 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val496 = {}
              (_ktype498, _vtype499, _size497 ) = iprot.readMapBegin() 
              if _size497 >= 0:
                for _i501 in range(_size497):
                  _key502 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val503 = iprot.readI32()
                  _val496[_key502] = _val503
              else: 
                while iprot.peekMap():
                  _key504 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val505 = iprot.readI32()
                  _val496[_key504] = _val505
              iprot.readMapEnd()
              self.assign[_key495] = _val496
          else: 
            while iprot.peekMap():
              _key506 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val507 = {}
              (_ktype509, _vtype510, _size508 ) = iprot.readMapBegin() 
              if _size508 >= 0:
                for _i512 in range(_size508):
                  _key513 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val514 = iprot.readI32()
                  _val507[_key513] = _val514
              else: 
                while iprot.peekMap():
                  _key515 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val516 = iprot.readI32()
                  _val507[_key515] = _val516
              iprot.readMapEnd()
              self.assign[_key506] = _val507
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patchPrior = {}
          (_ktype518, _vtype519, _size517 ) = iprot.readMapBegin() 
          if _size517 >= 0:
            for _i521 in range(_size517):
              _key522 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val523 = MyStructField30Patch1()
              _val523.read(iprot)
              self.patchPrior[_key522] = _val523
          else: 
            while iprot.peekMap():
              _key524 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val525 = MyStructField30Patch1()
              _val525.read(iprot)
              self.patchPrior[_key524] = _val525
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.add = {}
          (_ktype527, _vtype528, _size526 ) = iprot.readMapBegin() 
          if _size526 >= 0:
            for _i530 in range(_size526):
              _key531 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val532 = {}
              (_ktype534, _vtype535, _size533 ) = iprot.readMapBegin() 
              if _size533 >= 0:
                for _i537 in range(_size533):
                  _key538 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val539 = iprot.readI32()
                  _val532[_key538] = _val539
              else: 
                while iprot.peekMap():
                  _key540 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val541 = iprot.readI32()
                  _val532[_key540] = _val541
              iprot.readMapEnd()
              self.add[_key531] = _val532
          else: 
            while iprot.peekMap():
              _key542 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val543 = {}
              (_ktype545, _vtype546, _size544 ) = iprot.readMapBegin() 
              if _size544 >= 0:
                for _i548 in range(_size544):
                  _key549 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val550 = iprot.readI32()
                  _val543[_key549] = _val550
              else: 
                while iprot.peekMap():
                  _key551 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val552 = iprot.readI32()
                  _val543[_key551] = _val552
              iprot.readMapEnd()
              self.add[_key542] = _val543
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype554, _vtype555, _size553 ) = iprot.readMapBegin() 
          if _size553 >= 0:
            for _i557 in range(_size553):
              _key558 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val559 = MyStructField30Patch1()
              _val559.read(iprot)
              self.patch[_key558] = _val559
          else: 
            while iprot.peekMap():
              _key560 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val561 = MyStructField30Patch1()
              _val561.read(iprot)
              self.patch[_key560] = _val561
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype565, _size562) = iprot.readSetBegin()
          if _size562 >= 0:
            for _i566 in range(_size562):
              _elem567 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem567)
          else: 
            while iprot.peekSet():
              _elem568 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem568)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.put = {}
          (_ktype570, _vtype571, _size569 ) = iprot.readMapBegin() 
          if _size569 >= 0:
            for _i573 in range(_size569):
              _key574 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val575 = {}
              (_ktype577, _vtype578, _size576 ) = iprot.readMapBegin() 
              if _size576 >= 0:
                for _i580 in range(_size576):
                  _key581 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val582 = iprot.readI32()
                  _val575[_key581] = _val582
              else: 
                while iprot.peekMap():
                  _key583 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val584 = iprot.readI32()
                  _val575[_key583] = _val584
              iprot.readMapEnd()
              self.put[_key574] = _val575
          else: 
            while iprot.peekMap():
              _key585 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val586 = {}
              (_ktype588, _vtype589, _size587 ) = iprot.readMapBegin() 
              if _size587 >= 0:
                for _i591 in range(_size587):
                  _key592 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val593 = iprot.readI32()
                  _val586[_key592] = _val593
              else: 
                while iprot.peekMap():
                  _key594 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val595 = iprot.readI32()
                  _val586[_key594] = _val595
              iprot.readMapEnd()
              self.put[_key585] = _val586
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField30Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.assign))
      for kiter596,viter597 in self.assign.items():
        oprot.writeString(kiter596.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter596, bytes) else oprot.writeString(kiter596)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter597))
        for kiter598,viter599 in viter597.items():
          oprot.writeString(kiter598.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter598, bytes) else oprot.writeString(kiter598)
          oprot.writeI32(viter599)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patchPrior))
      for kiter600,viter601 in self.patchPrior.items():
        oprot.writeString(kiter600.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter600, bytes) else oprot.writeString(kiter600)
        viter601.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.add))
      for kiter602,viter603 in self.add.items():
        oprot.writeString(kiter602.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter602, bytes) else oprot.writeString(kiter602)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter603))
        for kiter604,viter605 in viter603.items():
          oprot.writeString(kiter604.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter604, bytes) else oprot.writeString(kiter604)
          oprot.writeI32(viter605)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patch))
      for kiter606,viter607 in self.patch.items():
        oprot.writeString(kiter606.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter606, bytes) else oprot.writeString(kiter606)
        viter607.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter608 in self.remove:
        oprot.writeString(iter608.encode('utf-8')) if UTF8STRINGS and not isinstance(iter608, bytes) else oprot.writeString(iter608)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.put != None:
      oprot.writeFieldBegin('put', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.put))
      for kiter609,viter610 in self.put.items():
        oprot.writeString(kiter609.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter609, bytes) else oprot.writeString(kiter609)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter610))
        for kiter611,viter612 in viter610.items():
          oprot.writeString(kiter611.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter611, bytes) else oprot.writeString(kiter611)
          oprot.writeI32(viter612)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k613, _tmp_v614 in json_obj['assign'].items():
        _tmp_kp615 = _tmp_k613
        _map616 = dict_cls()
        for _tmp_k617, _tmp_v618 in _tmp_v614.items():
          _tmp_kp619 = _tmp_k617
          if _tmp_v618 > 0x7fffffff or _tmp_v618 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map616[_tmp_kp619] = _tmp_v618
        self.assign[_tmp_kp615] = _map616
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = dict_cls()
      for _tmp_k620, _tmp_v621 in json_obj['patchPrior'].items():
        _tmp_kp622 = _tmp_k620
        _struct623 = MyStructField30Patch1()
        _struct623.readFromJson(_tmp_v621, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patchPrior[_tmp_kp622] = _struct623
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = dict_cls()
      for _tmp_k624, _tmp_v625 in json_obj['add'].items():
        _tmp_kp626 = _tmp_k624
        _map627 = dict_cls()
        for _tmp_k628, _tmp_v629 in _tmp_v625.items():
          _tmp_kp630 = _tmp_k628
          if _tmp_v629 > 0x7fffffff or _tmp_v629 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map627[_tmp_kp630] = _tmp_v629
        self.add[_tmp_kp626] = _map627
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k631, _tmp_v632 in json_obj['patch'].items():
        _tmp_kp633 = _tmp_k631
        _struct634 = MyStructField30Patch1()
        _struct634.readFromJson(_tmp_v632, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp633] = _struct634
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e635 in json_obj['remove']:
        self.remove.add(_tmp_e635)
    if 'put' in json_obj and json_obj['put'] is not None:
      self.put = dict_cls()
      for _tmp_k636, _tmp_v637 in json_obj['put'].items():
        _tmp_kp638 = _tmp_k636
        _map639 = dict_cls()
        for _tmp_k640, _tmp_v641 in _tmp_v637.items():
          _tmp_kp642 = _tmp_k640
          if _tmp_v641 > 0x7fffffff or _tmp_v641 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map639[_tmp_kp642] = _tmp_v641
        self.put[_tmp_kp638] = _map639

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.put is not None:
      value = pprint.pformat(self.put, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    put=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'add',
      'patch',
      'remove',
      'put',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField30Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField30Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField30Patch1:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - add: Add the given values, if the keys are not already present. Applies forth.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
   - put: Adds or replaces the given key/value pairs. Applies fifth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype644, _vtype645, _size643 ) = iprot.readMapBegin() 
          if _size643 >= 0:
            for _i647 in range(_size643):
              _key648 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val649 = iprot.readI32()
              self.assign[_key648] = _val649
          else: 
            while iprot.peekMap():
              _key650 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val651 = iprot.readI32()
              self.assign[_key650] = _val651
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patchPrior = {}
          (_ktype653, _vtype654, _size652 ) = iprot.readMapBegin() 
          if _size652 >= 0:
            for _i656 in range(_size652):
              _key657 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val658 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val658.read(iprot)
              self.patchPrior[_key657] = _val658
          else: 
            while iprot.peekMap():
              _key659 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val660 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val660.read(iprot)
              self.patchPrior[_key659] = _val660
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.add = {}
          (_ktype662, _vtype663, _size661 ) = iprot.readMapBegin() 
          if _size661 >= 0:
            for _i665 in range(_size661):
              _key666 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val667 = iprot.readI32()
              self.add[_key666] = _val667
          else: 
            while iprot.peekMap():
              _key668 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val669 = iprot.readI32()
              self.add[_key668] = _val669
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype671, _vtype672, _size670 ) = iprot.readMapBegin() 
          if _size670 >= 0:
            for _i674 in range(_size670):
              _key675 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val676 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val676.read(iprot)
              self.patch[_key675] = _val676
          else: 
            while iprot.peekMap():
              _key677 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val678 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val678.read(iprot)
              self.patch[_key677] = _val678
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype682, _size679) = iprot.readSetBegin()
          if _size679 >= 0:
            for _i683 in range(_size679):
              _elem684 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem684)
          else: 
            while iprot.peekSet():
              _elem685 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem685)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.put = {}
          (_ktype687, _vtype688, _size686 ) = iprot.readMapBegin() 
          if _size686 >= 0:
            for _i690 in range(_size686):
              _key691 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val692 = iprot.readI32()
              self.put[_key691] = _val692
          else: 
            while iprot.peekMap():
              _key693 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val694 = iprot.readI32()
              self.put[_key693] = _val694
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField30Patch1')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.assign))
      for kiter695,viter696 in self.assign.items():
        oprot.writeString(kiter695.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter695, bytes) else oprot.writeString(kiter695)
        oprot.writeI32(viter696)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patchPrior))
      for kiter697,viter698 in self.patchPrior.items():
        oprot.writeString(kiter697.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter697, bytes) else oprot.writeString(kiter697)
        viter698.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.add))
      for kiter699,viter700 in self.add.items():
        oprot.writeString(kiter699.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter699, bytes) else oprot.writeString(kiter699)
        oprot.writeI32(viter700)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patch))
      for kiter701,viter702 in self.patch.items():
        oprot.writeString(kiter701.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter701, bytes) else oprot.writeString(kiter701)
        viter702.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter703 in self.remove:
        oprot.writeString(iter703.encode('utf-8')) if UTF8STRINGS and not isinstance(iter703, bytes) else oprot.writeString(iter703)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.put != None:
      oprot.writeFieldBegin('put', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.put))
      for kiter704,viter705 in self.put.items():
        oprot.writeString(kiter704.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter704, bytes) else oprot.writeString(kiter704)
        oprot.writeI32(viter705)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k706, _tmp_v707 in json_obj['assign'].items():
        _tmp_kp708 = _tmp_k706
        if _tmp_v707 > 0x7fffffff or _tmp_v707 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.assign[_tmp_kp708] = _tmp_v707
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = dict_cls()
      for _tmp_k709, _tmp_v710 in json_obj['patchPrior'].items():
        _tmp_kp711 = _tmp_k709
        _struct712 = thrift.lib.thrift.patch.ttypes.I32Patch()
        _struct712.readFromJson(_tmp_v710, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patchPrior[_tmp_kp711] = _struct712
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = dict_cls()
      for _tmp_k713, _tmp_v714 in json_obj['add'].items():
        _tmp_kp715 = _tmp_k713
        if _tmp_v714 > 0x7fffffff or _tmp_v714 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.add[_tmp_kp715] = _tmp_v714
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k716, _tmp_v717 in json_obj['patch'].items():
        _tmp_kp718 = _tmp_k716
        _struct719 = thrift.lib.thrift.patch.ttypes.I32Patch()
        _struct719.readFromJson(_tmp_v717, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp718] = _struct719
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e720 in json_obj['remove']:
        self.remove.add(_tmp_e720)
    if 'put' in json_obj and json_obj['put'] is not None:
      self.put = dict_cls()
      for _tmp_k721, _tmp_v722 in json_obj['put'].items():
        _tmp_kp723 = _tmp_k721
        if _tmp_v722 > 0x7fffffff or _tmp_v722 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.put[_tmp_kp723] = _tmp_v722

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.put is not None:
      value = pprint.pformat(self.put, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    put=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'add',
      'patch',
      'remove',
      'put',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField30Patch1, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField30Patch1, self)

  def _to_py_deprecated(self):
    return self

class MyStructFieldPatch:
  r"""
  Attributes:
   - structWithCustomDefault
   - i32WithCustomDefault
   - mapMap
   - listMap
   - optMapVal
   - optSetVal
   - optListVal
   - optLateStructVal
   - optStructVal
   - optEnumVal
   - optBinaryVal
   - optStringVal
   - optDoubleVal
   - optFloatVal
   - optI64Val
   - optI32Val
   - optI16Val
   - optByteVal
   - optBoolVal
   - lateStructVal
   - unionVal
   - structVal
   - enumVal
   - binaryVal
   - stringVal
   - doubleVal
   - floatVal
   - i64Val
   - i32Val
   - i16Val
   - byteVal
   - boolVal
   - structWithFieldCustomDefault
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -32:
        if ftype == TType.STRUCT:
          self.structWithCustomDefault = MyDataWithCustomDefaultPatch()
          self.structWithCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -31:
        if ftype == TType.STRUCT:
          self.i32WithCustomDefault = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.i32WithCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -30:
        if ftype == TType.STRUCT:
          self.mapMap = MyStructField30Patch()
          self.mapMap.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -29:
        if ftype == TType.STRUCT:
          self.listMap = MyStructField29Patch()
          self.listMap.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -28:
        if ftype == TType.STRUCT:
          self.optMapVal = MyStructField28Patch()
          self.optMapVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -27:
        if ftype == TType.STRUCT:
          self.optSetVal = MyStructField27Patch()
          self.optSetVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -26:
        if ftype == TType.STRUCT:
          self.optListVal = MyStructField26Patch()
          self.optListVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -25:
        if ftype == TType.STRUCT:
          self.optLateStructVal = LateDefStructPatch()
          self.optLateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -24:
        if ftype == TType.STRUCT:
          self.optStructVal = MyDataPatch()
          self.optStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -23:
        if ftype == TType.STRUCT:
          self.optEnumVal = MyStructField23Patch()
          self.optEnumVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -22:
        if ftype == TType.STRUCT:
          self.optBinaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
          self.optBinaryVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -21:
        if ftype == TType.STRUCT:
          self.optStringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.optStringVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -20:
        if ftype == TType.STRUCT:
          self.optDoubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
          self.optDoubleVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -19:
        if ftype == TType.STRUCT:
          self.optFloatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
          self.optFloatVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -18:
        if ftype == TType.STRUCT:
          self.optI64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
          self.optI64Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -17:
        if ftype == TType.STRUCT:
          self.optI32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.optI32Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -16:
        if ftype == TType.STRUCT:
          self.optI16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
          self.optI16Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -15:
        if ftype == TType.STRUCT:
          self.optByteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
          self.optByteVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -14:
        if ftype == TType.STRUCT:
          self.optBoolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
          self.optBoolVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -13:
        if ftype == TType.STRUCT:
          self.lateStructVal = LateDefStructPatch()
          self.lateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -12:
        if ftype == TType.STRUCT:
          self.unionVal = MyUnionPatch()
          self.unionVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -11:
        if ftype == TType.STRUCT:
          self.structVal = MyDataPatch()
          self.structVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -10:
        if ftype == TType.STRUCT:
          self.enumVal = MyStructField10Patch()
          self.enumVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -9:
        if ftype == TType.STRUCT:
          self.binaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
          self.binaryVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -8:
        if ftype == TType.STRUCT:
          self.stringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.stringVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -7:
        if ftype == TType.STRUCT:
          self.doubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
          self.doubleVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -6:
        if ftype == TType.STRUCT:
          self.floatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
          self.floatVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.STRUCT:
          self.i64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
          self.i64Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.STRUCT:
          self.i32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.i32Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRUCT:
          self.i16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
          self.i16Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRUCT:
          self.byteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
          self.byteVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.boolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
          self.boolVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.structWithFieldCustomDefault = MyDataPatch()
          self.structWithFieldCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructFieldPatch')
    if self.structWithCustomDefault != None:
      oprot.writeFieldBegin('structWithCustomDefault', TType.STRUCT, -32)
      self.structWithCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    if self.i32WithCustomDefault != None:
      oprot.writeFieldBegin('i32WithCustomDefault', TType.STRUCT, -31)
      self.i32WithCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    if self.mapMap != None:
      oprot.writeFieldBegin('mapMap', TType.STRUCT, -30)
      self.mapMap.write(oprot)
      oprot.writeFieldEnd()
    if self.listMap != None:
      oprot.writeFieldBegin('listMap', TType.STRUCT, -29)
      self.listMap.write(oprot)
      oprot.writeFieldEnd()
    if self.optMapVal != None:
      oprot.writeFieldBegin('optMapVal', TType.STRUCT, -28)
      self.optMapVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optSetVal != None:
      oprot.writeFieldBegin('optSetVal', TType.STRUCT, -27)
      self.optSetVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optListVal != None:
      oprot.writeFieldBegin('optListVal', TType.STRUCT, -26)
      self.optListVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optLateStructVal != None:
      oprot.writeFieldBegin('optLateStructVal', TType.STRUCT, -25)
      self.optLateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStructVal != None:
      oprot.writeFieldBegin('optStructVal', TType.STRUCT, -24)
      self.optStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optEnumVal != None:
      oprot.writeFieldBegin('optEnumVal', TType.STRUCT, -23)
      self.optEnumVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optBinaryVal != None:
      oprot.writeFieldBegin('optBinaryVal', TType.STRUCT, -22)
      self.optBinaryVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStringVal != None:
      oprot.writeFieldBegin('optStringVal', TType.STRUCT, -21)
      self.optStringVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optDoubleVal != None:
      oprot.writeFieldBegin('optDoubleVal', TType.STRUCT, -20)
      self.optDoubleVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optFloatVal != None:
      oprot.writeFieldBegin('optFloatVal', TType.STRUCT, -19)
      self.optFloatVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optI64Val != None:
      oprot.writeFieldBegin('optI64Val', TType.STRUCT, -18)
      self.optI64Val.write(oprot)
      oprot.writeFieldEnd()
    if self.optI32Val != None:
      oprot.writeFieldBegin('optI32Val', TType.STRUCT, -17)
      self.optI32Val.write(oprot)
      oprot.writeFieldEnd()
    if self.optI16Val != None:
      oprot.writeFieldBegin('optI16Val', TType.STRUCT, -16)
      self.optI16Val.write(oprot)
      oprot.writeFieldEnd()
    if self.optByteVal != None:
      oprot.writeFieldBegin('optByteVal', TType.STRUCT, -15)
      self.optByteVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optBoolVal != None:
      oprot.writeFieldBegin('optBoolVal', TType.STRUCT, -14)
      self.optBoolVal.write(oprot)
      oprot.writeFieldEnd()
    if self.lateStructVal != None:
      oprot.writeFieldBegin('lateStructVal', TType.STRUCT, -13)
      self.lateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.unionVal != None:
      oprot.writeFieldBegin('unionVal', TType.STRUCT, -12)
      self.unionVal.write(oprot)
      oprot.writeFieldEnd()
    if self.structVal != None:
      oprot.writeFieldBegin('structVal', TType.STRUCT, -11)
      self.structVal.write(oprot)
      oprot.writeFieldEnd()
    if self.enumVal != None:
      oprot.writeFieldBegin('enumVal', TType.STRUCT, -10)
      self.enumVal.write(oprot)
      oprot.writeFieldEnd()
    if self.binaryVal != None:
      oprot.writeFieldBegin('binaryVal', TType.STRUCT, -9)
      self.binaryVal.write(oprot)
      oprot.writeFieldEnd()
    if self.stringVal != None:
      oprot.writeFieldBegin('stringVal', TType.STRUCT, -8)
      self.stringVal.write(oprot)
      oprot.writeFieldEnd()
    if self.doubleVal != None:
      oprot.writeFieldBegin('doubleVal', TType.STRUCT, -7)
      self.doubleVal.write(oprot)
      oprot.writeFieldEnd()
    if self.floatVal != None:
      oprot.writeFieldBegin('floatVal', TType.STRUCT, -6)
      self.floatVal.write(oprot)
      oprot.writeFieldEnd()
    if self.i64Val != None:
      oprot.writeFieldBegin('i64Val', TType.STRUCT, -5)
      self.i64Val.write(oprot)
      oprot.writeFieldEnd()
    if self.i32Val != None:
      oprot.writeFieldBegin('i32Val', TType.STRUCT, -4)
      self.i32Val.write(oprot)
      oprot.writeFieldEnd()
    if self.i16Val != None:
      oprot.writeFieldBegin('i16Val', TType.STRUCT, -3)
      self.i16Val.write(oprot)
      oprot.writeFieldEnd()
    if self.byteVal != None:
      oprot.writeFieldBegin('byteVal', TType.STRUCT, -2)
      self.byteVal.write(oprot)
      oprot.writeFieldEnd()
    if self.boolVal != None:
      oprot.writeFieldBegin('boolVal', TType.STRUCT, -1)
      self.boolVal.write(oprot)
      oprot.writeFieldEnd()
    if self.structWithFieldCustomDefault != None:
      oprot.writeFieldBegin('structWithFieldCustomDefault', TType.STRUCT, 1)
      self.structWithFieldCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'structWithCustomDefault' in json_obj and json_obj['structWithCustomDefault'] is not None:
      self.structWithCustomDefault = MyDataWithCustomDefaultPatch()
      self.structWithCustomDefault.readFromJson(json_obj['structWithCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i32WithCustomDefault' in json_obj and json_obj['i32WithCustomDefault'] is not None:
      self.i32WithCustomDefault = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.i32WithCustomDefault.readFromJson(json_obj['i32WithCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'mapMap' in json_obj and json_obj['mapMap'] is not None:
      self.mapMap = MyStructField30Patch()
      self.mapMap.readFromJson(json_obj['mapMap'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'listMap' in json_obj and json_obj['listMap'] is not None:
      self.listMap = MyStructField29Patch()
      self.listMap.readFromJson(json_obj['listMap'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optMapVal' in json_obj and json_obj['optMapVal'] is not None:
      self.optMapVal = MyStructField28Patch()
      self.optMapVal.readFromJson(json_obj['optMapVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optSetVal' in json_obj and json_obj['optSetVal'] is not None:
      self.optSetVal = MyStructField27Patch()
      self.optSetVal.readFromJson(json_obj['optSetVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optListVal' in json_obj and json_obj['optListVal'] is not None:
      self.optListVal = MyStructField26Patch()
      self.optListVal.readFromJson(json_obj['optListVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optLateStructVal' in json_obj and json_obj['optLateStructVal'] is not None:
      self.optLateStructVal = LateDefStructPatch()
      self.optLateStructVal.readFromJson(json_obj['optLateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optStructVal' in json_obj and json_obj['optStructVal'] is not None:
      self.optStructVal = MyDataPatch()
      self.optStructVal.readFromJson(json_obj['optStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optEnumVal' in json_obj and json_obj['optEnumVal'] is not None:
      self.optEnumVal = MyStructField23Patch()
      self.optEnumVal.readFromJson(json_obj['optEnumVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optBinaryVal' in json_obj and json_obj['optBinaryVal'] is not None:
      self.optBinaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
      self.optBinaryVal.readFromJson(json_obj['optBinaryVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optStringVal' in json_obj and json_obj['optStringVal'] is not None:
      self.optStringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.optStringVal.readFromJson(json_obj['optStringVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optDoubleVal' in json_obj and json_obj['optDoubleVal'] is not None:
      self.optDoubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
      self.optDoubleVal.readFromJson(json_obj['optDoubleVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optFloatVal' in json_obj and json_obj['optFloatVal'] is not None:
      self.optFloatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
      self.optFloatVal.readFromJson(json_obj['optFloatVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optI64Val' in json_obj and json_obj['optI64Val'] is not None:
      self.optI64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
      self.optI64Val.readFromJson(json_obj['optI64Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optI32Val' in json_obj and json_obj['optI32Val'] is not None:
      self.optI32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.optI32Val.readFromJson(json_obj['optI32Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optI16Val' in json_obj and json_obj['optI16Val'] is not None:
      self.optI16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
      self.optI16Val.readFromJson(json_obj['optI16Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optByteVal' in json_obj and json_obj['optByteVal'] is not None:
      self.optByteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
      self.optByteVal.readFromJson(json_obj['optByteVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optBoolVal' in json_obj and json_obj['optBoolVal'] is not None:
      self.optBoolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
      self.optBoolVal.readFromJson(json_obj['optBoolVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'lateStructVal' in json_obj and json_obj['lateStructVal'] is not None:
      self.lateStructVal = LateDefStructPatch()
      self.lateStructVal.readFromJson(json_obj['lateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'unionVal' in json_obj and json_obj['unionVal'] is not None:
      self.unionVal = MyUnionPatch()
      self.unionVal.readFromJson(json_obj['unionVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structVal' in json_obj and json_obj['structVal'] is not None:
      self.structVal = MyDataPatch()
      self.structVal.readFromJson(json_obj['structVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'enumVal' in json_obj and json_obj['enumVal'] is not None:
      self.enumVal = MyStructField10Patch()
      self.enumVal.readFromJson(json_obj['enumVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'binaryVal' in json_obj and json_obj['binaryVal'] is not None:
      self.binaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
      self.binaryVal.readFromJson(json_obj['binaryVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'stringVal' in json_obj and json_obj['stringVal'] is not None:
      self.stringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.stringVal.readFromJson(json_obj['stringVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'doubleVal' in json_obj and json_obj['doubleVal'] is not None:
      self.doubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
      self.doubleVal.readFromJson(json_obj['doubleVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'floatVal' in json_obj and json_obj['floatVal'] is not None:
      self.floatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
      self.floatVal.readFromJson(json_obj['floatVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i64Val' in json_obj and json_obj['i64Val'] is not None:
      self.i64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
      self.i64Val.readFromJson(json_obj['i64Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i32Val' in json_obj and json_obj['i32Val'] is not None:
      self.i32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.i32Val.readFromJson(json_obj['i32Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i16Val' in json_obj and json_obj['i16Val'] is not None:
      self.i16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
      self.i16Val.readFromJson(json_obj['i16Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'byteVal' in json_obj and json_obj['byteVal'] is not None:
      self.byteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
      self.byteVal.readFromJson(json_obj['byteVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'boolVal' in json_obj and json_obj['boolVal'] is not None:
      self.boolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
      self.boolVal.readFromJson(json_obj['boolVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structWithFieldCustomDefault' in json_obj and json_obj['structWithFieldCustomDefault'] is not None:
      self.structWithFieldCustomDefault = MyDataPatch()
      self.structWithFieldCustomDefault.readFromJson(json_obj['structWithFieldCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.structWithCustomDefault is not None:
      value = pprint.pformat(self.structWithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithCustomDefault=%s' % (value))
    if self.i32WithCustomDefault is not None:
      value = pprint.pformat(self.i32WithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32WithCustomDefault=%s' % (value))
    if self.mapMap is not None:
      value = pprint.pformat(self.mapMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapMap=%s' % (value))
    if self.listMap is not None:
      value = pprint.pformat(self.listMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    listMap=%s' % (value))
    if self.optMapVal is not None:
      value = pprint.pformat(self.optMapVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optMapVal=%s' % (value))
    if self.optSetVal is not None:
      value = pprint.pformat(self.optSetVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optSetVal=%s' % (value))
    if self.optListVal is not None:
      value = pprint.pformat(self.optListVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optListVal=%s' % (value))
    if self.optLateStructVal is not None:
      value = pprint.pformat(self.optLateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optLateStructVal=%s' % (value))
    if self.optStructVal is not None:
      value = pprint.pformat(self.optStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStructVal=%s' % (value))
    if self.optEnumVal is not None:
      value = pprint.pformat(self.optEnumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optEnumVal=%s' % (value))
    if self.optBinaryVal is not None:
      value = pprint.pformat(self.optBinaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBinaryVal=%s' % (value))
    if self.optStringVal is not None:
      value = pprint.pformat(self.optStringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStringVal=%s' % (value))
    if self.optDoubleVal is not None:
      value = pprint.pformat(self.optDoubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optDoubleVal=%s' % (value))
    if self.optFloatVal is not None:
      value = pprint.pformat(self.optFloatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optFloatVal=%s' % (value))
    if self.optI64Val is not None:
      value = pprint.pformat(self.optI64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI64Val=%s' % (value))
    if self.optI32Val is not None:
      value = pprint.pformat(self.optI32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI32Val=%s' % (value))
    if self.optI16Val is not None:
      value = pprint.pformat(self.optI16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI16Val=%s' % (value))
    if self.optByteVal is not None:
      value = pprint.pformat(self.optByteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optByteVal=%s' % (value))
    if self.optBoolVal is not None:
      value = pprint.pformat(self.optBoolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBoolVal=%s' % (value))
    if self.lateStructVal is not None:
      value = pprint.pformat(self.lateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lateStructVal=%s' % (value))
    if self.unionVal is not None:
      value = pprint.pformat(self.unionVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionVal=%s' % (value))
    if self.structVal is not None:
      value = pprint.pformat(self.structVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structVal=%s' % (value))
    if self.enumVal is not None:
      value = pprint.pformat(self.enumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enumVal=%s' % (value))
    if self.binaryVal is not None:
      value = pprint.pformat(self.binaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryVal=%s' % (value))
    if self.stringVal is not None:
      value = pprint.pformat(self.stringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stringVal=%s' % (value))
    if self.doubleVal is not None:
      value = pprint.pformat(self.doubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleVal=%s' % (value))
    if self.floatVal is not None:
      value = pprint.pformat(self.floatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    floatVal=%s' % (value))
    if self.i64Val is not None:
      value = pprint.pformat(self.i64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i64Val=%s' % (value))
    if self.i32Val is not None:
      value = pprint.pformat(self.i32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32Val=%s' % (value))
    if self.i16Val is not None:
      value = pprint.pformat(self.i16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i16Val=%s' % (value))
    if self.byteVal is not None:
      value = pprint.pformat(self.byteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byteVal=%s' % (value))
    if self.boolVal is not None:
      value = pprint.pformat(self.boolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    boolVal=%s' % (value))
    if self.structWithFieldCustomDefault is not None:
      value = pprint.pformat(self.structWithFieldCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithFieldCustomDefault=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'structWithCustomDefault',
      'i32WithCustomDefault',
      'mapMap',
      'listMap',
      'optMapVal',
      'optSetVal',
      'optListVal',
      'optLateStructVal',
      'optStructVal',
      'optEnumVal',
      'optBinaryVal',
      'optStringVal',
      'optDoubleVal',
      'optFloatVal',
      'optI64Val',
      'optI32Val',
      'optI16Val',
      'optByteVal',
      'optBoolVal',
      'lateStructVal',
      'unionVal',
      'structVal',
      'enumVal',
      'binaryVal',
      'stringVal',
      'doubleVal',
      'floatVal',
      'i64Val',
      'i32Val',
      'i16Val',
      'byteVal',
      'boolVal',
      'structWithFieldCustomDefault',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyStructEnsureStruct:
  r"""
  Attributes:
   - structWithCustomDefault
   - i32WithCustomDefault
   - mapMap
   - listMap
   - optMapVal
   - optSetVal
   - optListVal
   - optLateStructVal
   - optStructVal
   - optEnumVal
   - optBinaryVal
   - optStringVal
   - optDoubleVal
   - optFloatVal
   - optI64Val
   - optI32Val
   - optI16Val
   - optByteVal
   - optBoolVal
   - lateStructVal
   - unionVal
   - structVal
   - enumVal
   - binaryVal
   - stringVal
   - doubleVal
   - floatVal
   - i64Val
   - i32Val
   - i16Val
   - byteVal
   - boolVal
   - structWithFieldCustomDefault
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -32:
        if ftype == TType.STRUCT:
          self.structWithCustomDefault = MyDataWithCustomDefault()
          self.structWithCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -31:
        if ftype == TType.I32:
          self.i32WithCustomDefault = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -30:
        if ftype == TType.MAP:
          self.mapMap = {}
          (_ktype725, _vtype726, _size724 ) = iprot.readMapBegin() 
          if _size724 >= 0:
            for _i728 in range(_size724):
              _key729 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val730 = {}
              (_ktype732, _vtype733, _size731 ) = iprot.readMapBegin() 
              if _size731 >= 0:
                for _i735 in range(_size731):
                  _key736 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val737 = iprot.readI32()
                  _val730[_key736] = _val737
              else: 
                while iprot.peekMap():
                  _key738 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val739 = iprot.readI32()
                  _val730[_key738] = _val739
              iprot.readMapEnd()
              self.mapMap[_key729] = _val730
          else: 
            while iprot.peekMap():
              _key740 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val741 = {}
              (_ktype743, _vtype744, _size742 ) = iprot.readMapBegin() 
              if _size742 >= 0:
                for _i746 in range(_size742):
                  _key747 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val748 = iprot.readI32()
                  _val741[_key747] = _val748
              else: 
                while iprot.peekMap():
                  _key749 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val750 = iprot.readI32()
                  _val741[_key749] = _val750
              iprot.readMapEnd()
              self.mapMap[_key740] = _val741
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -29:
        if ftype == TType.LIST:
          self.listMap = []
          (_etype754, _size751) = iprot.readListBegin()
          if _size751 >= 0:
            for _i755 in range(_size751):
              _elem756 = {}
              (_ktype758, _vtype759, _size757 ) = iprot.readMapBegin() 
              if _size757 >= 0:
                for _i761 in range(_size757):
                  _key762 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val763 = iprot.readI32()
                  _elem756[_key762] = _val763
              else: 
                while iprot.peekMap():
                  _key764 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val765 = iprot.readI32()
                  _elem756[_key764] = _val765
              iprot.readMapEnd()
              self.listMap.append(_elem756)
          else: 
            while iprot.peekList():
              _elem766 = {}
              (_ktype768, _vtype769, _size767 ) = iprot.readMapBegin() 
              if _size767 >= 0:
                for _i771 in range(_size767):
                  _key772 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val773 = iprot.readI32()
                  _elem766[_key772] = _val773
              else: 
                while iprot.peekMap():
                  _key774 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val775 = iprot.readI32()
                  _elem766[_key774] = _val775
              iprot.readMapEnd()
              self.listMap.append(_elem766)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -28:
        if ftype == TType.MAP:
          self.optMapVal = {}
          (_ktype777, _vtype778, _size776 ) = iprot.readMapBegin() 
          if _size776 >= 0:
            for _i780 in range(_size776):
              _key781 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val782 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key781] = _val782
          else: 
            while iprot.peekMap():
              _key783 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val784 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key783] = _val784
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -27:
        if ftype == TType.SET:
          self.optSetVal = set()
          (_etype788, _size785) = iprot.readSetBegin()
          if _size785 >= 0:
            for _i789 in range(_size785):
              _elem790 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem790)
          else: 
            while iprot.peekSet():
              _elem791 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem791)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == -26:
        if ftype == TType.LIST:
          self.optListVal = []
          (_etype795, _size792) = iprot.readListBegin()
          if _size792 >= 0:
            for _i796 in range(_size792):
              _elem797 = iprot.readI16()
              self.optListVal.append(_elem797)
          else: 
            while iprot.peekList():
              _elem798 = iprot.readI16()
              self.optListVal.append(_elem798)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -25:
        if ftype == TType.STRUCT:
          self.optLateStructVal = LateDefStruct()
          self.optLateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -24:
        if ftype == TType.STRUCT:
          self.optStructVal = MyData()
          self.optStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -23:
        if ftype == TType.I32:
          self.optEnumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -22:
        if ftype == TType.STRING:
          self.optBinaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -21:
        if ftype == TType.STRING:
          self.optStringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -20:
        if ftype == TType.DOUBLE:
          self.optDoubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -19:
        if ftype == TType.FLOAT:
          self.optFloatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -18:
        if ftype == TType.I64:
          self.optI64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -17:
        if ftype == TType.I32:
          self.optI32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -16:
        if ftype == TType.I16:
          self.optI16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -15:
        if ftype == TType.BYTE:
          self.optByteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -14:
        if ftype == TType.BOOL:
          self.optBoolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == -13:
        if ftype == TType.STRUCT:
          self.lateStructVal = LateDefStruct()
          self.lateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -12:
        if ftype == TType.STRUCT:
          self.unionVal = MyUnion()
          self.unionVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -11:
        if ftype == TType.STRUCT:
          self.structVal = MyData()
          self.structVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -10:
        if ftype == TType.I32:
          self.enumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -9:
        if ftype == TType.STRING:
          self.binaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -8:
        if ftype == TType.STRING:
          self.stringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -7:
        if ftype == TType.DOUBLE:
          self.doubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -6:
        if ftype == TType.FLOAT:
          self.floatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.I64:
          self.i64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.I32:
          self.i32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.I16:
          self.i16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.BYTE:
          self.byteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.BOOL:
          self.boolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.structWithFieldCustomDefault = MyData()
          self.structWithFieldCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructEnsureStruct')
    if self.structWithCustomDefault != None:
      oprot.writeFieldBegin('structWithCustomDefault', TType.STRUCT, -32)
      self.structWithCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    if self.i32WithCustomDefault != None:
      oprot.writeFieldBegin('i32WithCustomDefault', TType.I32, -31)
      oprot.writeI32(self.i32WithCustomDefault)
      oprot.writeFieldEnd()
    if self.mapMap != None:
      oprot.writeFieldBegin('mapMap', TType.MAP, -30)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.mapMap))
      for kiter799,viter800 in self.mapMap.items():
        oprot.writeString(kiter799.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter799, bytes) else oprot.writeString(kiter799)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter800))
        for kiter801,viter802 in viter800.items():
          oprot.writeString(kiter801.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter801, bytes) else oprot.writeString(kiter801)
          oprot.writeI32(viter802)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.listMap != None:
      oprot.writeFieldBegin('listMap', TType.LIST, -29)
      oprot.writeListBegin(TType.MAP, len(self.listMap))
      for iter803 in self.listMap:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter803))
        for kiter804,viter805 in iter803.items():
          oprot.writeString(kiter804.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter804, bytes) else oprot.writeString(kiter804)
          oprot.writeI32(viter805)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optMapVal != None:
      oprot.writeFieldBegin('optMapVal', TType.MAP, -28)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.optMapVal))
      for kiter806,viter807 in self.optMapVal.items():
        oprot.writeString(kiter806.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter806, bytes) else oprot.writeString(kiter806)
        oprot.writeString(viter807.encode('utf-8')) if UTF8STRINGS and not isinstance(viter807, bytes) else oprot.writeString(viter807)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.optSetVal != None:
      oprot.writeFieldBegin('optSetVal', TType.SET, -27)
      oprot.writeSetBegin(TType.STRING, len(self.optSetVal))
      for iter808 in self.optSetVal:
        oprot.writeString(iter808.encode('utf-8')) if UTF8STRINGS and not isinstance(iter808, bytes) else oprot.writeString(iter808)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.optListVal != None:
      oprot.writeFieldBegin('optListVal', TType.LIST, -26)
      oprot.writeListBegin(TType.I16, len(self.optListVal))
      for iter809 in self.optListVal:
        oprot.writeI16(iter809)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optLateStructVal != None:
      oprot.writeFieldBegin('optLateStructVal', TType.STRUCT, -25)
      self.optLateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStructVal != None:
      oprot.writeFieldBegin('optStructVal', TType.STRUCT, -24)
      self.optStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optEnumVal != None:
      oprot.writeFieldBegin('optEnumVal', TType.I32, -23)
      oprot.writeI32(self.optEnumVal)
      oprot.writeFieldEnd()
    if self.optBinaryVal != None:
      oprot.writeFieldBegin('optBinaryVal', TType.STRING, -22)
      oprot.writeString(self.optBinaryVal)
      oprot.writeFieldEnd()
    if self.optStringVal != None:
      oprot.writeFieldBegin('optStringVal', TType.STRING, -21)
      oprot.writeString(self.optStringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.optStringVal, bytes) else oprot.writeString(self.optStringVal)
      oprot.writeFieldEnd()
    if self.optDoubleVal != None:
      oprot.writeFieldBegin('optDoubleVal', TType.DOUBLE, -20)
      oprot.writeDouble(self.optDoubleVal)
      oprot.writeFieldEnd()
    if self.optFloatVal != None:
      oprot.writeFieldBegin('optFloatVal', TType.FLOAT, -19)
      oprot.writeFloat(self.optFloatVal)
      oprot.writeFieldEnd()
    if self.optI64Val != None:
      oprot.writeFieldBegin('optI64Val', TType.I64, -18)
      oprot.writeI64(self.optI64Val)
      oprot.writeFieldEnd()
    if self.optI32Val != None:
      oprot.writeFieldBegin('optI32Val', TType.I32, -17)
      oprot.writeI32(self.optI32Val)
      oprot.writeFieldEnd()
    if self.optI16Val != None:
      oprot.writeFieldBegin('optI16Val', TType.I16, -16)
      oprot.writeI16(self.optI16Val)
      oprot.writeFieldEnd()
    if self.optByteVal != None:
      oprot.writeFieldBegin('optByteVal', TType.BYTE, -15)
      oprot.writeByte(self.optByteVal)
      oprot.writeFieldEnd()
    if self.optBoolVal != None:
      oprot.writeFieldBegin('optBoolVal', TType.BOOL, -14)
      oprot.writeBool(self.optBoolVal)
      oprot.writeFieldEnd()
    if self.lateStructVal != None:
      oprot.writeFieldBegin('lateStructVal', TType.STRUCT, -13)
      self.lateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.unionVal != None:
      oprot.writeFieldBegin('unionVal', TType.STRUCT, -12)
      self.unionVal.write(oprot)
      oprot.writeFieldEnd()
    if self.structVal != None:
      oprot.writeFieldBegin('structVal', TType.STRUCT, -11)
      self.structVal.write(oprot)
      oprot.writeFieldEnd()
    if self.enumVal != None:
      oprot.writeFieldBegin('enumVal', TType.I32, -10)
      oprot.writeI32(self.enumVal)
      oprot.writeFieldEnd()
    if self.binaryVal != None:
      oprot.writeFieldBegin('binaryVal', TType.STRING, -9)
      oprot.writeString(self.binaryVal)
      oprot.writeFieldEnd()
    if self.stringVal != None:
      oprot.writeFieldBegin('stringVal', TType.STRING, -8)
      oprot.writeString(self.stringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.stringVal, bytes) else oprot.writeString(self.stringVal)
      oprot.writeFieldEnd()
    if self.doubleVal != None:
      oprot.writeFieldBegin('doubleVal', TType.DOUBLE, -7)
      oprot.writeDouble(self.doubleVal)
      oprot.writeFieldEnd()
    if self.floatVal != None:
      oprot.writeFieldBegin('floatVal', TType.FLOAT, -6)
      oprot.writeFloat(self.floatVal)
      oprot.writeFieldEnd()
    if self.i64Val != None:
      oprot.writeFieldBegin('i64Val', TType.I64, -5)
      oprot.writeI64(self.i64Val)
      oprot.writeFieldEnd()
    if self.i32Val != None:
      oprot.writeFieldBegin('i32Val', TType.I32, -4)
      oprot.writeI32(self.i32Val)
      oprot.writeFieldEnd()
    if self.i16Val != None:
      oprot.writeFieldBegin('i16Val', TType.I16, -3)
      oprot.writeI16(self.i16Val)
      oprot.writeFieldEnd()
    if self.byteVal != None:
      oprot.writeFieldBegin('byteVal', TType.BYTE, -2)
      oprot.writeByte(self.byteVal)
      oprot.writeFieldEnd()
    if self.boolVal != None:
      oprot.writeFieldBegin('boolVal', TType.BOOL, -1)
      oprot.writeBool(self.boolVal)
      oprot.writeFieldEnd()
    if self.structWithFieldCustomDefault != None:
      oprot.writeFieldBegin('structWithFieldCustomDefault', TType.STRUCT, 1)
      self.structWithFieldCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'structWithCustomDefault' in json_obj and json_obj['structWithCustomDefault'] is not None:
      self.structWithCustomDefault = MyDataWithCustomDefault()
      self.structWithCustomDefault.readFromJson(json_obj['structWithCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i32WithCustomDefault' in json_obj and json_obj['i32WithCustomDefault'] is not None:
      self.i32WithCustomDefault = json_obj['i32WithCustomDefault']
      if self.i32WithCustomDefault > 0x7fffffff or self.i32WithCustomDefault < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'mapMap' in json_obj and json_obj['mapMap'] is not None:
      self.mapMap = dict_cls()
      for _tmp_k810, _tmp_v811 in json_obj['mapMap'].items():
        _tmp_kp812 = _tmp_k810
        _map813 = dict_cls()
        for _tmp_k814, _tmp_v815 in _tmp_v811.items():
          _tmp_kp816 = _tmp_k814
          if _tmp_v815 > 0x7fffffff or _tmp_v815 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map813[_tmp_kp816] = _tmp_v815
        self.mapMap[_tmp_kp812] = _map813
    if 'listMap' in json_obj and json_obj['listMap'] is not None:
      self.listMap = []
      for _tmp_e817 in json_obj['listMap']:
        _map818 = dict_cls()
        for _tmp_k819, _tmp_v820 in _tmp_e817.items():
          _tmp_kp821 = _tmp_k819
          if _tmp_v820 > 0x7fffffff or _tmp_v820 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map818[_tmp_kp821] = _tmp_v820
        self.listMap.append(_map818)
    if 'optMapVal' in json_obj and json_obj['optMapVal'] is not None:
      self.optMapVal = dict_cls()
      for _tmp_k822, _tmp_v823 in json_obj['optMapVal'].items():
        _tmp_kp824 = _tmp_k822
        self.optMapVal[_tmp_kp824] = _tmp_v823
    if 'optSetVal' in json_obj and json_obj['optSetVal'] is not None:
      self.optSetVal = set_cls()
      for _tmp_e825 in json_obj['optSetVal']:
        self.optSetVal.add(_tmp_e825)
    if 'optListVal' in json_obj and json_obj['optListVal'] is not None:
      self.optListVal = []
      for _tmp_e826 in json_obj['optListVal']:
        if _tmp_e826 > 0x7fff or _tmp_e826 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.optListVal.append(_tmp_e826)
    if 'optLateStructVal' in json_obj and json_obj['optLateStructVal'] is not None:
      self.optLateStructVal = LateDefStruct()
      self.optLateStructVal.readFromJson(json_obj['optLateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optStructVal' in json_obj and json_obj['optStructVal'] is not None:
      self.optStructVal = MyData()
      self.optStructVal.readFromJson(json_obj['optStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optEnumVal' in json_obj and json_obj['optEnumVal'] is not None:
      self.optEnumVal = json_obj['optEnumVal']
      if not self.optEnumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.optEnumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'optBinaryVal' in json_obj and json_obj['optBinaryVal'] is not None:
      self.optBinaryVal = json_obj['optBinaryVal']
    if 'optStringVal' in json_obj and json_obj['optStringVal'] is not None:
      self.optStringVal = json_obj['optStringVal']
    if 'optDoubleVal' in json_obj and json_obj['optDoubleVal'] is not None:
      self.optDoubleVal = float(json_obj['optDoubleVal'])
    if 'optFloatVal' in json_obj and json_obj['optFloatVal'] is not None:
      self.optFloatVal = float(json_obj['optFloatVal'])
    if 'optI64Val' in json_obj and json_obj['optI64Val'] is not None:
      self.optI64Val = long(json_obj['optI64Val'])
    if 'optI32Val' in json_obj and json_obj['optI32Val'] is not None:
      self.optI32Val = json_obj['optI32Val']
      if self.optI32Val > 0x7fffffff or self.optI32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI16Val' in json_obj and json_obj['optI16Val'] is not None:
      self.optI16Val = json_obj['optI16Val']
      if self.optI16Val > 0x7fff or self.optI16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optByteVal' in json_obj and json_obj['optByteVal'] is not None:
      self.optByteVal = json_obj['optByteVal']
      if self.optByteVal > 0x7f or self.optByteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optBoolVal' in json_obj and json_obj['optBoolVal'] is not None:
      self.optBoolVal = json_obj['optBoolVal']
    if 'lateStructVal' in json_obj and json_obj['lateStructVal'] is not None:
      self.lateStructVal = LateDefStruct()
      self.lateStructVal.readFromJson(json_obj['lateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'unionVal' in json_obj and json_obj['unionVal'] is not None:
      self.unionVal = MyUnion()
      self.unionVal.readFromJson(json_obj['unionVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structVal' in json_obj and json_obj['structVal'] is not None:
      self.structVal = MyData()
      self.structVal.readFromJson(json_obj['structVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'enumVal' in json_obj and json_obj['enumVal'] is not None:
      self.enumVal = json_obj['enumVal']
      if not self.enumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'binaryVal' in json_obj and json_obj['binaryVal'] is not None:
      self.binaryVal = json_obj['binaryVal']
    if 'stringVal' in json_obj and json_obj['stringVal'] is not None:
      self.stringVal = json_obj['stringVal']
    if 'doubleVal' in json_obj and json_obj['doubleVal'] is not None:
      self.doubleVal = float(json_obj['doubleVal'])
    if 'floatVal' in json_obj and json_obj['floatVal'] is not None:
      self.floatVal = float(json_obj['floatVal'])
    if 'i64Val' in json_obj and json_obj['i64Val'] is not None:
      self.i64Val = long(json_obj['i64Val'])
    if 'i32Val' in json_obj and json_obj['i32Val'] is not None:
      self.i32Val = json_obj['i32Val']
      if self.i32Val > 0x7fffffff or self.i32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i16Val' in json_obj and json_obj['i16Val'] is not None:
      self.i16Val = json_obj['i16Val']
      if self.i16Val > 0x7fff or self.i16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'byteVal' in json_obj and json_obj['byteVal'] is not None:
      self.byteVal = json_obj['byteVal']
      if self.byteVal > 0x7f or self.byteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'boolVal' in json_obj and json_obj['boolVal'] is not None:
      self.boolVal = json_obj['boolVal']
    if 'structWithFieldCustomDefault' in json_obj and json_obj['structWithFieldCustomDefault'] is not None:
      self.structWithFieldCustomDefault = MyData()
      self.structWithFieldCustomDefault.readFromJson(json_obj['structWithFieldCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.structWithCustomDefault is not None:
      value = pprint.pformat(self.structWithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithCustomDefault=%s' % (value))
    if self.i32WithCustomDefault is not None:
      value = pprint.pformat(self.i32WithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32WithCustomDefault=%s' % (value))
    if self.mapMap is not None:
      value = pprint.pformat(self.mapMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapMap=%s' % (value))
    if self.listMap is not None:
      value = pprint.pformat(self.listMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    listMap=%s' % (value))
    if self.optMapVal is not None:
      value = pprint.pformat(self.optMapVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optMapVal=%s' % (value))
    if self.optSetVal is not None:
      value = pprint.pformat(self.optSetVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optSetVal=%s' % (value))
    if self.optListVal is not None:
      value = pprint.pformat(self.optListVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optListVal=%s' % (value))
    if self.optLateStructVal is not None:
      value = pprint.pformat(self.optLateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optLateStructVal=%s' % (value))
    if self.optStructVal is not None:
      value = pprint.pformat(self.optStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStructVal=%s' % (value))
    if self.optEnumVal is not None:
      value = pprint.pformat(self.optEnumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optEnumVal=%s' % (value))
    if self.optBinaryVal is not None:
      value = pprint.pformat(self.optBinaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBinaryVal=%s' % (value))
    if self.optStringVal is not None:
      value = pprint.pformat(self.optStringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStringVal=%s' % (value))
    if self.optDoubleVal is not None:
      value = pprint.pformat(self.optDoubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optDoubleVal=%s' % (value))
    if self.optFloatVal is not None:
      value = pprint.pformat(self.optFloatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optFloatVal=%s' % (value))
    if self.optI64Val is not None:
      value = pprint.pformat(self.optI64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI64Val=%s' % (value))
    if self.optI32Val is not None:
      value = pprint.pformat(self.optI32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI32Val=%s' % (value))
    if self.optI16Val is not None:
      value = pprint.pformat(self.optI16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI16Val=%s' % (value))
    if self.optByteVal is not None:
      value = pprint.pformat(self.optByteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optByteVal=%s' % (value))
    if self.optBoolVal is not None:
      value = pprint.pformat(self.optBoolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBoolVal=%s' % (value))
    if self.lateStructVal is not None:
      value = pprint.pformat(self.lateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lateStructVal=%s' % (value))
    if self.unionVal is not None:
      value = pprint.pformat(self.unionVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionVal=%s' % (value))
    if self.structVal is not None:
      value = pprint.pformat(self.structVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structVal=%s' % (value))
    if self.enumVal is not None:
      value = pprint.pformat(self.enumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enumVal=%s' % (value))
    if self.binaryVal is not None:
      value = pprint.pformat(self.binaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryVal=%s' % (value))
    if self.stringVal is not None:
      value = pprint.pformat(self.stringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stringVal=%s' % (value))
    if self.doubleVal is not None:
      value = pprint.pformat(self.doubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleVal=%s' % (value))
    if self.floatVal is not None:
      value = pprint.pformat(self.floatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    floatVal=%s' % (value))
    if self.i64Val is not None:
      value = pprint.pformat(self.i64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i64Val=%s' % (value))
    if self.i32Val is not None:
      value = pprint.pformat(self.i32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32Val=%s' % (value))
    if self.i16Val is not None:
      value = pprint.pformat(self.i16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i16Val=%s' % (value))
    if self.byteVal is not None:
      value = pprint.pformat(self.byteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byteVal=%s' % (value))
    if self.boolVal is not None:
      value = pprint.pformat(self.boolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    boolVal=%s' % (value))
    if self.structWithFieldCustomDefault is not None:
      value = pprint.pformat(self.structWithFieldCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithFieldCustomDefault=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'structWithCustomDefault',
      'i32WithCustomDefault',
      'mapMap',
      'listMap',
      'optMapVal',
      'optSetVal',
      'optListVal',
      'optLateStructVal',
      'optStructVal',
      'optEnumVal',
      'optBinaryVal',
      'optStringVal',
      'optDoubleVal',
      'optFloatVal',
      'optI64Val',
      'optI32Val',
      'optI16Val',
      'optByteVal',
      'optBoolVal',
      'lateStructVal',
      'unionVal',
      'structVal',
      'enumVal',
      'binaryVal',
      'stringVal',
      'doubleVal',
      'floatVal',
      'i64Val',
      'i32Val',
      'i16Val',
      'byteVal',
      'boolVal',
      'structWithFieldCustomDefault',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class LateDefStructPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = LateDefStruct()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = LateDefStructFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = LateDefStructEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = LateDefStructFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype830, _size827) = iprot.readSetBegin()
          if _size827 >= 0:
            for _i831 in range(_size827):
              _elem832 = iprot.readI16()
              self.remove.add(_elem832)
          else: 
            while iprot.peekSet():
              _elem833 = iprot.readI16()
              self.remove.add(_elem833)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LateDefStructPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.I16, len(self.remove))
      for iter834 in self.remove:
        oprot.writeI16(iter834)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = LateDefStruct()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = LateDefStructFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = LateDefStructEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = LateDefStructFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e835 in json_obj['remove']:
        if _tmp_e835 > 0x7fff or _tmp_e835 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.remove.add(_tmp_e835)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
      'remove',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LateDefStructPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LateDefStructPatch, self)

  def _to_py_deprecated(self):
    return self

class LateDefStructFieldPatch:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LateDefStructFieldPatch')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LateDefStructFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LateDefStructFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class LateDefStructEnsureStruct:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LateDefStructEnsureStruct')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LateDefStructEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LateDefStructEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class RecursivePatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = Recursive()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = RecursiveFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = RecursiveEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = RecursiveFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype839, _size836) = iprot.readSetBegin()
          if _size836 >= 0:
            for _i840 in range(_size836):
              _elem841 = iprot.readI16()
              self.remove.add(_elem841)
          else: 
            while iprot.peekSet():
              _elem842 = iprot.readI16()
              self.remove.add(_elem842)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RecursivePatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.I16, len(self.remove))
      for iter843 in self.remove:
        oprot.writeI16(iter843)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = Recursive()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = RecursiveFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = RecursiveEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = RecursiveFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e844 in json_obj['remove']:
        if _tmp_e844 > 0x7fff or _tmp_e844 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.remove.add(_tmp_e844)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
      'remove',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RecursivePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RecursivePatch, self)

  def _to_py_deprecated(self):
    return self

class RecursiveField1Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype846, _vtype847, _size845 ) = iprot.readMapBegin() 
          if _size845 >= 0:
            for _i849 in range(_size845):
              _key850 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val851 = Recursive()
              _val851.read(iprot)
              self.assign[_key850] = _val851
          else: 
            while iprot.peekMap():
              _key852 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val853 = Recursive()
              _val853.read(iprot)
              self.assign[_key852] = _val853
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RecursiveField1Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.assign))
      for kiter854,viter855 in self.assign.items():
        oprot.writeString(kiter854.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter854, bytes) else oprot.writeString(kiter854)
        viter855.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k856, _tmp_v857 in json_obj['assign'].items():
        _tmp_kp858 = _tmp_k856
        _struct859 = Recursive()
        _struct859.readFromJson(_tmp_v857, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.assign[_tmp_kp858] = _struct859
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RecursiveField1Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RecursiveField1Patch, self)

  def _to_py_deprecated(self):
    return self

class RecursiveFieldPatch:
  r"""
  Attributes:
   - nodes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.nodes = RecursiveField1Patch()
          self.nodes.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RecursiveFieldPatch')
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.STRUCT, -1)
      self.nodes.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'nodes' in json_obj and json_obj['nodes'] is not None:
      self.nodes = RecursiveField1Patch()
      self.nodes.readFromJson(json_obj['nodes'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.nodes is not None:
      value = pprint.pformat(self.nodes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nodes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'nodes',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RecursiveFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RecursiveFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class RecursiveEnsureStruct:
  r"""
  Attributes:
   - nodes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.MAP:
          self.nodes = {}
          (_ktype861, _vtype862, _size860 ) = iprot.readMapBegin() 
          if _size860 >= 0:
            for _i864 in range(_size860):
              _key865 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val866 = Recursive()
              _val866.read(iprot)
              self.nodes[_key865] = _val866
          else: 
            while iprot.peekMap():
              _key867 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val868 = Recursive()
              _val868.read(iprot)
              self.nodes[_key867] = _val868
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RecursiveEnsureStruct')
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.MAP, -1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.nodes))
      for kiter869,viter870 in self.nodes.items():
        oprot.writeString(kiter869.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter869, bytes) else oprot.writeString(kiter869)
        viter870.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'nodes' in json_obj and json_obj['nodes'] is not None:
      self.nodes = dict_cls()
      for _tmp_k871, _tmp_v872 in json_obj['nodes'].items():
        _tmp_kp873 = _tmp_k871
        _struct874 = Recursive()
        _struct874.readFromJson(_tmp_v872, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.nodes[_tmp_kp873] = _struct874

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.nodes is not None:
      value = pprint.pformat(self.nodes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nodes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'nodes',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RecursiveEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RecursiveEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class BarPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = Bar()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = BarFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = BarEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = BarFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype878, _size875) = iprot.readSetBegin()
          if _size875 >= 0:
            for _i879 in range(_size875):
              _elem880 = iprot.readI16()
              self.remove.add(_elem880)
          else: 
            while iprot.peekSet():
              _elem881 = iprot.readI16()
              self.remove.add(_elem881)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BarPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.I16, len(self.remove))
      for iter882 in self.remove:
        oprot.writeI16(iter882)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = Bar()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = BarFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = BarEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = BarFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e883 in json_obj['remove']:
        if _tmp_e883 > 0x7fff or _tmp_e883 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.remove.add(_tmp_e883)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
      'remove',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BarPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BarPatch, self)

  def _to_py_deprecated(self):
    return self

class BarFieldPatch:
  r"""
  Attributes:
   - loop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.loop = LoopPatch()
          self.loop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BarFieldPatch')
    if self.loop != None:
      oprot.writeFieldBegin('loop', TType.STRUCT, -1)
      self.loop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'loop' in json_obj and json_obj['loop'] is not None:
      self.loop = LoopPatch()
      self.loop.readFromJson(json_obj['loop'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.loop is not None:
      value = pprint.pformat(self.loop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    loop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'loop',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BarFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BarFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class BarEnsureStruct:
  r"""
  Attributes:
   - loop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.loop = Loop()
          self.loop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BarEnsureStruct')
    if self.loop != None:
      oprot.writeFieldBegin('loop', TType.STRUCT, -1)
      self.loop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'loop' in json_obj and json_obj['loop'] is not None:
      self.loop = Loop()
      self.loop.readFromJson(json_obj['loop'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.loop is not None:
      value = pprint.pformat(self.loop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    loop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'loop',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BarEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BarEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class LoopPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = Loop()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LoopPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = Loop()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LoopPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LoopPatch, self)

  def _to_py_deprecated(self):
    return self

all_structs.append(MyData)
MyData.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'data1', True, None, 3, ), # 1
  (2, TType.I32, 'data2', None, None, 3, ), # 2
)

MyData.thrift_struct_annotations = {
}
MyData.thrift_field_annotations = {
}

def MyData__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyData.__init__ = MyData__init__

def MyData__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyData.__getstate__ = lambda self: self.__dict__.copy()
MyData.__setstate__ = MyData__setstate__

all_structs.append(MyDataWithCustomDefault)
MyDataWithCustomDefault.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'data1', True, "1", 3, ), # 1
  (2, TType.I32, 'data2', None, 2, 3, ), # 2
)

MyDataWithCustomDefault.thrift_struct_annotations = {
}
MyDataWithCustomDefault.thrift_field_annotations = {
}

def MyDataWithCustomDefault__init__(self, data1=MyDataWithCustomDefault.thrift_spec[1][4], data2=MyDataWithCustomDefault.thrift_spec[2][4],):
  self.data1 = data1
  self.data2 = data2

MyDataWithCustomDefault.__init__ = MyDataWithCustomDefault__init__

def MyDataWithCustomDefault__setstate__(self, state):
  state.setdefault('data1', "1")
  state.setdefault('data2', 2)
  self.__dict__ = state

MyDataWithCustomDefault.__getstate__ = lambda self: self.__dict__.copy()
MyDataWithCustomDefault.__setstate__ = MyDataWithCustomDefault__setstate__

all_structs.append(InnerUnion)
InnerUnion.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'innerOption', False, None, 2, ), # 1
)

InnerUnion.thrift_struct_annotations = {
}
InnerUnion.thrift_field_annotations = {
}

def InnerUnion__init__(self, innerOption=None,):
  self.field = 0
  self.value = None
  if innerOption is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = innerOption

InnerUnion.__init__ = InnerUnion__init__

all_structs.append(MyUnion)
MyUnion.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'option1', True, None, 2, ), # 1
  (2, TType.I32, 'option2', None, None, 2, ), # 2
  (3, TType.STRUCT, 'option3', [InnerUnion, InnerUnion.thrift_spec, True], None, 2, ), # 3
)

MyUnion.thrift_struct_annotations = {
}
MyUnion.thrift_field_annotations = {
}

def MyUnion__init__(self, option1=None, option2=None, option3=None,):
  self.field = 0
  self.value = None
  if option1 is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = option1
  if option2 is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = option2
  if option3 is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = option3

MyUnion.__init__ = MyUnion__init__

all_structs.append(MyStruct)
MyStruct.thrift_spec = (
  (-32, TType.STRUCT, 'structWithCustomDefault', [MyDataWithCustomDefault, MyDataWithCustomDefault.thrift_spec, False], None, 3, ), # -32
  (-31, TType.I32, 'i32WithCustomDefault', None, 1, 3, ), # -31
  (-30, TType.MAP, 'mapMap', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # -30
  (-29, TType.LIST, 'listMap', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # -29
  (-28, TType.MAP, 'optMapVal', (TType.STRING,True,TType.STRING,True), None, 1, ), # -28
  (-27, TType.SET, 'optSetVal', (TType.STRING,True), None, 1, ), # -27
  (-26, TType.LIST, 'optListVal', (TType.I16,None), None, 1, ), # -26
  (-25, TType.STRUCT, 'optLateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 1, ), # -25
  (-24, TType.STRUCT, 'optStructVal', [MyData, MyData.thrift_spec, False], None, 1, ), # -24
  (-23, TType.I32, 'optEnumVal', MyEnum, None, 1, ), # -23
  (-22, TType.STRING, 'optBinaryVal', False, None, 1, ), # -22
  (-21, TType.STRING, 'optStringVal', True, None, 1, ), # -21
  (-20, TType.DOUBLE, 'optDoubleVal', None, None, 1, ), # -20
  (-19, TType.FLOAT, 'optFloatVal', None, None, 1, ), # -19
  (-18, TType.I64, 'optI64Val', None, None, 1, ), # -18
  (-17, TType.I32, 'optI32Val', None, None, 1, ), # -17
  (-16, TType.I16, 'optI16Val', None, None, 1, ), # -16
  (-15, TType.BYTE, 'optByteVal', None, None, 1, ), # -15
  (-14, TType.BOOL, 'optBoolVal', None, None, 1, ), # -14
  (-13, TType.STRUCT, 'lateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 3, ), # -13
  (-12, TType.STRUCT, 'unionVal', [MyUnion, MyUnion.thrift_spec, True], None, 3, ), # -12
  (-11, TType.STRUCT, 'structVal', [MyData, MyData.thrift_spec, False], None, 3, ), # -11
  (-10, TType.I32, 'enumVal', MyEnum, None, 3, ), # -10
  (-9, TType.STRING, 'binaryVal', False, None, 3, ), # -9
  (-8, TType.STRING, 'stringVal', True, None, 3, ), # -8
  (-7, TType.DOUBLE, 'doubleVal', None, None, 3, ), # -7
  (-6, TType.FLOAT, 'floatVal', None, None, 3, ), # -6
  (-5, TType.I64, 'i64Val', None, None, 3, ), # -5
  (-4, TType.I32, 'i32Val', None, None, 3, ), # -4
  (-3, TType.I16, 'i16Val', None, None, 3, ), # -3
  (-2, TType.BYTE, 'byteVal', None, None, 3, ), # -2
  (-1, TType.BOOL, 'boolVal', None, None, 3, ), # -1
  None, # 0
  (1, TType.STRUCT, 'structWithFieldCustomDefault', [MyData, MyData.thrift_spec, False], MyData(**{
    "data1" : "1",
    "data2" : 2,
  }), 3, ), # 1
)

MyStruct.thrift_struct_annotations = {
}
MyStruct.thrift_field_annotations = {
}

def MyStruct__init__(self, boolVal=None, byteVal=None, i16Val=None, i32Val=None, i64Val=None, floatVal=None, doubleVal=None, stringVal=None, binaryVal=None, enumVal=None, structVal=None, unionVal=None, lateStructVal=None, optBoolVal=None, optByteVal=None, optI16Val=None, optI32Val=None, optI64Val=None, optFloatVal=None, optDoubleVal=None, optStringVal=None, optBinaryVal=None, optEnumVal=None, optStructVal=None, optLateStructVal=None, optListVal=None, optSetVal=None, optMapVal=None, listMap=None, mapMap=None, i32WithCustomDefault=MyStruct.thrift_spec[1][4], structWithCustomDefault=None, structWithFieldCustomDefault=MyStruct.thrift_spec[33][4],):
  self.boolVal = boolVal
  self.byteVal = byteVal
  self.i16Val = i16Val
  self.i32Val = i32Val
  self.i64Val = i64Val
  self.floatVal = floatVal
  self.doubleVal = doubleVal
  self.stringVal = stringVal
  self.binaryVal = binaryVal
  self.enumVal = enumVal
  self.structVal = structVal
  self.unionVal = unionVal
  self.lateStructVal = lateStructVal
  self.optBoolVal = optBoolVal
  self.optByteVal = optByteVal
  self.optI16Val = optI16Val
  self.optI32Val = optI32Val
  self.optI64Val = optI64Val
  self.optFloatVal = optFloatVal
  self.optDoubleVal = optDoubleVal
  self.optStringVal = optStringVal
  self.optBinaryVal = optBinaryVal
  self.optEnumVal = optEnumVal
  self.optStructVal = optStructVal
  self.optLateStructVal = optLateStructVal
  self.optListVal = optListVal
  self.optSetVal = optSetVal
  self.optMapVal = optMapVal
  self.listMap = listMap
  self.mapMap = mapMap
  self.i32WithCustomDefault = i32WithCustomDefault
  self.structWithCustomDefault = structWithCustomDefault
  if structWithFieldCustomDefault is self.thrift_spec[33][4]:
    structWithFieldCustomDefault = MyData(**{
    "data1" : "1",
    "data2" : 2,
  })
  self.structWithFieldCustomDefault = structWithFieldCustomDefault

MyStruct.__init__ = MyStruct__init__

def MyStruct__setstate__(self, state):
  state.setdefault('boolVal', None)
  state.setdefault('byteVal', None)
  state.setdefault('i16Val', None)
  state.setdefault('i32Val', None)
  state.setdefault('i64Val', None)
  state.setdefault('floatVal', None)
  state.setdefault('doubleVal', None)
  state.setdefault('stringVal', None)
  state.setdefault('binaryVal', None)
  state.setdefault('enumVal', None)
  state.setdefault('structVal', None)
  state.setdefault('unionVal', None)
  state.setdefault('lateStructVal', None)
  state.setdefault('optBoolVal', None)
  state.setdefault('optByteVal', None)
  state.setdefault('optI16Val', None)
  state.setdefault('optI32Val', None)
  state.setdefault('optI64Val', None)
  state.setdefault('optFloatVal', None)
  state.setdefault('optDoubleVal', None)
  state.setdefault('optStringVal', None)
  state.setdefault('optBinaryVal', None)
  state.setdefault('optEnumVal', None)
  state.setdefault('optStructVal', None)
  state.setdefault('optLateStructVal', None)
  state.setdefault('optListVal', None)
  state.setdefault('optSetVal', None)
  state.setdefault('optMapVal', None)
  state.setdefault('listMap', None)
  state.setdefault('mapMap', None)
  state.setdefault('i32WithCustomDefault', 1)
  state.setdefault('structWithCustomDefault', None)
  state.setdefault('structWithFieldCustomDefault', MyData(**{
    "data1" : "1",
    "data2" : 2,
  }))
  self.__dict__ = state

MyStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStruct.__setstate__ = MyStruct__setstate__

all_structs.append(LateDefStruct)
LateDefStruct.thrift_spec = (
)

LateDefStruct.thrift_struct_annotations = {
}
LateDefStruct.thrift_field_annotations = {
}

all_structs.append(Recursive)
Recursive.thrift_spec = (
  (-1, TType.MAP, 'nodes', (TType.STRING,True,TType.STRUCT,[Recursive, Recursive.thrift_spec, False]), None, 3, ), # -1
)

Recursive.thrift_struct_annotations = {
}
Recursive.thrift_field_annotations = {
}

def Recursive__init__(self, nodes=None,):
  self.nodes = nodes

Recursive.__init__ = Recursive__init__

def Recursive__setstate__(self, state):
  state.setdefault('nodes', None)
  self.__dict__ = state

Recursive.__getstate__ = lambda self: self.__dict__.copy()
Recursive.__setstate__ = Recursive__setstate__

all_structs.append(Bar)
Bar.thrift_spec = (
  (-1, TType.STRUCT, 'loop', [Loop, Loop.thrift_spec, False], None, 3, ), # -1
)

Bar.thrift_struct_annotations = {
}
Bar.thrift_field_annotations = {
  -1: {
    "cpp.ref": "1",
  },
}

def Bar__init__(self, loop=None,):
  self.loop = loop

Bar.__init__ = Bar__init__

def Bar__setstate__(self, state):
  state.setdefault('loop', None)
  self.__dict__ = state

Bar.__getstate__ = lambda self: self.__dict__.copy()
Bar.__setstate__ = Bar__setstate__

all_structs.append(Loop)
Loop.thrift_spec = (
  (-1, TType.STRUCT, 'bar', [Bar, Bar.thrift_spec, False], None, 3, ), # -1
)

Loop.thrift_struct_annotations = {
}
Loop.thrift_field_annotations = {
}

def Loop__init__(self, bar=None,):
  self.bar = bar

Loop.__init__ = Loop__init__

def Loop__setstate__(self, state):
  state.setdefault('bar', None)
  self.__dict__ = state

Loop.__getstate__ = lambda self: self.__dict__.copy()
Loop.__setstate__ = Loop__setstate__

all_structs.append(MyDataPatch)
MyDataPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyData, MyData.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyDataFieldPatch, MyDataFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [MyDataEnsureStruct, MyDataEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [MyDataFieldPatch, MyDataFieldPatch.thrift_spec, False], None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.I16,None), None, 3, ), # 7
)

MyDataPatch.thrift_struct_annotations = {
}
MyDataPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyDataPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None, remove=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch
  self.remove = remove

MyDataPatch.__init__ = MyDataPatch__init__

def MyDataPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  self.__dict__ = state

MyDataPatch.__getstate__ = lambda self: self.__dict__.copy()
MyDataPatch.__setstate__ = MyDataPatch__setstate__

all_structs.append(MyDataFieldPatch)
MyDataFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'data1', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # 1
  (2, TType.STRUCT, 'data2', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # 2
)

MyDataFieldPatch.thrift_struct_annotations = {
}
MyDataFieldPatch.thrift_field_annotations = {
}

def MyDataFieldPatch__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyDataFieldPatch.__init__ = MyDataFieldPatch__init__

def MyDataFieldPatch__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyDataFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyDataFieldPatch.__setstate__ = MyDataFieldPatch__setstate__

all_structs.append(MyDataEnsureStruct)
MyDataEnsureStruct.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'data1', True, None, 1, ), # 1
  (2, TType.I32, 'data2', None, None, 1, ), # 2
)

MyDataEnsureStruct.thrift_struct_annotations = {
}
MyDataEnsureStruct.thrift_field_annotations = {
}

def MyDataEnsureStruct__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyDataEnsureStruct.__init__ = MyDataEnsureStruct__init__

def MyDataEnsureStruct__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyDataEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
MyDataEnsureStruct.__setstate__ = MyDataEnsureStruct__setstate__

all_structs.append(MyDataWithCustomDefaultPatch)
MyDataWithCustomDefaultPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyDataWithCustomDefault, MyDataWithCustomDefault.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyDataWithCustomDefaultFieldPatch, MyDataWithCustomDefaultFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [MyDataWithCustomDefaultEnsureStruct, MyDataWithCustomDefaultEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [MyDataWithCustomDefaultFieldPatch, MyDataWithCustomDefaultFieldPatch.thrift_spec, False], None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.I16,None), None, 3, ), # 7
)

MyDataWithCustomDefaultPatch.thrift_struct_annotations = {
}
MyDataWithCustomDefaultPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyDataWithCustomDefaultPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None, remove=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch
  self.remove = remove

MyDataWithCustomDefaultPatch.__init__ = MyDataWithCustomDefaultPatch__init__

def MyDataWithCustomDefaultPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  self.__dict__ = state

MyDataWithCustomDefaultPatch.__getstate__ = lambda self: self.__dict__.copy()
MyDataWithCustomDefaultPatch.__setstate__ = MyDataWithCustomDefaultPatch__setstate__

all_structs.append(MyDataWithCustomDefaultFieldPatch)
MyDataWithCustomDefaultFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'data1', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # 1
  (2, TType.STRUCT, 'data2', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # 2
)

MyDataWithCustomDefaultFieldPatch.thrift_struct_annotations = {
}
MyDataWithCustomDefaultFieldPatch.thrift_field_annotations = {
}

def MyDataWithCustomDefaultFieldPatch__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyDataWithCustomDefaultFieldPatch.__init__ = MyDataWithCustomDefaultFieldPatch__init__

def MyDataWithCustomDefaultFieldPatch__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyDataWithCustomDefaultFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyDataWithCustomDefaultFieldPatch.__setstate__ = MyDataWithCustomDefaultFieldPatch__setstate__

all_structs.append(MyDataWithCustomDefaultEnsureStruct)
MyDataWithCustomDefaultEnsureStruct.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'data1', True, None, 1, ), # 1
  (2, TType.I32, 'data2', None, None, 1, ), # 2
)

MyDataWithCustomDefaultEnsureStruct.thrift_struct_annotations = {
}
MyDataWithCustomDefaultEnsureStruct.thrift_field_annotations = {
}

def MyDataWithCustomDefaultEnsureStruct__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyDataWithCustomDefaultEnsureStruct.__init__ = MyDataWithCustomDefaultEnsureStruct__init__

def MyDataWithCustomDefaultEnsureStruct__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyDataWithCustomDefaultEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
MyDataWithCustomDefaultEnsureStruct.__setstate__ = MyDataWithCustomDefaultEnsureStruct__setstate__

all_structs.append(InnerUnionPatch)
InnerUnionPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [InnerUnion, InnerUnion.thrift_spec, True], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [InnerUnionFieldPatch, InnerUnionFieldPatch.thrift_spec, False], None, 3, ), # 3
  (4, TType.STRUCT, 'ensure', [InnerUnion, InnerUnion.thrift_spec, True], None, 3, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [InnerUnionFieldPatch, InnerUnionFieldPatch.thrift_spec, False], None, 3, ), # 6
)

InnerUnionPatch.thrift_struct_annotations = {
}
InnerUnionPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def InnerUnionPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

InnerUnionPatch.__init__ = InnerUnionPatch__init__

def InnerUnionPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

InnerUnionPatch.__getstate__ = lambda self: self.__dict__.copy()
InnerUnionPatch.__setstate__ = InnerUnionPatch__setstate__

all_structs.append(InnerUnionFieldPatch)
InnerUnionFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'innerOption', [thrift.lib.thrift.patch.ttypes.BinaryPatch, thrift.lib.thrift.patch.ttypes.BinaryPatch.thrift_spec, False], None, 3, ), # 1
)

InnerUnionFieldPatch.thrift_struct_annotations = {
}
InnerUnionFieldPatch.thrift_field_annotations = {
}

def InnerUnionFieldPatch__init__(self, innerOption=None,):
  self.innerOption = innerOption

InnerUnionFieldPatch.__init__ = InnerUnionFieldPatch__init__

def InnerUnionFieldPatch__setstate__(self, state):
  state.setdefault('innerOption', None)
  self.__dict__ = state

InnerUnionFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
InnerUnionFieldPatch.__setstate__ = InnerUnionFieldPatch__setstate__

all_structs.append(MyUnionPatch)
MyUnionPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyUnion, MyUnion.thrift_spec, True], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyUnionFieldPatch, MyUnionFieldPatch.thrift_spec, False], None, 3, ), # 3
  (4, TType.STRUCT, 'ensure', [MyUnion, MyUnion.thrift_spec, True], None, 3, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [MyUnionFieldPatch, MyUnionFieldPatch.thrift_spec, False], None, 3, ), # 6
)

MyUnionPatch.thrift_struct_annotations = {
}
MyUnionPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyUnionPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

MyUnionPatch.__init__ = MyUnionPatch__init__

def MyUnionPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

MyUnionPatch.__getstate__ = lambda self: self.__dict__.copy()
MyUnionPatch.__setstate__ = MyUnionPatch__setstate__

all_structs.append(MyUnionFieldPatch)
MyUnionFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'option1', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # 1
  (2, TType.STRUCT, 'option2', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # 2
  (3, TType.STRUCT, 'option3', [InnerUnionPatch, InnerUnionPatch.thrift_spec, False], None, 3, ), # 3
)

MyUnionFieldPatch.thrift_struct_annotations = {
}
MyUnionFieldPatch.thrift_field_annotations = {
}

def MyUnionFieldPatch__init__(self, option1=None, option2=None, option3=None,):
  self.option1 = option1
  self.option2 = option2
  self.option3 = option3

MyUnionFieldPatch.__init__ = MyUnionFieldPatch__init__

def MyUnionFieldPatch__setstate__(self, state):
  state.setdefault('option1', None)
  state.setdefault('option2', None)
  state.setdefault('option3', None)
  self.__dict__ = state

MyUnionFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyUnionFieldPatch.__setstate__ = MyUnionFieldPatch__setstate__

all_structs.append(MyStructPatch)
MyStructPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyStruct, MyStruct.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyStructFieldPatch, MyStructFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [MyStructEnsureStruct, MyStructEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [MyStructFieldPatch, MyStructFieldPatch.thrift_spec, False], None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.I16,None), None, 3, ), # 7
)

MyStructPatch.thrift_struct_annotations = {
}
MyStructPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyStructPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None, remove=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch
  self.remove = remove

MyStructPatch.__init__ = MyStructPatch__init__

def MyStructPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  self.__dict__ = state

MyStructPatch.__getstate__ = lambda self: self.__dict__.copy()
MyStructPatch.__setstate__ = MyStructPatch__setstate__

all_structs.append(MyStructField10Patch)
MyStructField10Patch.thrift_spec = (
  None, # 0
  (1, TType.I32, 'assign', MyEnum, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
)

MyStructField10Patch.thrift_struct_annotations = {
}
MyStructField10Patch.thrift_field_annotations = {
}

def MyStructField10Patch__init__(self, assign=None, clear=None,):
  self.assign = assign
  self.clear = clear

MyStructField10Patch.__init__ = MyStructField10Patch__init__

def MyStructField10Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  self.__dict__ = state

MyStructField10Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField10Patch.__setstate__ = MyStructField10Patch__setstate__

all_structs.append(MyStructField23Patch)
MyStructField23Patch.thrift_spec = (
  None, # 0
  (1, TType.I32, 'assign', MyEnum, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
)

MyStructField23Patch.thrift_struct_annotations = {
}
MyStructField23Patch.thrift_field_annotations = {
}

def MyStructField23Patch__init__(self, assign=None, clear=None,):
  self.assign = assign
  self.clear = clear

MyStructField23Patch.__init__ = MyStructField23Patch__init__

def MyStructField23Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  self.__dict__ = state

MyStructField23Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField23Patch.__setstate__ = MyStructField23Patch__setstate__

all_structs.append(MyStructField26Patch)
MyStructField26Patch.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'assign', (TType.I16,None), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patch', (TType.I32,None,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I16Patch, thrift.lib.thrift.patch.ttypes.I16Patch.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.LIST, 'prepend', (TType.I16,None), None, 3, ), # 8
  (9, TType.LIST, 'append', (TType.I16,None), None, 3, ), # 9
)

MyStructField26Patch.thrift_struct_annotations = {
}
MyStructField26Patch.thrift_field_annotations = {
}

def MyStructField26Patch__init__(self, assign=None, clear=None, patch=None, prepend=None, append=None,):
  self.assign = assign
  self.clear = clear
  self.patch = patch
  self.prepend = prepend
  self.append = append

MyStructField26Patch.__init__ = MyStructField26Patch__init__

def MyStructField26Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patch', None)
  state.setdefault('prepend', None)
  state.setdefault('append', None)
  self.__dict__ = state

MyStructField26Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField26Patch.__setstate__ = MyStructField26Patch__setstate__

all_structs.append(MyStructField27Patch)
MyStructField27Patch.thrift_spec = (
  None, # 0
  (1, TType.SET, 'assign', (TType.STRING,True), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  (8, TType.SET, 'add', (TType.STRING,True), None, 3, ), # 8
)

MyStructField27Patch.thrift_struct_annotations = {
}
MyStructField27Patch.thrift_field_annotations = {
}

def MyStructField27Patch__init__(self, assign=None, clear=None, remove=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.remove = remove
  self.add = add

MyStructField27Patch.__init__ = MyStructField27Patch__init__

def MyStructField27Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('remove', None)
  state.setdefault('add', None)
  self.__dict__ = state

MyStructField27Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField27Patch.__setstate__ = MyStructField27Patch__setstate__

all_structs.append(MyStructField28Patch)
MyStructField28Patch.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.STRING,True), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patchPrior', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  (5, TType.MAP, 'add', (TType.STRING,True,TType.STRING,True), None, 3, ), # 5
  (6, TType.MAP, 'patch', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False]), None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  None, # 8
  (9, TType.MAP, 'put', (TType.STRING,True,TType.STRING,True), None, 3, ), # 9
)

MyStructField28Patch.thrift_struct_annotations = {
}
MyStructField28Patch.thrift_field_annotations = {
}

def MyStructField28Patch__init__(self, assign=None, clear=None, patchPrior=None, add=None, patch=None, remove=None, put=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.add = add
  self.patch = patch
  self.remove = remove
  self.put = put

MyStructField28Patch.__init__ = MyStructField28Patch__init__

def MyStructField28Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('add', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('put', None)
  self.__dict__ = state

MyStructField28Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField28Patch.__setstate__ = MyStructField28Patch__setstate__

all_structs.append(MyStructField29Patch)
MyStructField29Patch.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'assign', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patch', (TType.I32,None,TType.STRUCT,[MyStructField29Patch1, MyStructField29Patch1.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.LIST, 'prepend', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 8
  (9, TType.LIST, 'append', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 9
)

MyStructField29Patch.thrift_struct_annotations = {
}
MyStructField29Patch.thrift_field_annotations = {
}

def MyStructField29Patch__init__(self, assign=None, clear=None, patch=None, prepend=None, append=None,):
  self.assign = assign
  self.clear = clear
  self.patch = patch
  self.prepend = prepend
  self.append = append

MyStructField29Patch.__init__ = MyStructField29Patch__init__

def MyStructField29Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patch', None)
  state.setdefault('prepend', None)
  state.setdefault('append', None)
  self.__dict__ = state

MyStructField29Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField29Patch.__setstate__ = MyStructField29Patch__setstate__

all_structs.append(MyStructField29Patch1)
MyStructField29Patch1.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.I32,None), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patchPrior', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  (5, TType.MAP, 'add', (TType.STRING,True,TType.I32,None), None, 3, ), # 5
  (6, TType.MAP, 'patch', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False]), None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  None, # 8
  (9, TType.MAP, 'put', (TType.STRING,True,TType.I32,None), None, 3, ), # 9
)

MyStructField29Patch1.thrift_struct_annotations = {
}
MyStructField29Patch1.thrift_field_annotations = {
}

def MyStructField29Patch1__init__(self, assign=None, clear=None, patchPrior=None, add=None, patch=None, remove=None, put=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.add = add
  self.patch = patch
  self.remove = remove
  self.put = put

MyStructField29Patch1.__init__ = MyStructField29Patch1__init__

def MyStructField29Patch1__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('add', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('put', None)
  self.__dict__ = state

MyStructField29Patch1.__getstate__ = lambda self: self.__dict__.copy()
MyStructField29Patch1.__setstate__ = MyStructField29Patch1__setstate__

all_structs.append(MyStructField30Patch)
MyStructField30Patch.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patchPrior', (TType.STRING,True,TType.STRUCT,[MyStructField30Patch1, MyStructField30Patch1.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  (5, TType.MAP, 'add', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 5
  (6, TType.MAP, 'patch', (TType.STRING,True,TType.STRUCT,[MyStructField30Patch1, MyStructField30Patch1.thrift_spec, False]), None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  None, # 8
  (9, TType.MAP, 'put', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 9
)

MyStructField30Patch.thrift_struct_annotations = {
}
MyStructField30Patch.thrift_field_annotations = {
}

def MyStructField30Patch__init__(self, assign=None, clear=None, patchPrior=None, add=None, patch=None, remove=None, put=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.add = add
  self.patch = patch
  self.remove = remove
  self.put = put

MyStructField30Patch.__init__ = MyStructField30Patch__init__

def MyStructField30Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('add', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('put', None)
  self.__dict__ = state

MyStructField30Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField30Patch.__setstate__ = MyStructField30Patch__setstate__

all_structs.append(MyStructField30Patch1)
MyStructField30Patch1.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.I32,None), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patchPrior', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  (5, TType.MAP, 'add', (TType.STRING,True,TType.I32,None), None, 3, ), # 5
  (6, TType.MAP, 'patch', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False]), None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  None, # 8
  (9, TType.MAP, 'put', (TType.STRING,True,TType.I32,None), None, 3, ), # 9
)

MyStructField30Patch1.thrift_struct_annotations = {
}
MyStructField30Patch1.thrift_field_annotations = {
}

def MyStructField30Patch1__init__(self, assign=None, clear=None, patchPrior=None, add=None, patch=None, remove=None, put=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.add = add
  self.patch = patch
  self.remove = remove
  self.put = put

MyStructField30Patch1.__init__ = MyStructField30Patch1__init__

def MyStructField30Patch1__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('add', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('put', None)
  self.__dict__ = state

MyStructField30Patch1.__getstate__ = lambda self: self.__dict__.copy()
MyStructField30Patch1.__setstate__ = MyStructField30Patch1__setstate__

all_structs.append(MyStructFieldPatch)
MyStructFieldPatch.thrift_spec = (
  (-32, TType.STRUCT, 'structWithCustomDefault', [MyDataWithCustomDefaultPatch, MyDataWithCustomDefaultPatch.thrift_spec, False], None, 3, ), # -32
  (-31, TType.STRUCT, 'i32WithCustomDefault', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # -31
  (-30, TType.STRUCT, 'mapMap', [MyStructField30Patch, MyStructField30Patch.thrift_spec, False], None, 3, ), # -30
  (-29, TType.STRUCT, 'listMap', [MyStructField29Patch, MyStructField29Patch.thrift_spec, False], None, 3, ), # -29
  (-28, TType.STRUCT, 'optMapVal', [MyStructField28Patch, MyStructField28Patch.thrift_spec, False], None, 3, ), # -28
  (-27, TType.STRUCT, 'optSetVal', [MyStructField27Patch, MyStructField27Patch.thrift_spec, False], None, 3, ), # -27
  (-26, TType.STRUCT, 'optListVal', [MyStructField26Patch, MyStructField26Patch.thrift_spec, False], None, 3, ), # -26
  (-25, TType.STRUCT, 'optLateStructVal', [LateDefStructPatch, LateDefStructPatch.thrift_spec, False], None, 3, ), # -25
  (-24, TType.STRUCT, 'optStructVal', [MyDataPatch, MyDataPatch.thrift_spec, False], None, 3, ), # -24
  (-23, TType.STRUCT, 'optEnumVal', [MyStructField23Patch, MyStructField23Patch.thrift_spec, False], None, 3, ), # -23
  (-22, TType.STRUCT, 'optBinaryVal', [thrift.lib.thrift.patch.ttypes.BinaryPatch, thrift.lib.thrift.patch.ttypes.BinaryPatch.thrift_spec, False], None, 3, ), # -22
  (-21, TType.STRUCT, 'optStringVal', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # -21
  (-20, TType.STRUCT, 'optDoubleVal', [thrift.lib.thrift.patch.ttypes.DoublePatch, thrift.lib.thrift.patch.ttypes.DoublePatch.thrift_spec, False], None, 3, ), # -20
  (-19, TType.STRUCT, 'optFloatVal', [thrift.lib.thrift.patch.ttypes.FloatPatch, thrift.lib.thrift.patch.ttypes.FloatPatch.thrift_spec, False], None, 3, ), # -19
  (-18, TType.STRUCT, 'optI64Val', [thrift.lib.thrift.patch.ttypes.I64Patch, thrift.lib.thrift.patch.ttypes.I64Patch.thrift_spec, False], None, 3, ), # -18
  (-17, TType.STRUCT, 'optI32Val', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # -17
  (-16, TType.STRUCT, 'optI16Val', [thrift.lib.thrift.patch.ttypes.I16Patch, thrift.lib.thrift.patch.ttypes.I16Patch.thrift_spec, False], None, 3, ), # -16
  (-15, TType.STRUCT, 'optByteVal', [thrift.lib.thrift.patch.ttypes.BytePatch, thrift.lib.thrift.patch.ttypes.BytePatch.thrift_spec, False], None, 3, ), # -15
  (-14, TType.STRUCT, 'optBoolVal', [thrift.lib.thrift.patch.ttypes.BoolPatch, thrift.lib.thrift.patch.ttypes.BoolPatch.thrift_spec, False], None, 3, ), # -14
  (-13, TType.STRUCT, 'lateStructVal', [LateDefStructPatch, LateDefStructPatch.thrift_spec, False], None, 3, ), # -13
  (-12, TType.STRUCT, 'unionVal', [MyUnionPatch, MyUnionPatch.thrift_spec, False], None, 3, ), # -12
  (-11, TType.STRUCT, 'structVal', [MyDataPatch, MyDataPatch.thrift_spec, False], None, 3, ), # -11
  (-10, TType.STRUCT, 'enumVal', [MyStructField10Patch, MyStructField10Patch.thrift_spec, False], None, 3, ), # -10
  (-9, TType.STRUCT, 'binaryVal', [thrift.lib.thrift.patch.ttypes.BinaryPatch, thrift.lib.thrift.patch.ttypes.BinaryPatch.thrift_spec, False], None, 3, ), # -9
  (-8, TType.STRUCT, 'stringVal', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # -8
  (-7, TType.STRUCT, 'doubleVal', [thrift.lib.thrift.patch.ttypes.DoublePatch, thrift.lib.thrift.patch.ttypes.DoublePatch.thrift_spec, False], None, 3, ), # -7
  (-6, TType.STRUCT, 'floatVal', [thrift.lib.thrift.patch.ttypes.FloatPatch, thrift.lib.thrift.patch.ttypes.FloatPatch.thrift_spec, False], None, 3, ), # -6
  (-5, TType.STRUCT, 'i64Val', [thrift.lib.thrift.patch.ttypes.I64Patch, thrift.lib.thrift.patch.ttypes.I64Patch.thrift_spec, False], None, 3, ), # -5
  (-4, TType.STRUCT, 'i32Val', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # -4
  (-3, TType.STRUCT, 'i16Val', [thrift.lib.thrift.patch.ttypes.I16Patch, thrift.lib.thrift.patch.ttypes.I16Patch.thrift_spec, False], None, 3, ), # -3
  (-2, TType.STRUCT, 'byteVal', [thrift.lib.thrift.patch.ttypes.BytePatch, thrift.lib.thrift.patch.ttypes.BytePatch.thrift_spec, False], None, 3, ), # -2
  (-1, TType.STRUCT, 'boolVal', [thrift.lib.thrift.patch.ttypes.BoolPatch, thrift.lib.thrift.patch.ttypes.BoolPatch.thrift_spec, False], None, 3, ), # -1
  None, # 0
  (1, TType.STRUCT, 'structWithFieldCustomDefault', [MyDataPatch, MyDataPatch.thrift_spec, False], None, 3, ), # 1
)

MyStructFieldPatch.thrift_struct_annotations = {
}
MyStructFieldPatch.thrift_field_annotations = {
}

def MyStructFieldPatch__init__(self, structWithCustomDefault=None, i32WithCustomDefault=None, mapMap=None, listMap=None, optMapVal=None, optSetVal=None, optListVal=None, optLateStructVal=None, optStructVal=None, optEnumVal=None, optBinaryVal=None, optStringVal=None, optDoubleVal=None, optFloatVal=None, optI64Val=None, optI32Val=None, optI16Val=None, optByteVal=None, optBoolVal=None, lateStructVal=None, unionVal=None, structVal=None, enumVal=None, binaryVal=None, stringVal=None, doubleVal=None, floatVal=None, i64Val=None, i32Val=None, i16Val=None, byteVal=None, boolVal=None, structWithFieldCustomDefault=None,):
  self.structWithCustomDefault = structWithCustomDefault
  self.i32WithCustomDefault = i32WithCustomDefault
  self.mapMap = mapMap
  self.listMap = listMap
  self.optMapVal = optMapVal
  self.optSetVal = optSetVal
  self.optListVal = optListVal
  self.optLateStructVal = optLateStructVal
  self.optStructVal = optStructVal
  self.optEnumVal = optEnumVal
  self.optBinaryVal = optBinaryVal
  self.optStringVal = optStringVal
  self.optDoubleVal = optDoubleVal
  self.optFloatVal = optFloatVal
  self.optI64Val = optI64Val
  self.optI32Val = optI32Val
  self.optI16Val = optI16Val
  self.optByteVal = optByteVal
  self.optBoolVal = optBoolVal
  self.lateStructVal = lateStructVal
  self.unionVal = unionVal
  self.structVal = structVal
  self.enumVal = enumVal
  self.binaryVal = binaryVal
  self.stringVal = stringVal
  self.doubleVal = doubleVal
  self.floatVal = floatVal
  self.i64Val = i64Val
  self.i32Val = i32Val
  self.i16Val = i16Val
  self.byteVal = byteVal
  self.boolVal = boolVal
  self.structWithFieldCustomDefault = structWithFieldCustomDefault

MyStructFieldPatch.__init__ = MyStructFieldPatch__init__

def MyStructFieldPatch__setstate__(self, state):
  state.setdefault('structWithCustomDefault', None)
  state.setdefault('i32WithCustomDefault', None)
  state.setdefault('mapMap', None)
  state.setdefault('listMap', None)
  state.setdefault('optMapVal', None)
  state.setdefault('optSetVal', None)
  state.setdefault('optListVal', None)
  state.setdefault('optLateStructVal', None)
  state.setdefault('optStructVal', None)
  state.setdefault('optEnumVal', None)
  state.setdefault('optBinaryVal', None)
  state.setdefault('optStringVal', None)
  state.setdefault('optDoubleVal', None)
  state.setdefault('optFloatVal', None)
  state.setdefault('optI64Val', None)
  state.setdefault('optI32Val', None)
  state.setdefault('optI16Val', None)
  state.setdefault('optByteVal', None)
  state.setdefault('optBoolVal', None)
  state.setdefault('lateStructVal', None)
  state.setdefault('unionVal', None)
  state.setdefault('structVal', None)
  state.setdefault('enumVal', None)
  state.setdefault('binaryVal', None)
  state.setdefault('stringVal', None)
  state.setdefault('doubleVal', None)
  state.setdefault('floatVal', None)
  state.setdefault('i64Val', None)
  state.setdefault('i32Val', None)
  state.setdefault('i16Val', None)
  state.setdefault('byteVal', None)
  state.setdefault('boolVal', None)
  state.setdefault('structWithFieldCustomDefault', None)
  self.__dict__ = state

MyStructFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyStructFieldPatch.__setstate__ = MyStructFieldPatch__setstate__

all_structs.append(MyStructEnsureStruct)
MyStructEnsureStruct.thrift_spec = (
  (-32, TType.STRUCT, 'structWithCustomDefault', [MyDataWithCustomDefault, MyDataWithCustomDefault.thrift_spec, False], None, 1, ), # -32
  (-31, TType.I32, 'i32WithCustomDefault', None, None, 1, ), # -31
  (-30, TType.MAP, 'mapMap', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 1, ), # -30
  (-29, TType.LIST, 'listMap', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 1, ), # -29
  (-28, TType.MAP, 'optMapVal', (TType.STRING,True,TType.STRING,True), None, 1, ), # -28
  (-27, TType.SET, 'optSetVal', (TType.STRING,True), None, 1, ), # -27
  (-26, TType.LIST, 'optListVal', (TType.I16,None), None, 1, ), # -26
  (-25, TType.STRUCT, 'optLateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 1, ), # -25
  (-24, TType.STRUCT, 'optStructVal', [MyData, MyData.thrift_spec, False], None, 1, ), # -24
  (-23, TType.I32, 'optEnumVal', MyEnum, None, 1, ), # -23
  (-22, TType.STRING, 'optBinaryVal', False, None, 1, ), # -22
  (-21, TType.STRING, 'optStringVal', True, None, 1, ), # -21
  (-20, TType.DOUBLE, 'optDoubleVal', None, None, 1, ), # -20
  (-19, TType.FLOAT, 'optFloatVal', None, None, 1, ), # -19
  (-18, TType.I64, 'optI64Val', None, None, 1, ), # -18
  (-17, TType.I32, 'optI32Val', None, None, 1, ), # -17
  (-16, TType.I16, 'optI16Val', None, None, 1, ), # -16
  (-15, TType.BYTE, 'optByteVal', None, None, 1, ), # -15
  (-14, TType.BOOL, 'optBoolVal', None, None, 1, ), # -14
  (-13, TType.STRUCT, 'lateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 1, ), # -13
  (-12, TType.STRUCT, 'unionVal', [MyUnion, MyUnion.thrift_spec, True], None, 1, ), # -12
  (-11, TType.STRUCT, 'structVal', [MyData, MyData.thrift_spec, False], None, 1, ), # -11
  (-10, TType.I32, 'enumVal', MyEnum, None, 1, ), # -10
  (-9, TType.STRING, 'binaryVal', False, None, 1, ), # -9
  (-8, TType.STRING, 'stringVal', True, None, 1, ), # -8
  (-7, TType.DOUBLE, 'doubleVal', None, None, 1, ), # -7
  (-6, TType.FLOAT, 'floatVal', None, None, 1, ), # -6
  (-5, TType.I64, 'i64Val', None, None, 1, ), # -5
  (-4, TType.I32, 'i32Val', None, None, 1, ), # -4
  (-3, TType.I16, 'i16Val', None, None, 1, ), # -3
  (-2, TType.BYTE, 'byteVal', None, None, 1, ), # -2
  (-1, TType.BOOL, 'boolVal', None, None, 1, ), # -1
  None, # 0
  (1, TType.STRUCT, 'structWithFieldCustomDefault', [MyData, MyData.thrift_spec, False], None, 1, ), # 1
)

MyStructEnsureStruct.thrift_struct_annotations = {
}
MyStructEnsureStruct.thrift_field_annotations = {
  -32: {
    "thrift.box": "",
  },
  -25: {
    "thrift.box": "",
  },
  -24: {
    "thrift.box": "",
  },
  -13: {
    "thrift.box": "",
  },
  -12: {
    "thrift.box": "",
  },
  -11: {
    "thrift.box": "",
  },
  1: {
    "thrift.box": "",
  },
}

def MyStructEnsureStruct__init__(self, structWithCustomDefault=None, i32WithCustomDefault=None, mapMap=None, listMap=None, optMapVal=None, optSetVal=None, optListVal=None, optLateStructVal=None, optStructVal=None, optEnumVal=None, optBinaryVal=None, optStringVal=None, optDoubleVal=None, optFloatVal=None, optI64Val=None, optI32Val=None, optI16Val=None, optByteVal=None, optBoolVal=None, lateStructVal=None, unionVal=None, structVal=None, enumVal=None, binaryVal=None, stringVal=None, doubleVal=None, floatVal=None, i64Val=None, i32Val=None, i16Val=None, byteVal=None, boolVal=None, structWithFieldCustomDefault=None,):
  self.structWithCustomDefault = structWithCustomDefault
  self.i32WithCustomDefault = i32WithCustomDefault
  self.mapMap = mapMap
  self.listMap = listMap
  self.optMapVal = optMapVal
  self.optSetVal = optSetVal
  self.optListVal = optListVal
  self.optLateStructVal = optLateStructVal
  self.optStructVal = optStructVal
  self.optEnumVal = optEnumVal
  self.optBinaryVal = optBinaryVal
  self.optStringVal = optStringVal
  self.optDoubleVal = optDoubleVal
  self.optFloatVal = optFloatVal
  self.optI64Val = optI64Val
  self.optI32Val = optI32Val
  self.optI16Val = optI16Val
  self.optByteVal = optByteVal
  self.optBoolVal = optBoolVal
  self.lateStructVal = lateStructVal
  self.unionVal = unionVal
  self.structVal = structVal
  self.enumVal = enumVal
  self.binaryVal = binaryVal
  self.stringVal = stringVal
  self.doubleVal = doubleVal
  self.floatVal = floatVal
  self.i64Val = i64Val
  self.i32Val = i32Val
  self.i16Val = i16Val
  self.byteVal = byteVal
  self.boolVal = boolVal
  self.structWithFieldCustomDefault = structWithFieldCustomDefault

MyStructEnsureStruct.__init__ = MyStructEnsureStruct__init__

def MyStructEnsureStruct__setstate__(self, state):
  state.setdefault('structWithCustomDefault', None)
  state.setdefault('i32WithCustomDefault', None)
  state.setdefault('mapMap', None)
  state.setdefault('listMap', None)
  state.setdefault('optMapVal', None)
  state.setdefault('optSetVal', None)
  state.setdefault('optListVal', None)
  state.setdefault('optLateStructVal', None)
  state.setdefault('optStructVal', None)
  state.setdefault('optEnumVal', None)
  state.setdefault('optBinaryVal', None)
  state.setdefault('optStringVal', None)
  state.setdefault('optDoubleVal', None)
  state.setdefault('optFloatVal', None)
  state.setdefault('optI64Val', None)
  state.setdefault('optI32Val', None)
  state.setdefault('optI16Val', None)
  state.setdefault('optByteVal', None)
  state.setdefault('optBoolVal', None)
  state.setdefault('lateStructVal', None)
  state.setdefault('unionVal', None)
  state.setdefault('structVal', None)
  state.setdefault('enumVal', None)
  state.setdefault('binaryVal', None)
  state.setdefault('stringVal', None)
  state.setdefault('doubleVal', None)
  state.setdefault('floatVal', None)
  state.setdefault('i64Val', None)
  state.setdefault('i32Val', None)
  state.setdefault('i16Val', None)
  state.setdefault('byteVal', None)
  state.setdefault('boolVal', None)
  state.setdefault('structWithFieldCustomDefault', None)
  self.__dict__ = state

MyStructEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStructEnsureStruct.__setstate__ = MyStructEnsureStruct__setstate__

all_structs.append(LateDefStructPatch)
LateDefStructPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [LateDefStructFieldPatch, LateDefStructFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [LateDefStructEnsureStruct, LateDefStructEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [LateDefStructFieldPatch, LateDefStructFieldPatch.thrift_spec, False], None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.I16,None), None, 3, ), # 7
)

LateDefStructPatch.thrift_struct_annotations = {
}
LateDefStructPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def LateDefStructPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None, remove=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch
  self.remove = remove

LateDefStructPatch.__init__ = LateDefStructPatch__init__

def LateDefStructPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  self.__dict__ = state

LateDefStructPatch.__getstate__ = lambda self: self.__dict__.copy()
LateDefStructPatch.__setstate__ = LateDefStructPatch__setstate__

all_structs.append(LateDefStructFieldPatch)
LateDefStructFieldPatch.thrift_spec = (
)

LateDefStructFieldPatch.thrift_struct_annotations = {
}
LateDefStructFieldPatch.thrift_field_annotations = {
}

all_structs.append(LateDefStructEnsureStruct)
LateDefStructEnsureStruct.thrift_spec = (
)

LateDefStructEnsureStruct.thrift_struct_annotations = {
}
LateDefStructEnsureStruct.thrift_field_annotations = {
}

all_structs.append(RecursivePatch)
RecursivePatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [Recursive, Recursive.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [RecursiveFieldPatch, RecursiveFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [RecursiveEnsureStruct, RecursiveEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [RecursiveFieldPatch, RecursiveFieldPatch.thrift_spec, False], None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.I16,None), None, 3, ), # 7
)

RecursivePatch.thrift_struct_annotations = {
}
RecursivePatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def RecursivePatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None, remove=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch
  self.remove = remove

RecursivePatch.__init__ = RecursivePatch__init__

def RecursivePatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  self.__dict__ = state

RecursivePatch.__getstate__ = lambda self: self.__dict__.copy()
RecursivePatch.__setstate__ = RecursivePatch__setstate__

all_structs.append(RecursiveField1Patch)
RecursiveField1Patch.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.STRUCT,[Recursive, Recursive.thrift_spec, False]), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
)

RecursiveField1Patch.thrift_struct_annotations = {
}
RecursiveField1Patch.thrift_field_annotations = {
}

def RecursiveField1Patch__init__(self, assign=None, clear=None,):
  self.assign = assign
  self.clear = clear

RecursiveField1Patch.__init__ = RecursiveField1Patch__init__

def RecursiveField1Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  self.__dict__ = state

RecursiveField1Patch.__getstate__ = lambda self: self.__dict__.copy()
RecursiveField1Patch.__setstate__ = RecursiveField1Patch__setstate__

all_structs.append(RecursiveFieldPatch)
RecursiveFieldPatch.thrift_spec = (
  (-1, TType.STRUCT, 'nodes', [RecursiveField1Patch, RecursiveField1Patch.thrift_spec, False], None, 3, ), # -1
)

RecursiveFieldPatch.thrift_struct_annotations = {
}
RecursiveFieldPatch.thrift_field_annotations = {
}

def RecursiveFieldPatch__init__(self, nodes=None,):
  self.nodes = nodes

RecursiveFieldPatch.__init__ = RecursiveFieldPatch__init__

def RecursiveFieldPatch__setstate__(self, state):
  state.setdefault('nodes', None)
  self.__dict__ = state

RecursiveFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
RecursiveFieldPatch.__setstate__ = RecursiveFieldPatch__setstate__

all_structs.append(RecursiveEnsureStruct)
RecursiveEnsureStruct.thrift_spec = (
  (-1, TType.MAP, 'nodes', (TType.STRING,True,TType.STRUCT,[Recursive, Recursive.thrift_spec, False]), None, 1, ), # -1
)

RecursiveEnsureStruct.thrift_struct_annotations = {
}
RecursiveEnsureStruct.thrift_field_annotations = {
}

def RecursiveEnsureStruct__init__(self, nodes=None,):
  self.nodes = nodes

RecursiveEnsureStruct.__init__ = RecursiveEnsureStruct__init__

def RecursiveEnsureStruct__setstate__(self, state):
  state.setdefault('nodes', None)
  self.__dict__ = state

RecursiveEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
RecursiveEnsureStruct.__setstate__ = RecursiveEnsureStruct__setstate__

all_structs.append(BarPatch)
BarPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [Bar, Bar.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [BarFieldPatch, BarFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [BarEnsureStruct, BarEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [BarFieldPatch, BarFieldPatch.thrift_spec, False], None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.I16,None), None, 3, ), # 7
)

BarPatch.thrift_struct_annotations = {
}
BarPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def BarPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None, remove=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch
  self.remove = remove

BarPatch.__init__ = BarPatch__init__

def BarPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  self.__dict__ = state

BarPatch.__getstate__ = lambda self: self.__dict__.copy()
BarPatch.__setstate__ = BarPatch__setstate__

all_structs.append(BarFieldPatch)
BarFieldPatch.thrift_spec = (
  (-1, TType.STRUCT, 'loop', [LoopPatch, LoopPatch.thrift_spec, False], None, 3, ), # -1
)

BarFieldPatch.thrift_struct_annotations = {
}
BarFieldPatch.thrift_field_annotations = {
}

def BarFieldPatch__init__(self, loop=None,):
  self.loop = loop

BarFieldPatch.__init__ = BarFieldPatch__init__

def BarFieldPatch__setstate__(self, state):
  state.setdefault('loop', None)
  self.__dict__ = state

BarFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
BarFieldPatch.__setstate__ = BarFieldPatch__setstate__

all_structs.append(BarEnsureStruct)
BarEnsureStruct.thrift_spec = (
  (-1, TType.STRUCT, 'loop', [Loop, Loop.thrift_spec, False], None, 1, ), # -1
)

BarEnsureStruct.thrift_struct_annotations = {
}
BarEnsureStruct.thrift_field_annotations = {
  -1: {
    "thrift.box": "",
  },
}

def BarEnsureStruct__init__(self, loop=None,):
  self.loop = loop

BarEnsureStruct.__init__ = BarEnsureStruct__init__

def BarEnsureStruct__setstate__(self, state):
  state.setdefault('loop', None)
  self.__dict__ = state

BarEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
BarEnsureStruct.__setstate__ = BarEnsureStruct__setstate__

all_structs.append(LoopPatch)
LoopPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [Loop, Loop.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
)

LoopPatch.thrift_struct_annotations = {
}
LoopPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def LoopPatch__init__(self, assign=None, clear=None,):
  self.assign = assign
  self.clear = clear

LoopPatch.__init__ = LoopPatch__init__

def LoopPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  self.__dict__ = state

LoopPatch.__getstate__ = lambda self: self.__dict__.copy()
LoopPatch.__setstate__ = LoopPatch__setstate__

fix_spec(all_structs)
del all_structs
